{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/yilia/source/main.0cf68a.css","path":"main.0cf68a.css","modified":0,"renderable":1},{"_id":"themes/yilia/source/slider.e37972.js","path":"slider.e37972.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/main.0cf68a.js","path":"main.0cf68a.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/mobile.992cbe.js","path":"mobile.992cbe.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/default-skin.b257fa.svg","path":"fonts/default-skin.b257fa.svg","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.16acc2.ttf","path":"fonts/iconfont.16acc2.ttf","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.45d7ee.svg","path":"fonts/iconfont.45d7ee.svg","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.b322fa.eot","path":"fonts/iconfont.b322fa.eot","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/tooltip.4004ff.svg","path":"fonts/tooltip.4004ff.svg","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.8c627f.woff","path":"fonts/iconfont.8c627f.woff","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/default-skin.png","path":"img/default-skin.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/preloader.gif","path":"img/preloader.gif","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","path":"img/scrollbar_arrow.png","modified":0,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"86a2dec57c784f4d4bde941d0ad3cc6ec127ea76","modified":1530625771024},{"_id":"themes/yilia/README.md","hash":"1bf755806af9d8874bd22e1abbdaaa24328ef4dc","modified":1530625470421},{"_id":"themes/yilia/_config.yml","hash":"d7121ed8ec38fad25636b5bf0f1d1078771872a2","modified":1530625470422},{"_id":"themes/yilia/package.json","hash":"367cb9579d35968a942c243ab248a5f5ebfaf462","modified":1530625470433},{"_id":"themes/yilia/webpack.config.js","hash":"05ba46a4ae744272f5312e684928910dccad3755","modified":1530625470455},{"_id":"source/_draft/machine-learning-decision-tree.md","hash":"45db9693bfe749704288dbb33e613b87cb23789c","modified":1530625470391},{"_id":"source/_posts/bus-waiting-paradox.md","hash":"1a729422f7c4f9afe1c9bd8ee1ead973e5736d23","modified":1530625470391},{"_id":"source/_posts/connector-wechat-bot-1.md","hash":"cf4b1238093e75ecc9f73b75ba409441eab9a5ac","modified":1530625470392},{"_id":"source/_posts/connector-wechat-bot-2.md","hash":"4de73b30d476e55d650a5630701a56b7aabcca02","modified":1530625470392},{"_id":"source/_posts/connector-wechat-bot-3.md","hash":"1ca24488260c78762063f8cc0791ce4e986babbb","modified":1530625470393},{"_id":"source/_posts/connector-wechat-bot-4.md","hash":"4c5a0aab1a38b97834309da1224c623eb7f74940","modified":1530625470393},{"_id":"source/_posts/leetcode-2.md","hash":"d40c55320cb8681117542aafa6ff699a47dbc93b","modified":1530626759394},{"_id":"source/_posts/leetcode-189.md","hash":"ec1b052f0808fa341ed9d2c9469ae8bd8ceda963","modified":1530626764600},{"_id":"source/_posts/machine-learning-basic-concepts.md","hash":"5c3169b682a2b76c2856287ee8f8b1e3ea4a45d5","modified":1530625470393},{"_id":"source/_posts/tldr-pages.md","hash":"e7fb66ebdfe573d39f94be571236086de420271b","modified":1530625470393},{"_id":"source/_posts/weibo-login-20lines.md","hash":"18e76bd8e4d4f610775f72e8351e44f4684d142d","modified":1530625470394},{"_id":"source/_posts/youtube-dl.md","hash":"a545b51257245d3a1e4ceb5964072c88822b6757","modified":1530625470394},{"_id":"themes/yilia/languages/fr.yml","hash":"84ab164b37c6abf625473e9a0c18f6f815dd5fd9","modified":1530625470422},{"_id":"themes/yilia/languages/default.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1530625470422},{"_id":"themes/yilia/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1530625470422},{"_id":"themes/yilia/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1530625470423},{"_id":"themes/yilia/languages/zh-tw.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1530625470423},{"_id":"themes/yilia/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1530625470423},{"_id":"themes/yilia/languages/zh-CN.yml","hash":"ca40697097ab0b3672a80b455d3f4081292d1eed","modified":1530625470423},{"_id":"themes/yilia/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1530625470431},{"_id":"themes/yilia/layout/index.ejs","hash":"a35dc900203f9d8dd863ea4c1722198d6d457ec8","modified":1530625470432},{"_id":"themes/yilia/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1530625470432},{"_id":"themes/yilia/layout/layout.ejs","hash":"0a332bdbd3b86c231d690614687f5b97186b85d5","modified":1530625470432},{"_id":"themes/yilia/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1530625470432},{"_id":"themes/yilia/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1530625470433},{"_id":"themes/yilia/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1530625470433},{"_id":"themes/yilia/source/main.0cf68a.css","hash":"ddf6e2c6b953c2c59a3c271e6070010a4cc81cf9","modified":1530625470452},{"_id":"themes/yilia/source-src/css.ejs","hash":"94dbdb02ca11849e415d54fb28546a598f2cffb1","modified":1530625470433},{"_id":"themes/yilia/source/slider.e37972.js","hash":"6dec4e220c89049037eebc44404abd8455d22ad7","modified":1530625470455},{"_id":"themes/yilia/source-src/script.ejs","hash":"c21381e1317db7bb157f1d182b8c088cb7cba411","modified":1530625470448},{"_id":"themes/yilia/layout/_partial/toc.ejs","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1530625470431},{"_id":"themes/yilia/source/main.0cf68a.js","hash":"993fadeb5f6d296e9d997a49ee20dc97333ceab7","modified":1530625470453},{"_id":"themes/yilia/source/mobile.992cbe.js","hash":"01b35e71e37aa2849664eb5daf26daede2278398","modified":1530625470454},{"_id":"themes/yilia/layout/_partial/after-footer.ejs","hash":"b86b248720ad415ec1b5fee53fb583776c776f83","modified":1530625470424},{"_id":"themes/yilia/layout/_partial/archive-post.ejs","hash":"1f7d4819b7f67602c4a1b99871808d2160b60978","modified":1530625470424},{"_id":"themes/yilia/layout/_partial/archive.ejs","hash":"a6e94061ac55b9eb55275f87b608d62f6ea35659","modified":1530625470424},{"_id":"themes/yilia/layout/_partial/article.ejs","hash":"630c6ec866d056657d3d91e34b4c64eb993c0654","modified":1530625470425},{"_id":"themes/yilia/layout/_partial/aside.ejs","hash":"8edbd7993b9b061611a193533a664e2e85eae748","modified":1530625470425},{"_id":"themes/yilia/layout/_partial/baidu-analytics.ejs","hash":"f0e6e88f9f7eb08b8fe51449a8a3016273507924","modified":1530625470425},{"_id":"themes/yilia/layout/_partial/css.ejs","hash":"236f8a377b2e4e35754319c3029bcd4a4115431d","modified":1530625470425},{"_id":"themes/yilia/layout/_partial/footer.ejs","hash":"f2994e0acd1d606ebf4680afc4fa652e148ccf4e","modified":1530625470426},{"_id":"themes/yilia/layout/_partial/head.ejs","hash":"64f092186b5a744aa1603ce22bb1d44a34446add","modified":1530625470426},{"_id":"themes/yilia/layout/_partial/header.ejs","hash":"6387a93dad7c3d778eb91e3821852fbf6813880c","modified":1530625470426},{"_id":"themes/yilia/layout/_partial/left-col.ejs","hash":"183d7ca4ba8e7c80694ffdc8cf39957092238346","modified":1530625470427},{"_id":"themes/yilia/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1530625470426},{"_id":"themes/yilia/layout/_partial/mathjax.ejs","hash":"151a1ef2173ba7b6789d349f0f8da89616cc1394","modified":1530625470427},{"_id":"themes/yilia/layout/_partial/mobile-nav.ejs","hash":"7fbbfabf5e29525b24ada14613c21a26789132b4","modified":1530625470427},{"_id":"themes/yilia/layout/_partial/tools.ejs","hash":"c41341b9618e591538e1136a2d1637587c1bbd90","modified":1530625470431},{"_id":"themes/yilia/layout/_partial/viewer.ejs","hash":"e495790b2abe2290875817e42bd505bc611d3e26","modified":1530625470431},{"_id":"themes/yilia/source/fonts/default-skin.b257fa.svg","hash":"2ac727c9e092331d35cce95af209ccfac6d4c7c7","modified":1530625470449},{"_id":"themes/yilia/source/fonts/iconfont.16acc2.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1530625470449},{"_id":"themes/yilia/source/fonts/iconfont.45d7ee.svg","hash":"f9304e5714d20861be7d8f4d36687e88e86b9e1b","modified":1530625470450},{"_id":"themes/yilia/source/fonts/iconfont.b322fa.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1530625470450},{"_id":"themes/yilia/source/fonts/tooltip.4004ff.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1530625470451},{"_id":"themes/yilia/source/fonts/iconfont.8c627f.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1530625470450},{"_id":"themes/yilia/source/img/default-skin.png","hash":"ed95a8e40a2c3478c5915376acb8e5f33677f24d","modified":1530625470451},{"_id":"themes/yilia/source/img/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1530625470451},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1530625470451},{"_id":"themes/yilia/source-src/css/_core.scss","hash":"24f347a2412abbf58318369152504da9538f8d3b","modified":1530625470434},{"_id":"themes/yilia/source-src/css/_function.scss","hash":"93a50dd19a93485712da1f8d0a1672482dd1eabc","modified":1530625470434},{"_id":"themes/yilia/source-src/css/archive.scss","hash":"7d27e22ac898e8fafec14549e940c73cbea1fba8","modified":1530625470434},{"_id":"themes/yilia/source-src/css/article-inner.scss","hash":"d79f2d35a06de83a2a226ca790b7a0a34789c115","modified":1530625470435},{"_id":"themes/yilia/source-src/css/article-main.scss","hash":"3fad68bd74260326f83090b0974dd80707e7bac7","modified":1530625470435},{"_id":"themes/yilia/source-src/css/article-nav.scss","hash":"43e507f2a48504079afd9471353337e23ca47470","modified":1530625470435},{"_id":"themes/yilia/source-src/css/article.scss","hash":"0f6d61af99ed4db87f8589db1feaea7747b55963","modified":1530625470435},{"_id":"themes/yilia/source-src/css/aside.scss","hash":"578a67464dd0f542197f7fcee158c991db058563","modified":1530625470436},{"_id":"themes/yilia/source-src/css/comment.scss","hash":"cafe3834017a3bf47420f37543725025225a2c89","modified":1530625470436},{"_id":"themes/yilia/source-src/css/fonts.scss","hash":"97b8fba41c914145710b90091f400b845879577f","modified":1530625470438},{"_id":"themes/yilia/source-src/css/footer.scss","hash":"7c995410b25baaf61dfc5e148e22ca60330abcd3","modified":1530625470440},{"_id":"themes/yilia/source-src/css/global.scss","hash":"b4cb4f45a55d4250cd9056f76dab2a3c0dabcec4","modified":1530625470440},{"_id":"themes/yilia/source-src/css/grid.scss","hash":"849a29fcd7150214fcf7b9715fa5dc71d1f9b896","modified":1530625470441},{"_id":"themes/yilia/source-src/css/mobile-slider.scss","hash":"f053c609d84df0dd9eee1d11ddf0c19163a456be","modified":1530625470442},{"_id":"themes/yilia/source-src/css/left.scss","hash":"0d30c0e7cdb831c3881a017006c782f2214ac195","modified":1530625470442},{"_id":"themes/yilia/source-src/css/main.scss","hash":"2f86a014af93583caba78a563d9549826bf28294","modified":1530625470442},{"_id":"themes/yilia/source-src/css/mobile.scss","hash":"ace041d72f95b419f6a5e443191703c2b62007f4","modified":1530625470442},{"_id":"themes/yilia/source-src/css/reward.scss","hash":"80a4fcf9171d4a33235da96ac8a2b7dcabc45dfb","modified":1530625470443},{"_id":"themes/yilia/source-src/css/page.scss","hash":"bf206bb7f7d0967bc8b7fdf01b7ffc99aff9ba88","modified":1530625470443},{"_id":"themes/yilia/source-src/css/scroll.scss","hash":"9c8dfd1c76854ef063494ca76fac6360b391ed6d","modified":1530625470443},{"_id":"themes/yilia/source-src/css/share.scss","hash":"150c6425f6582e7ec78a873256ce49c9930e8805","modified":1530625470443},{"_id":"themes/yilia/source-src/css/social.scss","hash":"724162ccf3977e70a45d189abfaa20b6e2fba87b","modified":1530625470444},{"_id":"themes/yilia/source-src/css/tags.scss","hash":"ac67a3c7097849206244db9b0ba91daaba017ef5","modified":1530625470444},{"_id":"themes/yilia/source-src/css/tags-cloud.scss","hash":"c8aa84fca93862d3caae77c552873b8610f33327","modified":1530625470444},{"_id":"themes/yilia/source-src/css/tools.scss","hash":"1b1aa0908e58cf942b28e3881d07c5573c4129e1","modified":1530625470444},{"_id":"themes/yilia/source-src/css/tooltip.scss","hash":"53d5a554bc2f38e9bb3d26400a47767013c05216","modified":1530625470445},{"_id":"themes/yilia/source-src/js/aside.js","hash":"754f771264548a6c5a8ad842908e59ae4e7ed099","modified":1530625470446},{"_id":"themes/yilia/source-src/js/browser.js","hash":"04095b38cfd4316a23f8eb14b1ffaf95f78a4260","modified":1530625470446},{"_id":"themes/yilia/source-src/js/anm.js","hash":"4a4c5d82b09a3063f91a434388e6aa064fd7fd98","modified":1530625470446},{"_id":"themes/yilia/source-src/js/Q.js","hash":"d011af172064b6c6e0c7051d8f9879373ddac113","modified":1530625470445},{"_id":"themes/yilia/source-src/js/fix.js","hash":"d6782d53c992e712af39c84e804eccaf38830b94","modified":1530625470446},{"_id":"themes/yilia/source-src/js/main.js","hash":"3894e60827c817319e43c9ff3ed045fc3d7336ce","modified":1530625470446},{"_id":"themes/yilia/source-src/js/mobile.js","hash":"4d823b039fd296d24a454eae5a798b93c44560cb","modified":1530625470447},{"_id":"themes/yilia/source-src/css/highlight.scss","hash":"3719994c2c9393813cc1d42b657205c368a329cb","modified":1530625470441},{"_id":"themes/yilia/source-src/js/report.js","hash":"4f1d9a18a936ce40b037f636a39127dd19175b6e","modified":1530625470447},{"_id":"themes/yilia/source-src/js/share.js","hash":"b090f82cf80cba7da764753906d9e2cc2acdf30d","modified":1530625470447},{"_id":"themes/yilia/source-src/js/slider.js","hash":"e846bcc5aac9c68b93f7b8de353df54d8d29f666","modified":1530625470447},{"_id":"themes/yilia/source-src/js/util.js","hash":"8456e9d6b19532742582c99b2fb9d09e146e1c58","modified":1530625470448},{"_id":"themes/yilia/source-src/js/viewer.js","hash":"2577deb6a9fe4f5436360b2ce9afcc7f9a7f0116","modified":1530625470448},{"_id":"themes/yilia/layout/_partial/script.ejs","hash":"4cb685f07e89dd5175c2a576e73a1a957aec5637","modified":1530625470431},{"_id":"themes/yilia/layout/_partial/post/category.ejs","hash":"0809a4829aabeb4e911a3ed04ec28db4df7dfe3f","modified":1530625470427},{"_id":"themes/yilia/layout/_partial/post/changyan.ejs","hash":"5f99b55980da64a723a8e14d5a7daba0d6504647","modified":1530625470428},{"_id":"themes/yilia/layout/_partial/post/date.ejs","hash":"ef71c4081e866a494367575c59610e7e6339ece0","modified":1530625470428},{"_id":"themes/yilia/layout/_partial/post/duoshuo.ejs","hash":"e8399025ed3b980aedb821c92855889f5f12fd5b","modified":1530625470428},{"_id":"themes/yilia/layout/_partial/post/gitment.ejs","hash":"e68bbac9ffb1ad27b56837c9abad6ed6bb7daa0c","modified":1530625470428},{"_id":"themes/yilia/layout/_partial/post/nav.ejs","hash":"1036c8e4e1a7bc935ba173744da735a0d6ed09cd","modified":1530625470429},{"_id":"themes/yilia/layout/_partial/post/share.ejs","hash":"5dccfbe165b23a101f1333cc65ed8efbd197453c","modified":1530625470429},{"_id":"themes/yilia/layout/_partial/post/tag.ejs","hash":"2e783e68755abb852760eb0e627a3fbb50a05a55","modified":1530625470429},{"_id":"themes/yilia/layout/_partial/post/wangyiyun.ejs","hash":"ea41c462168d9697caef9485862e9cac718a12c1","modified":1530625470429},{"_id":"themes/yilia/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1530625470429},{"_id":"themes/yilia/source-src/css/core/_media-queries.scss","hash":"491ab3378d5c11005ba65c607608bb36b368a9d5","modified":1530625470437},{"_id":"themes/yilia/source-src/css/core/_animation.scss","hash":"63a37f26276f9207405afe0f2d65339ce295bbaf","modified":1530625470436},{"_id":"themes/yilia/source-src/css/core/_mixin.scss","hash":"3bba5c77bad5981eac859fe05c9561d580ba7fa9","modified":1530625470437},{"_id":"themes/yilia/source-src/css/core/_variables.scss","hash":"fb511c505d1309249f21dc577d4ad2bad99a764f","modified":1530625470438},{"_id":"themes/yilia/source-src/css/core/_reset.scss","hash":"fab871fa93bd542e76a71a56428f2994a4aaf443","modified":1530625470437},{"_id":"themes/yilia/source-src/css/fonts/iconfont.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1530625470439},{"_id":"themes/yilia/source-src/css/fonts/iconfont.svg","hash":"f9304e5714d20861be7d8f4d36687e88e86b9e1b","modified":1530625470439},{"_id":"themes/yilia/source-src/css/fonts/iconfont.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1530625470440},{"_id":"themes/yilia/source-src/css/fonts/iconfont.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1530625470440},{"_id":"themes/yilia/source-src/css/img/checkered-pattern.png","hash":"049262fa0886989d750637b264bed34ab51c23c8","modified":1530625470441},{"_id":"themes/yilia/source-src/css/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1530625470442},{"_id":"themes/yilia/source-src/css/img/tooltip.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1530625470442},{"_id":"public/content.json","hash":"4db6767567526060ed2b09dea5342e6c1eb23fde","modified":1530626769329},{"_id":"public/2018/05/bus-waiting-paradox/index.html","hash":"7657f298c43c7475f2ffa90de9af6703911cf08f","modified":1530626769590},{"_id":"public/2017/09/tldr-pages/index.html","hash":"90f702b27769db11e1913f32ed7b1e17e33a4593","modified":1530626540223},{"_id":"public/2017/07/machine-learning-basic-concepts/index.html","hash":"7e045583df104bd1f89e165bccf5661a9ad9f502","modified":1530626540233},{"_id":"public/2017/07/weibo-login-20lines/index.html","hash":"42b19991557dca5cea68fa86078b7ec3d518f7ae","modified":1530626540233},{"_id":"public/2017/07/youtube-dl/index.html","hash":"b3ccf480ac10154be86a0fd177315d87d05fdf9f","modified":1530626540233},{"_id":"public/2017/06/connector-wechat-bot-3/index.html","hash":"3915506831f5f7f80a19f3a41e03e9e04b41f0a0","modified":1530626540233},{"_id":"public/2017/06/connector-wechat-bot-4/index.html","hash":"4b1dfc2a360c0fbbd81696ef81bebb8b9bcaaa6d","modified":1530626540233},{"_id":"public/2017/06/connector-wechat-bot-2/index.html","hash":"f86bfe69a9bff64e8ad8580f0530226408a9aeea","modified":1530626540234},{"_id":"public/2017/06/connector-wechat-bot-1/index.html","hash":"65158fcd871669093ea1cb4dc440aaa1ab8f29b3","modified":1530626540234},{"_id":"public/archives/index.html","hash":"c53cbb6516fa1be6234fb36959fd5b9df1db024a","modified":1530626769591},{"_id":"public/archives/2017/index.html","hash":"8d822caef0b2dad8e42376e48f699001cdf92e84","modified":1530626540234},{"_id":"public/archives/2017/06/index.html","hash":"4751c5120029d97077e8f3feedcd00f5a047024b","modified":1530626540234},{"_id":"public/archives/2017/07/index.html","hash":"516afb442f5bf84a0fdddd323ba9ca5492978d23","modified":1530626540234},{"_id":"public/archives/2017/09/index.html","hash":"2ab38f3f939cc1655014f65d7b1272b8e07007aa","modified":1530626540235},{"_id":"public/archives/2018/index.html","hash":"8712116dad038e91f450fbda1f0c38141ee43d41","modified":1530626769591},{"_id":"public/archives/2018/05/index.html","hash":"2e80a6dd92ace17e7e90380dccd505ec35687854","modified":1530626540235},{"_id":"public/categories/计算机课堂/index.html","hash":"7a2c6203c5e7cf5d1dee756dabc80a021694e391","modified":1530626540235},{"_id":"public/categories/软件推荐/index.html","hash":"2174c5c2e3b50a31836b1d3daa23657d5a0056ff","modified":1530626540235},{"_id":"public/index.html","hash":"f8845fef9b68410c6197f3179626faedd5c32787","modified":1530626769592},{"_id":"public/tags/Python/index.html","hash":"d8b79141bcdcfdb32edee427f74a47ae240bb584","modified":1530626769592},{"_id":"public/tags/聊天机器人/index.html","hash":"6c3e775d80daf9ce106e6b82d419ace21ccee308","modified":1530626540235},{"_id":"public/tags/概率论/index.html","hash":"71a86bc6e9c86af7bb9784197fed851ce81c40af","modified":1530626540236},{"_id":"public/tags/统计学/index.html","hash":"7bee7fe8c6b57fbdf1856c79fae0ce3739c66047","modified":1530626540236},{"_id":"public/tags/软件/index.html","hash":"f112d8f4a79158bdf7f03d3f18f5710ace764d24","modified":1530626540236},{"_id":"public/tags/命令行/index.html","hash":"9c15bbadcdc6fb0030cb6ea025d467379c2d4cbf","modified":1530626540236},{"_id":"public/tags/爬虫/index.html","hash":"cb4510e56722f2ae76b626a0bc3a95a7f23ef64f","modified":1530626540236},{"_id":"public/tags/机器学习/index.html","hash":"48d9c3fbf476e5cf66ee2750426a9ad8244a334e","modified":1530626540236},{"_id":"public/fonts/default-skin.b257fa.svg","hash":"2ac727c9e092331d35cce95af209ccfac6d4c7c7","modified":1530626350308},{"_id":"public/fonts/iconfont.16acc2.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1530626350308},{"_id":"public/fonts/iconfont.45d7ee.svg","hash":"f9304e5714d20861be7d8f4d36687e88e86b9e1b","modified":1530626350308},{"_id":"public/fonts/iconfont.b322fa.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1530626350308},{"_id":"public/fonts/tooltip.4004ff.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1530626350309},{"_id":"public/fonts/iconfont.8c627f.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1530626350309},{"_id":"public/img/default-skin.png","hash":"ed95a8e40a2c3478c5915376acb8e5f33677f24d","modified":1530626350309},{"_id":"public/img/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1530626350309},{"_id":"public/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1530626350309},{"_id":"public/main.0cf68a.css","hash":"ddf6e2c6b953c2c59a3c271e6070010a4cc81cf9","modified":1530626350316},{"_id":"public/slider.e37972.js","hash":"6dec4e220c89049037eebc44404abd8455d22ad7","modified":1530626350316},{"_id":"public/main.0cf68a.js","hash":"993fadeb5f6d296e9d997a49ee20dc97333ceab7","modified":1530626350316},{"_id":"public/mobile.992cbe.js","hash":"01b35e71e37aa2849664eb5daf26daede2278398","modified":1530626350316},{"_id":"public/2018/07/leetcode-189/index.html","hash":"07e0f5fd8ae51972bc6065f5e0acf64bc6627e3c","modified":1530626769590},{"_id":"public/archives/2018/07/index.html","hash":"28edf4bdaf71d601f117db86c9a89b662ccfdfd0","modified":1530626769591},{"_id":"public/categories/解题报告/index.html","hash":"4c02def4247fc71b78b4a8090178571ba12f9df3","modified":1530626769592},{"_id":"public/tags/解题报告/index.html","hash":"926b04d312b0e3bf5a5a54c485471a8431a23397","modified":1530626769592},{"_id":"public/tags/LeetCode/index.html","hash":"0fd52fb34a112732abc0fe6f3162a4b93d8615b3","modified":1530626769593},{"_id":"public/tags/数组/index.html","hash":"7a1d4896510dd012293b40eef3e39b0ba86d1cc6","modified":1530626769593},{"_id":"public/tags/模拟/index.html","hash":"ad33ba9007b0ded2dd2a5cd7c232630cc15d3505","modified":1530626769593},{"_id":"public/tags/数论/index.html","hash":"b379c98dd77947751692cefffabc410c1775fc1b","modified":1530626769593},{"_id":"public/2018/07/leetcode-2/index.html","hash":"ce901684420ec6d3e410bea4459962e8dc465b5e","modified":1530626769589},{"_id":"public/archives/page/2/index.html","hash":"255a83961fb1c727f986f0a6d47b0b6ce42cb8ad","modified":1530626552919},{"_id":"public/page/2/index.html","hash":"de2148d0cf9684cf3fb7051071bb65cf00f97add","modified":1530626552919}],"Category":[{"name":"计算机课堂","_id":"cjj5repu600029pd3fs7ibv6p"},{"name":"软件推荐","_id":"cjj5repur000j9pd3l1cq63pm"},{"name":"解题报告","_id":"cjj5risfd0001bhd3i4d546k7"}],"Data":[],"Page":[],"Post":[{"title":"从零开始微信机器人（一）：wxpy简介","date":"2017-06-22T16:00:00.000Z","_content":"\n在过去的几个月中，由于在新生群中回答问题费时费力，同时又有许多重复而又有固定答案的回答，我受到一些知乎文章的启发，维护了一个基于itchat的群聊机器人。从刚开始接入图灵机器人时只会尬聊的机器人，之后又加入了api.ai的按照消息内容自动回复，而后再加入了回复表情功能，使得机器人变得越来越有趣。\n\n现在，由于itchat的更新和被wxpy一些更有趣的功能所吸引，我计划将这个机器人分步重写，并将完整的机器人构建步骤展现给大家。这是我第一次做这样的事，有诸多不足之处，也希望多多谅解和指正。\n\n<!--more-->\n\n本文很大程度上面向仅对python入门或是了解较少的开发者因此较为详细，希望最大程度上帮助大家从零开始构建一个属于自己的微信机器人，哪怕仅有很少的编程基础。每一篇会将长度控制在较短、能够快速阅读完的范围内。\n\n本文基于python 2.7，与python 3.5可能有语法上区别。\n\n\n\n## 安装wxpy\n\n安装wxpy非常简单，如果你拥有pip，请直接按照Github中的方法安装：\n\n> 从 PYPI 官方源下载安装 (在国内可能比较慢或不稳定):\n\n```shell\npip install -U wxpy\n```\n\n> 从豆瓣 PYPI 镜像源下载安装 (**推荐国内用户选用**):\n\n```shell\npip install -U wxpy -i \"https://pypi.doubanio.com/simple/\"\n```\n\n\n\n## 登录微信\n\n（这里吐槽一下wxpy文档中登录错写为登陆）\n\nGithub上和文档中给出了最简单的登录机器人的方式，在程序中写上这两行并运行，会通过图片扫描二维码并登录微信。\n\n```python\n# 导入模块\nfrom wxpy import *\n# 初始化机器人，扫码登陆\nbot = Bot()\n```\n\n有些情况下，可能不能通过终端打开图片（例如部署在服务器上时），我们可以通过参数选择在终端内显示二维码，这样代码会变为：\n\n```python\nfrom wxpy import *\nbot = Bot(console_qr=True)\n```\n\n如果你发现这样设置终端中的二维码变形了，可以尝试传入`console_qr=1`（或其他倍数）来进行调整字幅宽度。如果需要反色显示，可以使用负数来进行反色操作。\n\n如果你认为每次都需要扫描二维码很麻烦，可以启用缓存，来保存自己的登录状态：\n\n```python\nbot = Bot(console_qr=True, cache_path=True)\n```\n\n\n\n## 发送消息\n\n首先我们尝试给自己和文件传输助手发消息：\n\n```python\n# 给机器人自己发送消息\nbot.self.send('Hello World!')\n# 给文件传输助手发送消息\nbot.file_helper.send('Hello World!')\n```\n\n如果无法给机器人自身发送消息，请参考http://wxpy.readthedocs.io/zh/latest/bot.html#wxpy.Bot.self\n\n```python\n# 查找昵称为'乙醚。'的好友\nmy_friend = bot.friends().search(u'乙醚。')[0]\n# <Friend: 乙醚。>\n```\n\nwxpy同时也包括了发送不同类型消息的方法，通过这些方法我们可以发送各种不同类型的消息。以下是文档给出的样例使用方式：\n\n```python\n# 发送文本\nmy_friend.send('Hello, WeChat!')\n# 发送图片\nmy_friend.send_image('my_picture.png')\n# 发送视频\nmy_friend.send_video('my_video.mov')\n# 发送文件\nmy_friend.send_file('my_file.zip')\n# 以动态的方式发送图片\nmy_friend.send('@img@my_picture.png')\n```\n\n通过使用这些方法，我们就可以自定义一个在合适的时候做合适的事情的机器人了！\n\n由于群聊机器人设计暂时需要好友相关内容不多，此处不再作过过多赘述，如果有需要搜索好友的可以参考http://wxpy.readthedocs.io/zh/latest/chats.html#module-wxpy\n\n\n\n## 自动处理消息\n\nwxpy提供了注册消息的方法，可以简单将各种类型的消息注册并自定义处理方式。\n\n注册消息使用简单的`@bot.register()`方法，\n\n```python\n# 获取所有类型的消息（好友消息、群聊、公众号，不包括任何自己发送的消息）\n# 并将获得的消息打印到控制台\n@bot.register()\ndef print_others(msg):\n    print(msg)\n```\n\n同时wxpy也可以给注册消息的类型加上限制，\n\n```python\n# 回复 my_friend 发送的消息\n@bot.register(my_friend)\ndef reply_my_friend(msg):\n    return 'received: {} ({})'.format(msg.text, msg.type)\n\n# 回复发送给自己的消息，可以使用这个方法来进行测试机器人而不影响到他人\n@bot.register(bot.self, except_self=False)\ndef reply_self(msg):\n    return 'received: {} ({})'.format(msg.text, msg.type)\n\n# 打印出所有群聊中@自己的文本消息，并自动回复相同内容\n# 这条注册消息是我们构建群聊机器人的基础\n@bot.register(Group, TEXT)\ndef print_group_msg(msg):\n\tif msg.is_at:\n\t    print(msg)\n\t    msg.reply(meg.text)\n```\n\n当然仅仅写以上内容，会导致你的程序主程序运行结束自然退出。wxpy给出了`embed()`方法，在程序末尾（或其他你想要暂停调试的地方）加上`embed()`方法就可以让程序保持运行，同时进入Python命令行。\n\n```python\n# 进入 Python 命令行、让程序保持运行\n# 推荐使用\nembed()\n\n# 或者仅仅堵塞线程\n# bot.join()\n```\n\n关于消息注册的文档，更多内容可以参考http://wxpy.readthedocs.io/zh/latest/messages.html#id11\n\n现在，你已经可以用这个微信机器人和自动回复消息玩了！刺不刺激呢！\n\n下一篇中，我将就如何将API接入机器人进行阐述。\n\n\n\n# 你可能会遇到的一些问题\n\n## 报错[SSL: CERTIFICATE_VERIFY_FAILED]\n\n可能的**解决方案**一：\n\n```shell\npip install -U requests[security]\n```\n\n可能的**解决方案**二：\n\n进如python后运行：\n\n```python\nimport certifi \nprint(certifi.old_where())\n```\n\n把打印出的路径（例如我的是`/usr/local/lib/python2.7/site-packages/certifi/weak.pem`）放入环境变量`REQUESTS_CA_BUNDLE`中。具体而言是在*nix环境下运行：\n\n```shell\nexport REQUESTS_CA_BUNDLE='What you get'\n```\n\n或是在Windows中使用系统面板进行修改。","source":"_posts/connector-wechat-bot-1.md","raw":"---\ntitle: 从零开始微信机器人（一）：wxpy简介\ndate: 2017-06-23\ncategory: 计算机课堂\ntags: \n- Python\n- 聊天机器人\n---\n\n在过去的几个月中，由于在新生群中回答问题费时费力，同时又有许多重复而又有固定答案的回答，我受到一些知乎文章的启发，维护了一个基于itchat的群聊机器人。从刚开始接入图灵机器人时只会尬聊的机器人，之后又加入了api.ai的按照消息内容自动回复，而后再加入了回复表情功能，使得机器人变得越来越有趣。\n\n现在，由于itchat的更新和被wxpy一些更有趣的功能所吸引，我计划将这个机器人分步重写，并将完整的机器人构建步骤展现给大家。这是我第一次做这样的事，有诸多不足之处，也希望多多谅解和指正。\n\n<!--more-->\n\n本文很大程度上面向仅对python入门或是了解较少的开发者因此较为详细，希望最大程度上帮助大家从零开始构建一个属于自己的微信机器人，哪怕仅有很少的编程基础。每一篇会将长度控制在较短、能够快速阅读完的范围内。\n\n本文基于python 2.7，与python 3.5可能有语法上区别。\n\n\n\n## 安装wxpy\n\n安装wxpy非常简单，如果你拥有pip，请直接按照Github中的方法安装：\n\n> 从 PYPI 官方源下载安装 (在国内可能比较慢或不稳定):\n\n```shell\npip install -U wxpy\n```\n\n> 从豆瓣 PYPI 镜像源下载安装 (**推荐国内用户选用**):\n\n```shell\npip install -U wxpy -i \"https://pypi.doubanio.com/simple/\"\n```\n\n\n\n## 登录微信\n\n（这里吐槽一下wxpy文档中登录错写为登陆）\n\nGithub上和文档中给出了最简单的登录机器人的方式，在程序中写上这两行并运行，会通过图片扫描二维码并登录微信。\n\n```python\n# 导入模块\nfrom wxpy import *\n# 初始化机器人，扫码登陆\nbot = Bot()\n```\n\n有些情况下，可能不能通过终端打开图片（例如部署在服务器上时），我们可以通过参数选择在终端内显示二维码，这样代码会变为：\n\n```python\nfrom wxpy import *\nbot = Bot(console_qr=True)\n```\n\n如果你发现这样设置终端中的二维码变形了，可以尝试传入`console_qr=1`（或其他倍数）来进行调整字幅宽度。如果需要反色显示，可以使用负数来进行反色操作。\n\n如果你认为每次都需要扫描二维码很麻烦，可以启用缓存，来保存自己的登录状态：\n\n```python\nbot = Bot(console_qr=True, cache_path=True)\n```\n\n\n\n## 发送消息\n\n首先我们尝试给自己和文件传输助手发消息：\n\n```python\n# 给机器人自己发送消息\nbot.self.send('Hello World!')\n# 给文件传输助手发送消息\nbot.file_helper.send('Hello World!')\n```\n\n如果无法给机器人自身发送消息，请参考http://wxpy.readthedocs.io/zh/latest/bot.html#wxpy.Bot.self\n\n```python\n# 查找昵称为'乙醚。'的好友\nmy_friend = bot.friends().search(u'乙醚。')[0]\n# <Friend: 乙醚。>\n```\n\nwxpy同时也包括了发送不同类型消息的方法，通过这些方法我们可以发送各种不同类型的消息。以下是文档给出的样例使用方式：\n\n```python\n# 发送文本\nmy_friend.send('Hello, WeChat!')\n# 发送图片\nmy_friend.send_image('my_picture.png')\n# 发送视频\nmy_friend.send_video('my_video.mov')\n# 发送文件\nmy_friend.send_file('my_file.zip')\n# 以动态的方式发送图片\nmy_friend.send('@img@my_picture.png')\n```\n\n通过使用这些方法，我们就可以自定义一个在合适的时候做合适的事情的机器人了！\n\n由于群聊机器人设计暂时需要好友相关内容不多，此处不再作过过多赘述，如果有需要搜索好友的可以参考http://wxpy.readthedocs.io/zh/latest/chats.html#module-wxpy\n\n\n\n## 自动处理消息\n\nwxpy提供了注册消息的方法，可以简单将各种类型的消息注册并自定义处理方式。\n\n注册消息使用简单的`@bot.register()`方法，\n\n```python\n# 获取所有类型的消息（好友消息、群聊、公众号，不包括任何自己发送的消息）\n# 并将获得的消息打印到控制台\n@bot.register()\ndef print_others(msg):\n    print(msg)\n```\n\n同时wxpy也可以给注册消息的类型加上限制，\n\n```python\n# 回复 my_friend 发送的消息\n@bot.register(my_friend)\ndef reply_my_friend(msg):\n    return 'received: {} ({})'.format(msg.text, msg.type)\n\n# 回复发送给自己的消息，可以使用这个方法来进行测试机器人而不影响到他人\n@bot.register(bot.self, except_self=False)\ndef reply_self(msg):\n    return 'received: {} ({})'.format(msg.text, msg.type)\n\n# 打印出所有群聊中@自己的文本消息，并自动回复相同内容\n# 这条注册消息是我们构建群聊机器人的基础\n@bot.register(Group, TEXT)\ndef print_group_msg(msg):\n\tif msg.is_at:\n\t    print(msg)\n\t    msg.reply(meg.text)\n```\n\n当然仅仅写以上内容，会导致你的程序主程序运行结束自然退出。wxpy给出了`embed()`方法，在程序末尾（或其他你想要暂停调试的地方）加上`embed()`方法就可以让程序保持运行，同时进入Python命令行。\n\n```python\n# 进入 Python 命令行、让程序保持运行\n# 推荐使用\nembed()\n\n# 或者仅仅堵塞线程\n# bot.join()\n```\n\n关于消息注册的文档，更多内容可以参考http://wxpy.readthedocs.io/zh/latest/messages.html#id11\n\n现在，你已经可以用这个微信机器人和自动回复消息玩了！刺不刺激呢！\n\n下一篇中，我将就如何将API接入机器人进行阐述。\n\n\n\n# 你可能会遇到的一些问题\n\n## 报错[SSL: CERTIFICATE_VERIFY_FAILED]\n\n可能的**解决方案**一：\n\n```shell\npip install -U requests[security]\n```\n\n可能的**解决方案**二：\n\n进如python后运行：\n\n```python\nimport certifi \nprint(certifi.old_where())\n```\n\n把打印出的路径（例如我的是`/usr/local/lib/python2.7/site-packages/certifi/weak.pem`）放入环境变量`REQUESTS_CA_BUNDLE`中。具体而言是在*nix环境下运行：\n\n```shell\nexport REQUESTS_CA_BUNDLE='What you get'\n```\n\n或是在Windows中使用系统面板进行修改。","slug":"connector-wechat-bot-1","published":1,"updated":"2018-07-03T13:44:30.392Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj5reptx00009pd3w2srrft4","content":"<p>在过去的几个月中，由于在新生群中回答问题费时费力，同时又有许多重复而又有固定答案的回答，我受到一些知乎文章的启发，维护了一个基于itchat的群聊机器人。从刚开始接入图灵机器人时只会尬聊的机器人，之后又加入了api.ai的按照消息内容自动回复，而后再加入了回复表情功能，使得机器人变得越来越有趣。</p>\n<p>现在，由于itchat的更新和被wxpy一些更有趣的功能所吸引，我计划将这个机器人分步重写，并将完整的机器人构建步骤展现给大家。这是我第一次做这样的事，有诸多不足之处，也希望多多谅解和指正。</p>\n<a id=\"more\"></a>\n<p>本文很大程度上面向仅对python入门或是了解较少的开发者因此较为详细，希望最大程度上帮助大家从零开始构建一个属于自己的微信机器人，哪怕仅有很少的编程基础。每一篇会将长度控制在较短、能够快速阅读完的范围内。</p>\n<p>本文基于python 2.7，与python 3.5可能有语法上区别。</p>\n<h2 id=\"安装wxpy\"><a href=\"#安装wxpy\" class=\"headerlink\" title=\"安装wxpy\"></a>安装wxpy</h2><p>安装wxpy非常简单，如果你拥有pip，请直接按照Github中的方法安装：</p>\n<blockquote>\n<p>从 PYPI 官方源下载安装 (在国内可能比较慢或不稳定):</p>\n</blockquote>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip install -U wxpy</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>从豆瓣 PYPI 镜像源下载安装 (<strong>推荐国内用户选用</strong>):</p>\n</blockquote>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip install -U wxpy -i \"https://pypi.doubanio.com/simple/\"</span><br></pre></td></tr></table></figure>\n<h2 id=\"登录微信\"><a href=\"#登录微信\" class=\"headerlink\" title=\"登录微信\"></a>登录微信</h2><p>（这里吐槽一下wxpy文档中登录错写为登陆）</p>\n<p>Github上和文档中给出了最简单的登录机器人的方式，在程序中写上这两行并运行，会通过图片扫描二维码并登录微信。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 导入模块</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> wxpy <span class=\"keyword\">import</span> *</span><br><span class=\"line\"><span class=\"comment\"># 初始化机器人，扫码登陆</span></span><br><span class=\"line\">bot = Bot()</span><br></pre></td></tr></table></figure>\n<p>有些情况下，可能不能通过终端打开图片（例如部署在服务器上时），我们可以通过参数选择在终端内显示二维码，这样代码会变为：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> wxpy <span class=\"keyword\">import</span> *</span><br><span class=\"line\">bot = Bot(console_qr=<span class=\"keyword\">True</span>)</span><br></pre></td></tr></table></figure>\n<p>如果你发现这样设置终端中的二维码变形了，可以尝试传入<code>console_qr=1</code>（或其他倍数）来进行调整字幅宽度。如果需要反色显示，可以使用负数来进行反色操作。</p>\n<p>如果你认为每次都需要扫描二维码很麻烦，可以启用缓存，来保存自己的登录状态：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bot = Bot(console_qr=<span class=\"keyword\">True</span>, cache_path=<span class=\"keyword\">True</span>)</span><br></pre></td></tr></table></figure>\n<h2 id=\"发送消息\"><a href=\"#发送消息\" class=\"headerlink\" title=\"发送消息\"></a>发送消息</h2><p>首先我们尝试给自己和文件传输助手发消息：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 给机器人自己发送消息</span></span><br><span class=\"line\">bot.self.send(<span class=\"string\">'Hello World!'</span>)</span><br><span class=\"line\"><span class=\"comment\"># 给文件传输助手发送消息</span></span><br><span class=\"line\">bot.file_helper.send(<span class=\"string\">'Hello World!'</span>)</span><br></pre></td></tr></table></figure>\n<p>如果无法给机器人自身发送消息，请参考<a href=\"http://wxpy.readthedocs.io/zh/latest/bot.html#wxpy.Bot.self\" target=\"_blank\" rel=\"noopener\">http://wxpy.readthedocs.io/zh/latest/bot.html#wxpy.Bot.self</a></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查找昵称为'乙醚。'的好友</span></span><br><span class=\"line\">my_friend = bot.friends().search(<span class=\"string\">u'乙醚。'</span>)[<span class=\"number\">0</span>]</span><br><span class=\"line\"><span class=\"comment\"># &lt;Friend: 乙醚。&gt;</span></span><br></pre></td></tr></table></figure>\n<p>wxpy同时也包括了发送不同类型消息的方法，通过这些方法我们可以发送各种不同类型的消息。以下是文档给出的样例使用方式：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 发送文本</span></span><br><span class=\"line\">my_friend.send(<span class=\"string\">'Hello, WeChat!'</span>)</span><br><span class=\"line\"><span class=\"comment\"># 发送图片</span></span><br><span class=\"line\">my_friend.send_image(<span class=\"string\">'my_picture.png'</span>)</span><br><span class=\"line\"><span class=\"comment\"># 发送视频</span></span><br><span class=\"line\">my_friend.send_video(<span class=\"string\">'my_video.mov'</span>)</span><br><span class=\"line\"><span class=\"comment\"># 发送文件</span></span><br><span class=\"line\">my_friend.send_file(<span class=\"string\">'my_file.zip'</span>)</span><br><span class=\"line\"><span class=\"comment\"># 以动态的方式发送图片</span></span><br><span class=\"line\">my_friend.send(<span class=\"string\">'@img@my_picture.png'</span>)</span><br></pre></td></tr></table></figure>\n<p>通过使用这些方法，我们就可以自定义一个在合适的时候做合适的事情的机器人了！</p>\n<p>由于群聊机器人设计暂时需要好友相关内容不多，此处不再作过过多赘述，如果有需要搜索好友的可以参考<a href=\"http://wxpy.readthedocs.io/zh/latest/chats.html#module-wxpy\" target=\"_blank\" rel=\"noopener\">http://wxpy.readthedocs.io/zh/latest/chats.html#module-wxpy</a></p>\n<h2 id=\"自动处理消息\"><a href=\"#自动处理消息\" class=\"headerlink\" title=\"自动处理消息\"></a>自动处理消息</h2><p>wxpy提供了注册消息的方法，可以简单将各种类型的消息注册并自定义处理方式。</p>\n<p>注册消息使用简单的<a href=\"mailto:`@bot.register\" target=\"_blank\" rel=\"noopener\">`@bot.register</a>()`方法，</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 获取所有类型的消息（好友消息、群聊、公众号，不包括任何自己发送的消息）</span></span><br><span class=\"line\"><span class=\"comment\"># 并将获得的消息打印到控制台</span></span><br><span class=\"line\"><span class=\"meta\">@bot.register()</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">print_others</span><span class=\"params\">(msg)</span>:</span></span><br><span class=\"line\">    print(msg)</span><br></pre></td></tr></table></figure>\n<p>同时wxpy也可以给注册消息的类型加上限制，</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 回复 my_friend 发送的消息</span></span><br><span class=\"line\"><span class=\"meta\">@bot.register(my_friend)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">reply_my_friend</span><span class=\"params\">(msg)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'received: &#123;&#125; (&#123;&#125;)'</span>.format(msg.text, msg.type)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 回复发送给自己的消息，可以使用这个方法来进行测试机器人而不影响到他人</span></span><br><span class=\"line\"><span class=\"meta\">@bot.register(bot.self, except_self=False)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">reply_self</span><span class=\"params\">(msg)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'received: &#123;&#125; (&#123;&#125;)'</span>.format(msg.text, msg.type)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 打印出所有群聊中@自己的文本消息，并自动回复相同内容</span></span><br><span class=\"line\"><span class=\"comment\"># 这条注册消息是我们构建群聊机器人的基础</span></span><br><span class=\"line\"><span class=\"meta\">@bot.register(Group, TEXT)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">print_group_msg</span><span class=\"params\">(msg)</span>:</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> msg.is_at:</span><br><span class=\"line\">\t    print(msg)</span><br><span class=\"line\">\t    msg.reply(meg.text)</span><br></pre></td></tr></table></figure>\n<p>当然仅仅写以上内容，会导致你的程序主程序运行结束自然退出。wxpy给出了<code>embed()</code>方法，在程序末尾（或其他你想要暂停调试的地方）加上<code>embed()</code>方法就可以让程序保持运行，同时进入Python命令行。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 进入 Python 命令行、让程序保持运行</span></span><br><span class=\"line\"><span class=\"comment\"># 推荐使用</span></span><br><span class=\"line\">embed()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 或者仅仅堵塞线程</span></span><br><span class=\"line\"><span class=\"comment\"># bot.join()</span></span><br></pre></td></tr></table></figure>\n<p>关于消息注册的文档，更多内容可以参考<a href=\"http://wxpy.readthedocs.io/zh/latest/messages.html#id11\" target=\"_blank\" rel=\"noopener\">http://wxpy.readthedocs.io/zh/latest/messages.html#id11</a></p>\n<p>现在，你已经可以用这个微信机器人和自动回复消息玩了！刺不刺激呢！</p>\n<p>下一篇中，我将就如何将API接入机器人进行阐述。</p>\n<h1 id=\"你可能会遇到的一些问题\"><a href=\"#你可能会遇到的一些问题\" class=\"headerlink\" title=\"你可能会遇到的一些问题\"></a>你可能会遇到的一些问题</h1><h2 id=\"报错-SSL-CERTIFICATE-VERIFY-FAILED\"><a href=\"#报错-SSL-CERTIFICATE-VERIFY-FAILED\" class=\"headerlink\" title=\"报错[SSL: CERTIFICATE_VERIFY_FAILED]\"></a>报错[SSL: CERTIFICATE_VERIFY_FAILED]</h2><p>可能的<strong>解决方案</strong>一：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip install -U requests[security]</span><br></pre></td></tr></table></figure>\n<p>可能的<strong>解决方案</strong>二：</p>\n<p>进如python后运行：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> certifi </span><br><span class=\"line\">print(certifi.old_where())</span><br></pre></td></tr></table></figure>\n<p>把打印出的路径（例如我的是<code>/usr/local/lib/python2.7/site-packages/certifi/weak.pem</code>）放入环境变量<code>REQUESTS_CA_BUNDLE</code>中。具体而言是在*nix环境下运行：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export REQUESTS_CA_BUNDLE='What you get'</span><br></pre></td></tr></table></figure>\n<p>或是在Windows中使用系统面板进行修改。</p>\n","site":{"data":{}},"excerpt":"<p>在过去的几个月中，由于在新生群中回答问题费时费力，同时又有许多重复而又有固定答案的回答，我受到一些知乎文章的启发，维护了一个基于itchat的群聊机器人。从刚开始接入图灵机器人时只会尬聊的机器人，之后又加入了api.ai的按照消息内容自动回复，而后再加入了回复表情功能，使得机器人变得越来越有趣。</p>\n<p>现在，由于itchat的更新和被wxpy一些更有趣的功能所吸引，我计划将这个机器人分步重写，并将完整的机器人构建步骤展现给大家。这是我第一次做这样的事，有诸多不足之处，也希望多多谅解和指正。</p>","more":"<p>本文很大程度上面向仅对python入门或是了解较少的开发者因此较为详细，希望最大程度上帮助大家从零开始构建一个属于自己的微信机器人，哪怕仅有很少的编程基础。每一篇会将长度控制在较短、能够快速阅读完的范围内。</p>\n<p>本文基于python 2.7，与python 3.5可能有语法上区别。</p>\n<h2 id=\"安装wxpy\"><a href=\"#安装wxpy\" class=\"headerlink\" title=\"安装wxpy\"></a>安装wxpy</h2><p>安装wxpy非常简单，如果你拥有pip，请直接按照Github中的方法安装：</p>\n<blockquote>\n<p>从 PYPI 官方源下载安装 (在国内可能比较慢或不稳定):</p>\n</blockquote>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip install -U wxpy</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>从豆瓣 PYPI 镜像源下载安装 (<strong>推荐国内用户选用</strong>):</p>\n</blockquote>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip install -U wxpy -i \"https://pypi.doubanio.com/simple/\"</span><br></pre></td></tr></table></figure>\n<h2 id=\"登录微信\"><a href=\"#登录微信\" class=\"headerlink\" title=\"登录微信\"></a>登录微信</h2><p>（这里吐槽一下wxpy文档中登录错写为登陆）</p>\n<p>Github上和文档中给出了最简单的登录机器人的方式，在程序中写上这两行并运行，会通过图片扫描二维码并登录微信。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 导入模块</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> wxpy <span class=\"keyword\">import</span> *</span><br><span class=\"line\"><span class=\"comment\"># 初始化机器人，扫码登陆</span></span><br><span class=\"line\">bot = Bot()</span><br></pre></td></tr></table></figure>\n<p>有些情况下，可能不能通过终端打开图片（例如部署在服务器上时），我们可以通过参数选择在终端内显示二维码，这样代码会变为：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> wxpy <span class=\"keyword\">import</span> *</span><br><span class=\"line\">bot = Bot(console_qr=<span class=\"keyword\">True</span>)</span><br></pre></td></tr></table></figure>\n<p>如果你发现这样设置终端中的二维码变形了，可以尝试传入<code>console_qr=1</code>（或其他倍数）来进行调整字幅宽度。如果需要反色显示，可以使用负数来进行反色操作。</p>\n<p>如果你认为每次都需要扫描二维码很麻烦，可以启用缓存，来保存自己的登录状态：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bot = Bot(console_qr=<span class=\"keyword\">True</span>, cache_path=<span class=\"keyword\">True</span>)</span><br></pre></td></tr></table></figure>\n<h2 id=\"发送消息\"><a href=\"#发送消息\" class=\"headerlink\" title=\"发送消息\"></a>发送消息</h2><p>首先我们尝试给自己和文件传输助手发消息：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 给机器人自己发送消息</span></span><br><span class=\"line\">bot.self.send(<span class=\"string\">'Hello World!'</span>)</span><br><span class=\"line\"><span class=\"comment\"># 给文件传输助手发送消息</span></span><br><span class=\"line\">bot.file_helper.send(<span class=\"string\">'Hello World!'</span>)</span><br></pre></td></tr></table></figure>\n<p>如果无法给机器人自身发送消息，请参考<a href=\"http://wxpy.readthedocs.io/zh/latest/bot.html#wxpy.Bot.self\" target=\"_blank\" rel=\"noopener\">http://wxpy.readthedocs.io/zh/latest/bot.html#wxpy.Bot.self</a></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查找昵称为'乙醚。'的好友</span></span><br><span class=\"line\">my_friend = bot.friends().search(<span class=\"string\">u'乙醚。'</span>)[<span class=\"number\">0</span>]</span><br><span class=\"line\"><span class=\"comment\"># &lt;Friend: 乙醚。&gt;</span></span><br></pre></td></tr></table></figure>\n<p>wxpy同时也包括了发送不同类型消息的方法，通过这些方法我们可以发送各种不同类型的消息。以下是文档给出的样例使用方式：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 发送文本</span></span><br><span class=\"line\">my_friend.send(<span class=\"string\">'Hello, WeChat!'</span>)</span><br><span class=\"line\"><span class=\"comment\"># 发送图片</span></span><br><span class=\"line\">my_friend.send_image(<span class=\"string\">'my_picture.png'</span>)</span><br><span class=\"line\"><span class=\"comment\"># 发送视频</span></span><br><span class=\"line\">my_friend.send_video(<span class=\"string\">'my_video.mov'</span>)</span><br><span class=\"line\"><span class=\"comment\"># 发送文件</span></span><br><span class=\"line\">my_friend.send_file(<span class=\"string\">'my_file.zip'</span>)</span><br><span class=\"line\"><span class=\"comment\"># 以动态的方式发送图片</span></span><br><span class=\"line\">my_friend.send(<span class=\"string\">'@img@my_picture.png'</span>)</span><br></pre></td></tr></table></figure>\n<p>通过使用这些方法，我们就可以自定义一个在合适的时候做合适的事情的机器人了！</p>\n<p>由于群聊机器人设计暂时需要好友相关内容不多，此处不再作过过多赘述，如果有需要搜索好友的可以参考<a href=\"http://wxpy.readthedocs.io/zh/latest/chats.html#module-wxpy\" target=\"_blank\" rel=\"noopener\">http://wxpy.readthedocs.io/zh/latest/chats.html#module-wxpy</a></p>\n<h2 id=\"自动处理消息\"><a href=\"#自动处理消息\" class=\"headerlink\" title=\"自动处理消息\"></a>自动处理消息</h2><p>wxpy提供了注册消息的方法，可以简单将各种类型的消息注册并自定义处理方式。</p>\n<p>注册消息使用简单的<a href=\"mailto:`@bot.register\" target=\"_blank\" rel=\"noopener\">`@bot.register</a>()`方法，</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 获取所有类型的消息（好友消息、群聊、公众号，不包括任何自己发送的消息）</span></span><br><span class=\"line\"><span class=\"comment\"># 并将获得的消息打印到控制台</span></span><br><span class=\"line\"><span class=\"meta\">@bot.register()</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">print_others</span><span class=\"params\">(msg)</span>:</span></span><br><span class=\"line\">    print(msg)</span><br></pre></td></tr></table></figure>\n<p>同时wxpy也可以给注册消息的类型加上限制，</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 回复 my_friend 发送的消息</span></span><br><span class=\"line\"><span class=\"meta\">@bot.register(my_friend)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">reply_my_friend</span><span class=\"params\">(msg)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'received: &#123;&#125; (&#123;&#125;)'</span>.format(msg.text, msg.type)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 回复发送给自己的消息，可以使用这个方法来进行测试机器人而不影响到他人</span></span><br><span class=\"line\"><span class=\"meta\">@bot.register(bot.self, except_self=False)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">reply_self</span><span class=\"params\">(msg)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'received: &#123;&#125; (&#123;&#125;)'</span>.format(msg.text, msg.type)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 打印出所有群聊中@自己的文本消息，并自动回复相同内容</span></span><br><span class=\"line\"><span class=\"comment\"># 这条注册消息是我们构建群聊机器人的基础</span></span><br><span class=\"line\"><span class=\"meta\">@bot.register(Group, TEXT)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">print_group_msg</span><span class=\"params\">(msg)</span>:</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> msg.is_at:</span><br><span class=\"line\">\t    print(msg)</span><br><span class=\"line\">\t    msg.reply(meg.text)</span><br></pre></td></tr></table></figure>\n<p>当然仅仅写以上内容，会导致你的程序主程序运行结束自然退出。wxpy给出了<code>embed()</code>方法，在程序末尾（或其他你想要暂停调试的地方）加上<code>embed()</code>方法就可以让程序保持运行，同时进入Python命令行。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 进入 Python 命令行、让程序保持运行</span></span><br><span class=\"line\"><span class=\"comment\"># 推荐使用</span></span><br><span class=\"line\">embed()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 或者仅仅堵塞线程</span></span><br><span class=\"line\"><span class=\"comment\"># bot.join()</span></span><br></pre></td></tr></table></figure>\n<p>关于消息注册的文档，更多内容可以参考<a href=\"http://wxpy.readthedocs.io/zh/latest/messages.html#id11\" target=\"_blank\" rel=\"noopener\">http://wxpy.readthedocs.io/zh/latest/messages.html#id11</a></p>\n<p>现在，你已经可以用这个微信机器人和自动回复消息玩了！刺不刺激呢！</p>\n<p>下一篇中，我将就如何将API接入机器人进行阐述。</p>\n<h1 id=\"你可能会遇到的一些问题\"><a href=\"#你可能会遇到的一些问题\" class=\"headerlink\" title=\"你可能会遇到的一些问题\"></a>你可能会遇到的一些问题</h1><h2 id=\"报错-SSL-CERTIFICATE-VERIFY-FAILED\"><a href=\"#报错-SSL-CERTIFICATE-VERIFY-FAILED\" class=\"headerlink\" title=\"报错[SSL: CERTIFICATE_VERIFY_FAILED]\"></a>报错[SSL: CERTIFICATE_VERIFY_FAILED]</h2><p>可能的<strong>解决方案</strong>一：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip install -U requests[security]</span><br></pre></td></tr></table></figure>\n<p>可能的<strong>解决方案</strong>二：</p>\n<p>进如python后运行：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> certifi </span><br><span class=\"line\">print(certifi.old_where())</span><br></pre></td></tr></table></figure>\n<p>把打印出的路径（例如我的是<code>/usr/local/lib/python2.7/site-packages/certifi/weak.pem</code>）放入环境变量<code>REQUESTS_CA_BUNDLE</code>中。具体而言是在*nix环境下运行：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export REQUESTS_CA_BUNDLE='What you get'</span><br></pre></td></tr></table></figure>\n<p>或是在Windows中使用系统面板进行修改。</p>"},{"title":"为什么公交车来的总比时间表上说的还久？","date":"2018-04-30T16:00:00.000Z","_content":"\n\n\n十字路口的红绿灯，每分钟交替一次的话，你在红灯的时候到达的平均等待时间是多久？\n\n$1分钟/2  = 半分钟$\n\n公交车平均五分钟来一次的话你等公交车要多久？\n\n$5分钟/2 =两分半$ \n\n错啦！这就是经典的等车悖论，因为公交车平均每五分钟来一辆，那么你的平均等待时间将是五分钟。\n\n\n\n# 均匀分布和指数分布\n\n红绿灯和公交车有什么不同的地方呢？\n\n<!--more-->\n\n我们往往假设，红绿灯每次交替的时间是固定的（假设是一分钟），是不随着雨天还是晴天而改变的。如果我们在任何时间抵达红绿灯前，我们到达的分布可以视作是均匀分布的（如下图）。\n\n![Uniform distribution PDF](https://upload.wikimedia.org/wikipedia/commons/thumb/9/9c/Uniform_distribution_PDF.png/350px-Uniform_distribution_PDF.png)\n\n也就是说，在每个红灯的前，我们可能的等待时间是从0分钟（一到灯就绿了）到1分钟之间（一到灯就红了）每个时间出现的可能性是完全一致的。因此我们可以简单地做一个平均运算来算出我们的期待值，也就是说：\n\n$E[X]={\\frac  {a+b}{2}} = {\\frac  {1+0}{2}} = {\\frac{1}{2}}$\n\n\n\n但是相比之下公交车则完全不同，公交车的到达时间是平均五分钟，这么说来和红绿灯则是完全不同。路况不同，路上的红绿灯稍有不同，就不可能在五分钟准时抵达。虽然人们脑海中认为公交车和红绿灯一样也是完全准时的，但事实却不是如此。我们往往将一段时间内到达公交车的数量假设为泊松分布，而公交车的间隔是指数分布的（下图）。\n\n![Probability density function](https://upload.wikimedia.org/wikipedia/commons/thumb/e/ec/Exponential_pdf.svg/325px-Exponential_pdf.svg.png)\n\n如果从指数分布去考虑，我们等待的时间并不是均匀分布的。直观地说，我们到达等待时间更长的区间的可能性更大，因此我们等待的平均时间，并不是一个简单的算术平均值，而是一个加权平均值，而等待的时长也因此被拉高了。\n\n\n\n# 指数分布的无记忆性\n\n无记忆性指的是，指数分布的概率只和时间区间有关，和已经发生了多久（时间的起点）无关。用数学公式可以表达为：\n\n$\\Pr \\left (T > s + t | T > s \\right ) = \\Pr(T > t), \\qquad \\forall s, t \\ge 0$\n\n证明可以通过条件概率的贝叶斯定律。另外，由于对时间而言， $Pr(T>s+t\\cap T>s) = Pr(T>s+t)$ 易证上述公式成立。\n\n生活中有许多东西服从指数分布。例如电池等电子元件的寿命在低于某个值的时候：如果电池标示1000次充放电会坏，往往有些人的用了100次就坏了，而有些人的用了1000次也仍然完好无损。这和批次的质量等有关系，而在一个界限值之下，人们往往会将它的使用年限用指数分布来衡量：一块充放电100次的电池和一块充放300次的电池，在未来还能使用100次的概率是相同的。虽然听上去很不可思议，但是这也是由于指数分布的方差极大二导致的。\n\n同理，虽然听上去不可思议，但是你等公交车的时间往往也和上一辆车什么时候开走的没有什么关系，因为指数分布是没有记忆的，它不会“记得”上一次公交车经过的时间。而等待时间的平均值，和公交车间隔的平均值是相同的。\n\n\n\n# 等车悖论\n\n等车悖论告诉我们的不仅仅是你等车的时间要比你想象的长，更重要的是，我们必须要知道，我们脑海中假定的模型和现实生活中的模型总有一点偏差，而这点偏差往往导致的是我们捶胸顿足，发现自己又迟到了又赶不上车了。\n\n可能这就是所谓的“生活总有一些不如意吧”，因为是总有，所以背后就有其道理呀！","source":"_posts/bus-waiting-paradox.md","raw":"---\ntitle: 为什么公交车来的总比时间表上说的还久？\ndate: 2018-05-01\ncategory: 计算机课堂\ntags: \n- 概率论\n- 统计学\n---\n\n\n\n十字路口的红绿灯，每分钟交替一次的话，你在红灯的时候到达的平均等待时间是多久？\n\n$1分钟/2  = 半分钟$\n\n公交车平均五分钟来一次的话你等公交车要多久？\n\n$5分钟/2 =两分半$ \n\n错啦！这就是经典的等车悖论，因为公交车平均每五分钟来一辆，那么你的平均等待时间将是五分钟。\n\n\n\n# 均匀分布和指数分布\n\n红绿灯和公交车有什么不同的地方呢？\n\n<!--more-->\n\n我们往往假设，红绿灯每次交替的时间是固定的（假设是一分钟），是不随着雨天还是晴天而改变的。如果我们在任何时间抵达红绿灯前，我们到达的分布可以视作是均匀分布的（如下图）。\n\n![Uniform distribution PDF](https://upload.wikimedia.org/wikipedia/commons/thumb/9/9c/Uniform_distribution_PDF.png/350px-Uniform_distribution_PDF.png)\n\n也就是说，在每个红灯的前，我们可能的等待时间是从0分钟（一到灯就绿了）到1分钟之间（一到灯就红了）每个时间出现的可能性是完全一致的。因此我们可以简单地做一个平均运算来算出我们的期待值，也就是说：\n\n$E[X]={\\frac  {a+b}{2}} = {\\frac  {1+0}{2}} = {\\frac{1}{2}}$\n\n\n\n但是相比之下公交车则完全不同，公交车的到达时间是平均五分钟，这么说来和红绿灯则是完全不同。路况不同，路上的红绿灯稍有不同，就不可能在五分钟准时抵达。虽然人们脑海中认为公交车和红绿灯一样也是完全准时的，但事实却不是如此。我们往往将一段时间内到达公交车的数量假设为泊松分布，而公交车的间隔是指数分布的（下图）。\n\n![Probability density function](https://upload.wikimedia.org/wikipedia/commons/thumb/e/ec/Exponential_pdf.svg/325px-Exponential_pdf.svg.png)\n\n如果从指数分布去考虑，我们等待的时间并不是均匀分布的。直观地说，我们到达等待时间更长的区间的可能性更大，因此我们等待的平均时间，并不是一个简单的算术平均值，而是一个加权平均值，而等待的时长也因此被拉高了。\n\n\n\n# 指数分布的无记忆性\n\n无记忆性指的是，指数分布的概率只和时间区间有关，和已经发生了多久（时间的起点）无关。用数学公式可以表达为：\n\n$\\Pr \\left (T > s + t | T > s \\right ) = \\Pr(T > t), \\qquad \\forall s, t \\ge 0$\n\n证明可以通过条件概率的贝叶斯定律。另外，由于对时间而言， $Pr(T>s+t\\cap T>s) = Pr(T>s+t)$ 易证上述公式成立。\n\n生活中有许多东西服从指数分布。例如电池等电子元件的寿命在低于某个值的时候：如果电池标示1000次充放电会坏，往往有些人的用了100次就坏了，而有些人的用了1000次也仍然完好无损。这和批次的质量等有关系，而在一个界限值之下，人们往往会将它的使用年限用指数分布来衡量：一块充放电100次的电池和一块充放300次的电池，在未来还能使用100次的概率是相同的。虽然听上去很不可思议，但是这也是由于指数分布的方差极大二导致的。\n\n同理，虽然听上去不可思议，但是你等公交车的时间往往也和上一辆车什么时候开走的没有什么关系，因为指数分布是没有记忆的，它不会“记得”上一次公交车经过的时间。而等待时间的平均值，和公交车间隔的平均值是相同的。\n\n\n\n# 等车悖论\n\n等车悖论告诉我们的不仅仅是你等车的时间要比你想象的长，更重要的是，我们必须要知道，我们脑海中假定的模型和现实生活中的模型总有一点偏差，而这点偏差往往导致的是我们捶胸顿足，发现自己又迟到了又赶不上车了。\n\n可能这就是所谓的“生活总有一些不如意吧”，因为是总有，所以背后就有其道理呀！","slug":"bus-waiting-paradox","published":1,"updated":"2018-07-03T13:44:30.391Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj5repu400019pd3vfxedkeb","content":"<p>十字路口的红绿灯，每分钟交替一次的话，你在红灯的时候到达的平均等待时间是多久？</p>\n<p>$1分钟/2  = 半分钟$</p>\n<p>公交车平均五分钟来一次的话你等公交车要多久？</p>\n<p>$5分钟/2 =两分半$ </p>\n<p>错啦！这就是经典的等车悖论，因为公交车平均每五分钟来一辆，那么你的平均等待时间将是五分钟。</p>\n<h1 id=\"均匀分布和指数分布\"><a href=\"#均匀分布和指数分布\" class=\"headerlink\" title=\"均匀分布和指数分布\"></a>均匀分布和指数分布</h1><p>红绿灯和公交车有什么不同的地方呢？</p>\n<a id=\"more\"></a>\n<p>我们往往假设，红绿灯每次交替的时间是固定的（假设是一分钟），是不随着雨天还是晴天而改变的。如果我们在任何时间抵达红绿灯前，我们到达的分布可以视作是均匀分布的（如下图）。</p>\n<p><img src=\"https://upload.wikimedia.org/wikipedia/commons/thumb/9/9c/Uniform_distribution_PDF.png/350px-Uniform_distribution_PDF.png\" alt=\"Uniform distribution PDF\"></p>\n<p>也就是说，在每个红灯的前，我们可能的等待时间是从0分钟（一到灯就绿了）到1分钟之间（一到灯就红了）每个时间出现的可能性是完全一致的。因此我们可以简单地做一个平均运算来算出我们的期待值，也就是说：</p>\n<p>$E[X]={\\frac  {a+b}{2}} = {\\frac  {1+0}{2}} = {\\frac{1}{2}}$</p>\n<p>但是相比之下公交车则完全不同，公交车的到达时间是平均五分钟，这么说来和红绿灯则是完全不同。路况不同，路上的红绿灯稍有不同，就不可能在五分钟准时抵达。虽然人们脑海中认为公交车和红绿灯一样也是完全准时的，但事实却不是如此。我们往往将一段时间内到达公交车的数量假设为泊松分布，而公交车的间隔是指数分布的（下图）。</p>\n<p><img src=\"https://upload.wikimedia.org/wikipedia/commons/thumb/e/ec/Exponential_pdf.svg/325px-Exponential_pdf.svg.png\" alt=\"Probability density function\"></p>\n<p>如果从指数分布去考虑，我们等待的时间并不是均匀分布的。直观地说，我们到达等待时间更长的区间的可能性更大，因此我们等待的平均时间，并不是一个简单的算术平均值，而是一个加权平均值，而等待的时长也因此被拉高了。</p>\n<h1 id=\"指数分布的无记忆性\"><a href=\"#指数分布的无记忆性\" class=\"headerlink\" title=\"指数分布的无记忆性\"></a>指数分布的无记忆性</h1><p>无记忆性指的是，指数分布的概率只和时间区间有关，和已经发生了多久（时间的起点）无关。用数学公式可以表达为：</p>\n<p>$\\Pr \\left (T &gt; s + t | T &gt; s \\right ) = \\Pr(T &gt; t), \\qquad \\forall s, t \\ge 0$</p>\n<p>证明可以通过条件概率的贝叶斯定律。另外，由于对时间而言， $Pr(T&gt;s+t\\cap T&gt;s) = Pr(T&gt;s+t)$ 易证上述公式成立。</p>\n<p>生活中有许多东西服从指数分布。例如电池等电子元件的寿命在低于某个值的时候：如果电池标示1000次充放电会坏，往往有些人的用了100次就坏了，而有些人的用了1000次也仍然完好无损。这和批次的质量等有关系，而在一个界限值之下，人们往往会将它的使用年限用指数分布来衡量：一块充放电100次的电池和一块充放300次的电池，在未来还能使用100次的概率是相同的。虽然听上去很不可思议，但是这也是由于指数分布的方差极大二导致的。</p>\n<p>同理，虽然听上去不可思议，但是你等公交车的时间往往也和上一辆车什么时候开走的没有什么关系，因为指数分布是没有记忆的，它不会“记得”上一次公交车经过的时间。而等待时间的平均值，和公交车间隔的平均值是相同的。</p>\n<h1 id=\"等车悖论\"><a href=\"#等车悖论\" class=\"headerlink\" title=\"等车悖论\"></a>等车悖论</h1><p>等车悖论告诉我们的不仅仅是你等车的时间要比你想象的长，更重要的是，我们必须要知道，我们脑海中假定的模型和现实生活中的模型总有一点偏差，而这点偏差往往导致的是我们捶胸顿足，发现自己又迟到了又赶不上车了。</p>\n<p>可能这就是所谓的“生活总有一些不如意吧”，因为是总有，所以背后就有其道理呀！</p>\n","site":{"data":{}},"excerpt":"<p>十字路口的红绿灯，每分钟交替一次的话，你在红灯的时候到达的平均等待时间是多久？</p>\n<p>$1分钟/2  = 半分钟$</p>\n<p>公交车平均五分钟来一次的话你等公交车要多久？</p>\n<p>$5分钟/2 =两分半$ </p>\n<p>错啦！这就是经典的等车悖论，因为公交车平均每五分钟来一辆，那么你的平均等待时间将是五分钟。</p>\n<h1 id=\"均匀分布和指数分布\"><a href=\"#均匀分布和指数分布\" class=\"headerlink\" title=\"均匀分布和指数分布\"></a>均匀分布和指数分布</h1><p>红绿灯和公交车有什么不同的地方呢？</p>","more":"<p>我们往往假设，红绿灯每次交替的时间是固定的（假设是一分钟），是不随着雨天还是晴天而改变的。如果我们在任何时间抵达红绿灯前，我们到达的分布可以视作是均匀分布的（如下图）。</p>\n<p><img src=\"https://upload.wikimedia.org/wikipedia/commons/thumb/9/9c/Uniform_distribution_PDF.png/350px-Uniform_distribution_PDF.png\" alt=\"Uniform distribution PDF\"></p>\n<p>也就是说，在每个红灯的前，我们可能的等待时间是从0分钟（一到灯就绿了）到1分钟之间（一到灯就红了）每个时间出现的可能性是完全一致的。因此我们可以简单地做一个平均运算来算出我们的期待值，也就是说：</p>\n<p>$E[X]={\\frac  {a+b}{2}} = {\\frac  {1+0}{2}} = {\\frac{1}{2}}$</p>\n<p>但是相比之下公交车则完全不同，公交车的到达时间是平均五分钟，这么说来和红绿灯则是完全不同。路况不同，路上的红绿灯稍有不同，就不可能在五分钟准时抵达。虽然人们脑海中认为公交车和红绿灯一样也是完全准时的，但事实却不是如此。我们往往将一段时间内到达公交车的数量假设为泊松分布，而公交车的间隔是指数分布的（下图）。</p>\n<p><img src=\"https://upload.wikimedia.org/wikipedia/commons/thumb/e/ec/Exponential_pdf.svg/325px-Exponential_pdf.svg.png\" alt=\"Probability density function\"></p>\n<p>如果从指数分布去考虑，我们等待的时间并不是均匀分布的。直观地说，我们到达等待时间更长的区间的可能性更大，因此我们等待的平均时间，并不是一个简单的算术平均值，而是一个加权平均值，而等待的时长也因此被拉高了。</p>\n<h1 id=\"指数分布的无记忆性\"><a href=\"#指数分布的无记忆性\" class=\"headerlink\" title=\"指数分布的无记忆性\"></a>指数分布的无记忆性</h1><p>无记忆性指的是，指数分布的概率只和时间区间有关，和已经发生了多久（时间的起点）无关。用数学公式可以表达为：</p>\n<p>$\\Pr \\left (T &gt; s + t | T &gt; s \\right ) = \\Pr(T &gt; t), \\qquad \\forall s, t \\ge 0$</p>\n<p>证明可以通过条件概率的贝叶斯定律。另外，由于对时间而言， $Pr(T&gt;s+t\\cap T&gt;s) = Pr(T&gt;s+t)$ 易证上述公式成立。</p>\n<p>生活中有许多东西服从指数分布。例如电池等电子元件的寿命在低于某个值的时候：如果电池标示1000次充放电会坏，往往有些人的用了100次就坏了，而有些人的用了1000次也仍然完好无损。这和批次的质量等有关系，而在一个界限值之下，人们往往会将它的使用年限用指数分布来衡量：一块充放电100次的电池和一块充放300次的电池，在未来还能使用100次的概率是相同的。虽然听上去很不可思议，但是这也是由于指数分布的方差极大二导致的。</p>\n<p>同理，虽然听上去不可思议，但是你等公交车的时间往往也和上一辆车什么时候开走的没有什么关系，因为指数分布是没有记忆的，它不会“记得”上一次公交车经过的时间。而等待时间的平均值，和公交车间隔的平均值是相同的。</p>\n<h1 id=\"等车悖论\"><a href=\"#等车悖论\" class=\"headerlink\" title=\"等车悖论\"></a>等车悖论</h1><p>等车悖论告诉我们的不仅仅是你等车的时间要比你想象的长，更重要的是，我们必须要知道，我们脑海中假定的模型和现实生活中的模型总有一点偏差，而这点偏差往往导致的是我们捶胸顿足，发现自己又迟到了又赶不上车了。</p>\n<p>可能这就是所谓的“生活总有一些不如意吧”，因为是总有，所以背后就有其道理呀！</p>"},{"title":"从零开始微信机器人（二）：使用图灵机器人和api.ai相关接口","date":"2017-06-23T16:00:00.000Z","_content":"\n\n\n# 图灵机器人相关接口\n\n图灵机器人是一个中文语境下的对话机器人，免费的机器人每天有5000次调用的，如果放在群聊中是完全够用的（如果只有@的消息才使用机器人回复的）。图灵机器人也包括一些简单的能力，比如讲笑话、故事大全、成语接龙、新闻资讯等，我们将介绍如何简单调用图灵机器人接口。\n\n\n\n## 前期准备\n\n1. 前往注册[图灵机器人](http://www.tuling123.com/)，增加一个机器人，并记录机器人的APIKey。具体注册方法可以前往[图灵API](http://www.tuling123.com/help/h_cent_webapi.jhtml?nav=doc)查看。（如果你觉得很麻烦， 也可以暂时使用itchat提供的几个[key](http://itchat.readthedocs.io/zh/latest/tutorial/tutorial0/#3_1)）\n\n2. 安装[Requests: HTTP for Humans](http://docs.python-requests.org/)\n\n   ```shell\n   # 从 pip 安装 ()\n   pip install requests\n   ```\n\n   并在机器人中导入Requests包（写在程序最初）：\n\n   ```python\n   import requests\n   ```\n\n\n<!--more-->\n\n## 调用接口\n\nwxpy提供了图灵的接口，使用方法：\n\n```python\ntuling = Tuling(api_key='Your API Key') # 刚才申请的key\n\n@bot.register(my_friend) # 注册消息\ndef reply_my_friend(msg):\n    tuling.do_reply(msg)\n```\n\n为了让大家了解HTTP协议在python中的使用方式，我接下来会介绍如何使用请求获取信息。\n\n本节中内容如果没有特殊提示，都应写在你希望处理的某种注册了的消息方法中以保证它的正常运作。\n\n首先，将图灵API写入程序中：\n\n```python\nTULING_TOKEN = 'Your API Key'\n```\n\n然后，定义接口链接和需要传输的数据：\n\n```python\nurl_api = 'http://www.tuling123.com/openapi/api'\ndata = {\n    'key'    : TULING_TOKEN,\n    'info'   : msg.text, # 收到消息的文字内容\n}\n```\n根据文档，通过HTTP请求，我们将会得到一个json格式的文件。使用Requests包，我们可以简单的获得调用接口所返回的信息：\n\n```python\ns = requests.post(url_api, data=data).json()\nprint s # 打印所获得的json查看如何使用\n# {u'text': u'回复的内容', u'code': 100000}\n```\n\n我们发现经过请求，我们一般会得到一个字典内容，其中包括text和code两项：text是图灵机器人回复的文本，而code是返回的编号。详细的返回数据格式也可以在[图灵API](http://www.tuling123.com/help/h_cent_webapi.jhtml?nav=doc)中看到，除了文字类还有新闻类、图片类、链接类等返回类型。在这里我们以文字类为例，介绍如何处理：\n\n```python\nif s['code'] == 100000:\n\t\tprint s['text'] # 查看回复消息的内容，可省略\n\t\tmsg.reply(s['text']) # 回复消息\n```\n\n如果需要回复其他类型的消息，也完全可以通过判断code确定消息类型，再决定如何回复。这里给出我的回复方法供大家参考（也可以选择不处理这一类内容）：\n\n```python\nif s['code'] == 200000: # 链接类：回复文字和链接\n    msg.reply(s['text'] + s['url'])\n```\n\n至此，我们已经成功调用了图灵机器人的API接口进行回复，完整程序如下：\n\n```python\n# -*- coding: utf-8 -*-\n\nfrom wxpy import *\nimport requests\n\nTULING_TOKEN = 'Your API Key'\nbot = Bot()\n\n@bot.register(Group, TEXT) # 这里注册了群聊中的文字消息，测试时可以设置为自己(上篇中提到过)\ndef group_msg(msg):\n\tif msg.is_at:\n\t\turl_api = 'http://www.tuling123.com/openapi/api'\n\t\tdata = {\n\t\t    'key'    : TULING_TOKEN,\n\t\t    'info'   : msg.text, # 收到消息的文字内容\n\t\t}\n\n\t\ts = requests.post(url_api, data=data).json()\n\t\tprint s # 打印所获得的json查看如何使用\n\n\t\tif s['code'] == 100000:\n\t\t\tprint s['text'] # 查看回复消息的内容，可省略\n\t\t\tmsg.reply(s['text']) # 回复消息\n        \nembed()\n```\n以下内容更加进阶，而文末有一些简单问题的解答。如果遇到其他问题，我也会在之后更新。\n\n\n\n## 番外：使用上下文\n\nwxpy给每个用户定义了一个相对稳定的对象/用户id，为puid，可以始终被获取到并有唯一的稳定性（根据文档），我们可以使用这个id来作为userid传给图灵机器人，以方便识别机器人或航班/列成信息的上下文。\n\n```python\nbot.enable_puid() # puid 需要手动开启，请将这句话写在登陆登录之后\n```\n\n这样传送给接口的数据也要同时修改为：\n\n```python\ndata = {\n    'key'    : TULING_TOKEN,\n    'info'   : msg.text, # 收到消息的文字内容\n    'userid' : msg.member.puid, # 使用群聊中发送者的 puid 作为 userid 传送给图灵接口， 如果是私聊可以使用 msg.sender.puid\n}\n```\n这样做的好处是，图灵机器人可以根据得userid来获取上下文信息。例如你询问『天气』，它会回复『亲爱的，悄悄地告诉我你在哪个城市？』。在这种情况下，如果你不使用userid参数，你再次回复城市，图灵机器人也无法正确找到天气；如果你使用了这一参数，且两次回复使用的userid相同，图灵机器人会为你回复你回复的城市的天气情况，完成这一对话。\n\n\n\n# 使用api.ai\n\napi.ai是一家被谷歌收购的人机交互系统，主要着重于对话机器人的开发。图灵机器人虽然包括一个知识库，但其语义识别的能力较差。我所需要的机器人主要用于新生群，很多问题人与人之间会有相当多不同的表达，图灵机器人无法满足我对于群聊机器人的要求。因此，我尝试使用api.ai进行回复有针对性的一些问题。\n\n如果你的英语相对糟糕，我不建议使用api.ai。api.ai的配置大多需要使用英语，虽然接口简单，但是后台设置相对复杂，如果没有英文背景不推荐使用。\n\n这一部分内容相对进阶，如果没有特殊需要，完全可以跳过不看。这里只作一个对api.ai使用方式上大体的介绍，希望能帮助大家了解这一网站。\n\n\n\n## 前期准备\n\n1. 前往[api.ai](https://api.ai/)注册，创建机器人，并获得APIkey。虽然被谷歌收购，但是这个网站是不需要翻墙的哦！\n\n2. 安装api.ai官方提供的Python SDK\n\n   ```shell\n   pip install apiai\n   ```\n\n3. 在文件头部加入（处理返回的消息时使用）\n\n   ```python\n   import json\n   ```\n\n\n\n## 调用接口\n\n首先，我们需要设置api.ai的Token，\n\n```python\nAPIAI_TOKEN = 'Your API Key'\n```\n\n而后我们发起一个最简单的请求，一下内容都可以通过[例子](https://github.com/api-ai/apiai-python-client/tree/master/examples)找到：\n\n```python\nai = apiai.ApiAI(APIAI_TOKEN)\nrequest = ai.text_request()\nrequest.lang = 'zh-CN' # 使用中文\nrequest.session_id = msg.member.puid # api.ai 中用 session id 来区分对话对象，必须\nrequest.query = msg.text # 消息文字内容\n```\n\n然后通过接口得到传回的json：\n\n```python\nresponse = request.getresponse()\ns = json.loads(response.read(), encoding='UTF-8') # 讲传回的json转换为python字典\nprint s\n# {u'lang': u'zh-cn', u'status': {u'errorType': u'success', u'code': 200}, u'timestamp': u'20}\n```\n\n我们发现，api.ai传回的json相对于图灵机器人更加复杂。参考[api.ai的query文档](https://docs.api.ai/docs/query)，我对对这部分回复进行了如下处理：\n\n```python\nif s['result']['action'] == 'input.unknown': # \n    raise Exception('api.ai cannot reply this message') # 抛出异常：使用 try 语句捕捉后使用图灵机器人回复\nif s['status']['code'] == 200:\n    msg.reply(s['result']['fulfillment']['speech']) # 回复 api.ai 返回的内容\n```\n\n\n\n## api.ai的设置和调试\n\n在进入api.ai的机器人后，你将会看到左边的多个菜单。\n\n如果你只是简单的需要特定语句回复的功能，只需要创建并设置[Intents](https://docs.api.ai/docs/concept-intents)就可以实现。在User Says一栏中填写消息可能是什么，在下方Response处填写可能回复的内容，然后保存即可。\n\napi.ai自带机器学习功能，它的参数可以在机器人设置中的ML settings里找到。可以通过调整参数和方式让你的机器人回复更加准确。\n\n在进入机器人后，api.ai的右侧会出现一个对话框。你可以使用它进行一些基础调试。在上方输入你的消息后，下方会给出机器人的回复，你可以通过这个对话框来了解是否正确设置了机器人。（需要翻墙）\n\n# 你可能会遇到的一些问题\n\n## 报错：No handlers could be found for logger \"wxpy.api.bot\"\n\n有报错但是无法显示，可以选择在代码头部加入：\n\n```python\nimport logging\nlogging.basicConfig()\n```\n\n\n\n## 消息处理：删除@内容\n\n如果不删除消息中@部分的内容，图灵机器人的回复可能会受到昵称内容的影响，导致回复不准确，或是识别不出一些应当识别出的内容。我们可以用一段简单的代码删除@到空格之间的内容并去除首尾多余的空格。\n\n```python\nmsg_content = re.sub('@[^\\s]*', '', unicodedata.normalize('NFKC', msg.text)).strip()\n```\n\n这里使用了正则表达式，匹配@以及它之后所有不为空的字符。如果你的微信昵称中没有空白字符，这条代码是可行的。（需要在代码开头添加`import re`）","source":"_posts/connector-wechat-bot-2.md","raw":"---\ntitle: 从零开始微信机器人（二）：使用图灵机器人和api.ai相关接口\ndate: 2017-06-24\ncategory: 计算机课堂\ntags: \n- Python\n- 聊天机器人\n---\n\n\n\n# 图灵机器人相关接口\n\n图灵机器人是一个中文语境下的对话机器人，免费的机器人每天有5000次调用的，如果放在群聊中是完全够用的（如果只有@的消息才使用机器人回复的）。图灵机器人也包括一些简单的能力，比如讲笑话、故事大全、成语接龙、新闻资讯等，我们将介绍如何简单调用图灵机器人接口。\n\n\n\n## 前期准备\n\n1. 前往注册[图灵机器人](http://www.tuling123.com/)，增加一个机器人，并记录机器人的APIKey。具体注册方法可以前往[图灵API](http://www.tuling123.com/help/h_cent_webapi.jhtml?nav=doc)查看。（如果你觉得很麻烦， 也可以暂时使用itchat提供的几个[key](http://itchat.readthedocs.io/zh/latest/tutorial/tutorial0/#3_1)）\n\n2. 安装[Requests: HTTP for Humans](http://docs.python-requests.org/)\n\n   ```shell\n   # 从 pip 安装 ()\n   pip install requests\n   ```\n\n   并在机器人中导入Requests包（写在程序最初）：\n\n   ```python\n   import requests\n   ```\n\n\n<!--more-->\n\n## 调用接口\n\nwxpy提供了图灵的接口，使用方法：\n\n```python\ntuling = Tuling(api_key='Your API Key') # 刚才申请的key\n\n@bot.register(my_friend) # 注册消息\ndef reply_my_friend(msg):\n    tuling.do_reply(msg)\n```\n\n为了让大家了解HTTP协议在python中的使用方式，我接下来会介绍如何使用请求获取信息。\n\n本节中内容如果没有特殊提示，都应写在你希望处理的某种注册了的消息方法中以保证它的正常运作。\n\n首先，将图灵API写入程序中：\n\n```python\nTULING_TOKEN = 'Your API Key'\n```\n\n然后，定义接口链接和需要传输的数据：\n\n```python\nurl_api = 'http://www.tuling123.com/openapi/api'\ndata = {\n    'key'    : TULING_TOKEN,\n    'info'   : msg.text, # 收到消息的文字内容\n}\n```\n根据文档，通过HTTP请求，我们将会得到一个json格式的文件。使用Requests包，我们可以简单的获得调用接口所返回的信息：\n\n```python\ns = requests.post(url_api, data=data).json()\nprint s # 打印所获得的json查看如何使用\n# {u'text': u'回复的内容', u'code': 100000}\n```\n\n我们发现经过请求，我们一般会得到一个字典内容，其中包括text和code两项：text是图灵机器人回复的文本，而code是返回的编号。详细的返回数据格式也可以在[图灵API](http://www.tuling123.com/help/h_cent_webapi.jhtml?nav=doc)中看到，除了文字类还有新闻类、图片类、链接类等返回类型。在这里我们以文字类为例，介绍如何处理：\n\n```python\nif s['code'] == 100000:\n\t\tprint s['text'] # 查看回复消息的内容，可省略\n\t\tmsg.reply(s['text']) # 回复消息\n```\n\n如果需要回复其他类型的消息，也完全可以通过判断code确定消息类型，再决定如何回复。这里给出我的回复方法供大家参考（也可以选择不处理这一类内容）：\n\n```python\nif s['code'] == 200000: # 链接类：回复文字和链接\n    msg.reply(s['text'] + s['url'])\n```\n\n至此，我们已经成功调用了图灵机器人的API接口进行回复，完整程序如下：\n\n```python\n# -*- coding: utf-8 -*-\n\nfrom wxpy import *\nimport requests\n\nTULING_TOKEN = 'Your API Key'\nbot = Bot()\n\n@bot.register(Group, TEXT) # 这里注册了群聊中的文字消息，测试时可以设置为自己(上篇中提到过)\ndef group_msg(msg):\n\tif msg.is_at:\n\t\turl_api = 'http://www.tuling123.com/openapi/api'\n\t\tdata = {\n\t\t    'key'    : TULING_TOKEN,\n\t\t    'info'   : msg.text, # 收到消息的文字内容\n\t\t}\n\n\t\ts = requests.post(url_api, data=data).json()\n\t\tprint s # 打印所获得的json查看如何使用\n\n\t\tif s['code'] == 100000:\n\t\t\tprint s['text'] # 查看回复消息的内容，可省略\n\t\t\tmsg.reply(s['text']) # 回复消息\n        \nembed()\n```\n以下内容更加进阶，而文末有一些简单问题的解答。如果遇到其他问题，我也会在之后更新。\n\n\n\n## 番外：使用上下文\n\nwxpy给每个用户定义了一个相对稳定的对象/用户id，为puid，可以始终被获取到并有唯一的稳定性（根据文档），我们可以使用这个id来作为userid传给图灵机器人，以方便识别机器人或航班/列成信息的上下文。\n\n```python\nbot.enable_puid() # puid 需要手动开启，请将这句话写在登陆登录之后\n```\n\n这样传送给接口的数据也要同时修改为：\n\n```python\ndata = {\n    'key'    : TULING_TOKEN,\n    'info'   : msg.text, # 收到消息的文字内容\n    'userid' : msg.member.puid, # 使用群聊中发送者的 puid 作为 userid 传送给图灵接口， 如果是私聊可以使用 msg.sender.puid\n}\n```\n这样做的好处是，图灵机器人可以根据得userid来获取上下文信息。例如你询问『天气』，它会回复『亲爱的，悄悄地告诉我你在哪个城市？』。在这种情况下，如果你不使用userid参数，你再次回复城市，图灵机器人也无法正确找到天气；如果你使用了这一参数，且两次回复使用的userid相同，图灵机器人会为你回复你回复的城市的天气情况，完成这一对话。\n\n\n\n# 使用api.ai\n\napi.ai是一家被谷歌收购的人机交互系统，主要着重于对话机器人的开发。图灵机器人虽然包括一个知识库，但其语义识别的能力较差。我所需要的机器人主要用于新生群，很多问题人与人之间会有相当多不同的表达，图灵机器人无法满足我对于群聊机器人的要求。因此，我尝试使用api.ai进行回复有针对性的一些问题。\n\n如果你的英语相对糟糕，我不建议使用api.ai。api.ai的配置大多需要使用英语，虽然接口简单，但是后台设置相对复杂，如果没有英文背景不推荐使用。\n\n这一部分内容相对进阶，如果没有特殊需要，完全可以跳过不看。这里只作一个对api.ai使用方式上大体的介绍，希望能帮助大家了解这一网站。\n\n\n\n## 前期准备\n\n1. 前往[api.ai](https://api.ai/)注册，创建机器人，并获得APIkey。虽然被谷歌收购，但是这个网站是不需要翻墙的哦！\n\n2. 安装api.ai官方提供的Python SDK\n\n   ```shell\n   pip install apiai\n   ```\n\n3. 在文件头部加入（处理返回的消息时使用）\n\n   ```python\n   import json\n   ```\n\n\n\n## 调用接口\n\n首先，我们需要设置api.ai的Token，\n\n```python\nAPIAI_TOKEN = 'Your API Key'\n```\n\n而后我们发起一个最简单的请求，一下内容都可以通过[例子](https://github.com/api-ai/apiai-python-client/tree/master/examples)找到：\n\n```python\nai = apiai.ApiAI(APIAI_TOKEN)\nrequest = ai.text_request()\nrequest.lang = 'zh-CN' # 使用中文\nrequest.session_id = msg.member.puid # api.ai 中用 session id 来区分对话对象，必须\nrequest.query = msg.text # 消息文字内容\n```\n\n然后通过接口得到传回的json：\n\n```python\nresponse = request.getresponse()\ns = json.loads(response.read(), encoding='UTF-8') # 讲传回的json转换为python字典\nprint s\n# {u'lang': u'zh-cn', u'status': {u'errorType': u'success', u'code': 200}, u'timestamp': u'20}\n```\n\n我们发现，api.ai传回的json相对于图灵机器人更加复杂。参考[api.ai的query文档](https://docs.api.ai/docs/query)，我对对这部分回复进行了如下处理：\n\n```python\nif s['result']['action'] == 'input.unknown': # \n    raise Exception('api.ai cannot reply this message') # 抛出异常：使用 try 语句捕捉后使用图灵机器人回复\nif s['status']['code'] == 200:\n    msg.reply(s['result']['fulfillment']['speech']) # 回复 api.ai 返回的内容\n```\n\n\n\n## api.ai的设置和调试\n\n在进入api.ai的机器人后，你将会看到左边的多个菜单。\n\n如果你只是简单的需要特定语句回复的功能，只需要创建并设置[Intents](https://docs.api.ai/docs/concept-intents)就可以实现。在User Says一栏中填写消息可能是什么，在下方Response处填写可能回复的内容，然后保存即可。\n\napi.ai自带机器学习功能，它的参数可以在机器人设置中的ML settings里找到。可以通过调整参数和方式让你的机器人回复更加准确。\n\n在进入机器人后，api.ai的右侧会出现一个对话框。你可以使用它进行一些基础调试。在上方输入你的消息后，下方会给出机器人的回复，你可以通过这个对话框来了解是否正确设置了机器人。（需要翻墙）\n\n# 你可能会遇到的一些问题\n\n## 报错：No handlers could be found for logger \"wxpy.api.bot\"\n\n有报错但是无法显示，可以选择在代码头部加入：\n\n```python\nimport logging\nlogging.basicConfig()\n```\n\n\n\n## 消息处理：删除@内容\n\n如果不删除消息中@部分的内容，图灵机器人的回复可能会受到昵称内容的影响，导致回复不准确，或是识别不出一些应当识别出的内容。我们可以用一段简单的代码删除@到空格之间的内容并去除首尾多余的空格。\n\n```python\nmsg_content = re.sub('@[^\\s]*', '', unicodedata.normalize('NFKC', msg.text)).strip()\n```\n\n这里使用了正则表达式，匹配@以及它之后所有不为空的字符。如果你的微信昵称中没有空白字符，这条代码是可行的。（需要在代码开头添加`import re`）","slug":"connector-wechat-bot-2","published":1,"updated":"2018-07-03T13:44:30.392Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj5repu800049pd38zvtapq8","content":"<h1 id=\"图灵机器人相关接口\"><a href=\"#图灵机器人相关接口\" class=\"headerlink\" title=\"图灵机器人相关接口\"></a>图灵机器人相关接口</h1><p>图灵机器人是一个中文语境下的对话机器人，免费的机器人每天有5000次调用的，如果放在群聊中是完全够用的（如果只有@的消息才使用机器人回复的）。图灵机器人也包括一些简单的能力，比如讲笑话、故事大全、成语接龙、新闻资讯等，我们将介绍如何简单调用图灵机器人接口。</p>\n<h2 id=\"前期准备\"><a href=\"#前期准备\" class=\"headerlink\" title=\"前期准备\"></a>前期准备</h2><ol>\n<li><p>前往注册<a href=\"http://www.tuling123.com/\" target=\"_blank\" rel=\"noopener\">图灵机器人</a>，增加一个机器人，并记录机器人的APIKey。具体注册方法可以前往<a href=\"http://www.tuling123.com/help/h_cent_webapi.jhtml?nav=doc\" target=\"_blank\" rel=\"noopener\">图灵API</a>查看。（如果你觉得很麻烦， 也可以暂时使用itchat提供的几个<a href=\"http://itchat.readthedocs.io/zh/latest/tutorial/tutorial0/#3_1\" target=\"_blank\" rel=\"noopener\">key</a>）</p>\n</li>\n<li><p>安装<a href=\"http://docs.python-requests.org/\" target=\"_blank\" rel=\"noopener\">Requests: HTTP for Humans</a></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span> 从 pip 安装 ()</span><br><span class=\"line\">pip install requests</span><br></pre></td></tr></table></figure>\n<p>并在机器人中导入Requests包（写在程序最初）：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> requests</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<a id=\"more\"></a>\n<h2 id=\"调用接口\"><a href=\"#调用接口\" class=\"headerlink\" title=\"调用接口\"></a>调用接口</h2><p>wxpy提供了图灵的接口，使用方法：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tuling = Tuling(api_key=<span class=\"string\">'Your API Key'</span>) <span class=\"comment\"># 刚才申请的key</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@bot.register(my_friend) # 注册消息</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">reply_my_friend</span><span class=\"params\">(msg)</span>:</span></span><br><span class=\"line\">    tuling.do_reply(msg)</span><br></pre></td></tr></table></figure>\n<p>为了让大家了解HTTP协议在python中的使用方式，我接下来会介绍如何使用请求获取信息。</p>\n<p>本节中内容如果没有特殊提示，都应写在你希望处理的某种注册了的消息方法中以保证它的正常运作。</p>\n<p>首先，将图灵API写入程序中：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TULING_TOKEN = <span class=\"string\">'Your API Key'</span></span><br></pre></td></tr></table></figure>\n<p>然后，定义接口链接和需要传输的数据：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">url_api = <span class=\"string\">'http://www.tuling123.com/openapi/api'</span></span><br><span class=\"line\">data = &#123;</span><br><span class=\"line\">    <span class=\"string\">'key'</span>    : TULING_TOKEN,</span><br><span class=\"line\">    <span class=\"string\">'info'</span>   : msg.text, <span class=\"comment\"># 收到消息的文字内容</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>根据文档，通过HTTP请求，我们将会得到一个json格式的文件。使用Requests包，我们可以简单的获得调用接口所返回的信息：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s = requests.post(url_api, data=data).json()</span><br><span class=\"line\"><span class=\"keyword\">print</span> s <span class=\"comment\"># 打印所获得的json查看如何使用</span></span><br><span class=\"line\"><span class=\"comment\"># &#123;u'text': u'回复的内容', u'code': 100000&#125;</span></span><br></pre></td></tr></table></figure>\n<p>我们发现经过请求，我们一般会得到一个字典内容，其中包括text和code两项：text是图灵机器人回复的文本，而code是返回的编号。详细的返回数据格式也可以在<a href=\"http://www.tuling123.com/help/h_cent_webapi.jhtml?nav=doc\" target=\"_blank\" rel=\"noopener\">图灵API</a>中看到，除了文字类还有新闻类、图片类、链接类等返回类型。在这里我们以文字类为例，介绍如何处理：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> s[<span class=\"string\">'code'</span>] == <span class=\"number\">100000</span>:</span><br><span class=\"line\">\t\t<span class=\"keyword\">print</span> s[<span class=\"string\">'text'</span>] <span class=\"comment\"># 查看回复消息的内容，可省略</span></span><br><span class=\"line\">\t\tmsg.reply(s[<span class=\"string\">'text'</span>]) <span class=\"comment\"># 回复消息</span></span><br></pre></td></tr></table></figure>\n<p>如果需要回复其他类型的消息，也完全可以通过判断code确定消息类型，再决定如何回复。这里给出我的回复方法供大家参考（也可以选择不处理这一类内容）：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> s[<span class=\"string\">'code'</span>] == <span class=\"number\">200000</span>: <span class=\"comment\"># 链接类：回复文字和链接</span></span><br><span class=\"line\">    msg.reply(s[<span class=\"string\">'text'</span>] + s[<span class=\"string\">'url'</span>])</span><br></pre></td></tr></table></figure>\n<p>至此，我们已经成功调用了图灵机器人的API接口进行回复，完整程序如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># -*- coding: utf-8 -*-</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> wxpy <span class=\"keyword\">import</span> *</span><br><span class=\"line\"><span class=\"keyword\">import</span> requests</span><br><span class=\"line\"></span><br><span class=\"line\">TULING_TOKEN = <span class=\"string\">'Your API Key'</span></span><br><span class=\"line\">bot = Bot()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@bot.register(Group, TEXT) # 这里注册了群聊中的文字消息，测试时可以设置为自己(上篇中提到过)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">group_msg</span><span class=\"params\">(msg)</span>:</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> msg.is_at:</span><br><span class=\"line\">\t\turl_api = <span class=\"string\">'http://www.tuling123.com/openapi/api'</span></span><br><span class=\"line\">\t\tdata = &#123;</span><br><span class=\"line\">\t\t    <span class=\"string\">'key'</span>    : TULING_TOKEN,</span><br><span class=\"line\">\t\t    <span class=\"string\">'info'</span>   : msg.text, <span class=\"comment\"># 收到消息的文字内容</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\ts = requests.post(url_api, data=data).json()</span><br><span class=\"line\">\t\t<span class=\"keyword\">print</span> s <span class=\"comment\"># 打印所获得的json查看如何使用</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> s[<span class=\"string\">'code'</span>] == <span class=\"number\">100000</span>:</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">print</span> s[<span class=\"string\">'text'</span>] <span class=\"comment\"># 查看回复消息的内容，可省略</span></span><br><span class=\"line\">\t\t\tmsg.reply(s[<span class=\"string\">'text'</span>]) <span class=\"comment\"># 回复消息</span></span><br><span class=\"line\">        </span><br><span class=\"line\">embed()</span><br></pre></td></tr></table></figure>\n<p>以下内容更加进阶，而文末有一些简单问题的解答。如果遇到其他问题，我也会在之后更新。</p>\n<h2 id=\"番外：使用上下文\"><a href=\"#番外：使用上下文\" class=\"headerlink\" title=\"番外：使用上下文\"></a>番外：使用上下文</h2><p>wxpy给每个用户定义了一个相对稳定的对象/用户id，为puid，可以始终被获取到并有唯一的稳定性（根据文档），我们可以使用这个id来作为userid传给图灵机器人，以方便识别机器人或航班/列成信息的上下文。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bot.enable_puid() <span class=\"comment\"># puid 需要手动开启，请将这句话写在登陆登录之后</span></span><br></pre></td></tr></table></figure>\n<p>这样传送给接口的数据也要同时修改为：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">data = &#123;</span><br><span class=\"line\">    <span class=\"string\">'key'</span>    : TULING_TOKEN,</span><br><span class=\"line\">    <span class=\"string\">'info'</span>   : msg.text, <span class=\"comment\"># 收到消息的文字内容</span></span><br><span class=\"line\">    <span class=\"string\">'userid'</span> : msg.member.puid, <span class=\"comment\"># 使用群聊中发送者的 puid 作为 userid 传送给图灵接口， 如果是私聊可以使用 msg.sender.puid</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样做的好处是，图灵机器人可以根据得userid来获取上下文信息。例如你询问『天气』，它会回复『亲爱的，悄悄地告诉我你在哪个城市？』。在这种情况下，如果你不使用userid参数，你再次回复城市，图灵机器人也无法正确找到天气；如果你使用了这一参数，且两次回复使用的userid相同，图灵机器人会为你回复你回复的城市的天气情况，完成这一对话。</p>\n<h1 id=\"使用api-ai\"><a href=\"#使用api-ai\" class=\"headerlink\" title=\"使用api.ai\"></a>使用api.ai</h1><p>api.ai是一家被谷歌收购的人机交互系统，主要着重于对话机器人的开发。图灵机器人虽然包括一个知识库，但其语义识别的能力较差。我所需要的机器人主要用于新生群，很多问题人与人之间会有相当多不同的表达，图灵机器人无法满足我对于群聊机器人的要求。因此，我尝试使用api.ai进行回复有针对性的一些问题。</p>\n<p>如果你的英语相对糟糕，我不建议使用api.ai。api.ai的配置大多需要使用英语，虽然接口简单，但是后台设置相对复杂，如果没有英文背景不推荐使用。</p>\n<p>这一部分内容相对进阶，如果没有特殊需要，完全可以跳过不看。这里只作一个对api.ai使用方式上大体的介绍，希望能帮助大家了解这一网站。</p>\n<h2 id=\"前期准备-1\"><a href=\"#前期准备-1\" class=\"headerlink\" title=\"前期准备\"></a>前期准备</h2><ol>\n<li><p>前往<a href=\"https://api.ai/\" target=\"_blank\" rel=\"noopener\">api.ai</a>注册，创建机器人，并获得APIkey。虽然被谷歌收购，但是这个网站是不需要翻墙的哦！</p>\n</li>\n<li><p>安装api.ai官方提供的Python SDK</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip install apiai</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在文件头部加入（处理返回的消息时使用）</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> json</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"调用接口-1\"><a href=\"#调用接口-1\" class=\"headerlink\" title=\"调用接口\"></a>调用接口</h2><p>首先，我们需要设置api.ai的Token，</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">APIAI_TOKEN = <span class=\"string\">'Your API Key'</span></span><br></pre></td></tr></table></figure>\n<p>而后我们发起一个最简单的请求，一下内容都可以通过<a href=\"https://github.com/api-ai/apiai-python-client/tree/master/examples\" target=\"_blank\" rel=\"noopener\">例子</a>找到：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ai = apiai.ApiAI(APIAI_TOKEN)</span><br><span class=\"line\">request = ai.text_request()</span><br><span class=\"line\">request.lang = <span class=\"string\">'zh-CN'</span> <span class=\"comment\"># 使用中文</span></span><br><span class=\"line\">request.session_id = msg.member.puid <span class=\"comment\"># api.ai 中用 session id 来区分对话对象，必须</span></span><br><span class=\"line\">request.query = msg.text <span class=\"comment\"># 消息文字内容</span></span><br></pre></td></tr></table></figure>\n<p>然后通过接口得到传回的json：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">response = request.getresponse()</span><br><span class=\"line\">s = json.loads(response.read(), encoding=<span class=\"string\">'UTF-8'</span>) <span class=\"comment\"># 讲传回的json转换为python字典</span></span><br><span class=\"line\"><span class=\"keyword\">print</span> s</span><br><span class=\"line\"><span class=\"comment\"># &#123;u'lang': u'zh-cn', u'status': &#123;u'errorType': u'success', u'code': 200&#125;, u'timestamp': u'20&#125;</span></span><br></pre></td></tr></table></figure>\n<p>我们发现，api.ai传回的json相对于图灵机器人更加复杂。参考<a href=\"https://docs.api.ai/docs/query\" target=\"_blank\" rel=\"noopener\">api.ai的query文档</a>，我对对这部分回复进行了如下处理：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> s[<span class=\"string\">'result'</span>][<span class=\"string\">'action'</span>] == <span class=\"string\">'input.unknown'</span>: <span class=\"comment\"># </span></span><br><span class=\"line\">    <span class=\"keyword\">raise</span> Exception(<span class=\"string\">'api.ai cannot reply this message'</span>) <span class=\"comment\"># 抛出异常：使用 try 语句捕捉后使用图灵机器人回复</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> s[<span class=\"string\">'status'</span>][<span class=\"string\">'code'</span>] == <span class=\"number\">200</span>:</span><br><span class=\"line\">    msg.reply(s[<span class=\"string\">'result'</span>][<span class=\"string\">'fulfillment'</span>][<span class=\"string\">'speech'</span>]) <span class=\"comment\"># 回复 api.ai 返回的内容</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"api-ai的设置和调试\"><a href=\"#api-ai的设置和调试\" class=\"headerlink\" title=\"api.ai的设置和调试\"></a>api.ai的设置和调试</h2><p>在进入api.ai的机器人后，你将会看到左边的多个菜单。</p>\n<p>如果你只是简单的需要特定语句回复的功能，只需要创建并设置<a href=\"https://docs.api.ai/docs/concept-intents\" target=\"_blank\" rel=\"noopener\">Intents</a>就可以实现。在User Says一栏中填写消息可能是什么，在下方Response处填写可能回复的内容，然后保存即可。</p>\n<p>api.ai自带机器学习功能，它的参数可以在机器人设置中的ML settings里找到。可以通过调整参数和方式让你的机器人回复更加准确。</p>\n<p>在进入机器人后，api.ai的右侧会出现一个对话框。你可以使用它进行一些基础调试。在上方输入你的消息后，下方会给出机器人的回复，你可以通过这个对话框来了解是否正确设置了机器人。（需要翻墙）</p>\n<h1 id=\"你可能会遇到的一些问题\"><a href=\"#你可能会遇到的一些问题\" class=\"headerlink\" title=\"你可能会遇到的一些问题\"></a>你可能会遇到的一些问题</h1><h2 id=\"报错：No-handlers-could-be-found-for-logger-“wxpy-api-bot”\"><a href=\"#报错：No-handlers-could-be-found-for-logger-“wxpy-api-bot”\" class=\"headerlink\" title=\"报错：No handlers could be found for logger “wxpy.api.bot”\"></a>报错：No handlers could be found for logger “wxpy.api.bot”</h2><p>有报错但是无法显示，可以选择在代码头部加入：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> logging</span><br><span class=\"line\">logging.basicConfig()</span><br></pre></td></tr></table></figure>\n<h2 id=\"消息处理：删除-内容\"><a href=\"#消息处理：删除-内容\" class=\"headerlink\" title=\"消息处理：删除@内容\"></a>消息处理：删除@内容</h2><p>如果不删除消息中@部分的内容，图灵机器人的回复可能会受到昵称内容的影响，导致回复不准确，或是识别不出一些应当识别出的内容。我们可以用一段简单的代码删除@到空格之间的内容并去除首尾多余的空格。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">msg_content = re.sub(<span class=\"string\">'@[^\\s]*'</span>, <span class=\"string\">''</span>, unicodedata.normalize(<span class=\"string\">'NFKC'</span>, msg.text)).strip()</span><br></pre></td></tr></table></figure>\n<p>这里使用了正则表达式，匹配@以及它之后所有不为空的字符。如果你的微信昵称中没有空白字符，这条代码是可行的。（需要在代码开头添加<code>import re</code>）</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"图灵机器人相关接口\"><a href=\"#图灵机器人相关接口\" class=\"headerlink\" title=\"图灵机器人相关接口\"></a>图灵机器人相关接口</h1><p>图灵机器人是一个中文语境下的对话机器人，免费的机器人每天有5000次调用的，如果放在群聊中是完全够用的（如果只有@的消息才使用机器人回复的）。图灵机器人也包括一些简单的能力，比如讲笑话、故事大全、成语接龙、新闻资讯等，我们将介绍如何简单调用图灵机器人接口。</p>\n<h2 id=\"前期准备\"><a href=\"#前期准备\" class=\"headerlink\" title=\"前期准备\"></a>前期准备</h2><ol>\n<li><p>前往注册<a href=\"http://www.tuling123.com/\" target=\"_blank\" rel=\"noopener\">图灵机器人</a>，增加一个机器人，并记录机器人的APIKey。具体注册方法可以前往<a href=\"http://www.tuling123.com/help/h_cent_webapi.jhtml?nav=doc\" target=\"_blank\" rel=\"noopener\">图灵API</a>查看。（如果你觉得很麻烦， 也可以暂时使用itchat提供的几个<a href=\"http://itchat.readthedocs.io/zh/latest/tutorial/tutorial0/#3_1\" target=\"_blank\" rel=\"noopener\">key</a>）</p>\n</li>\n<li><p>安装<a href=\"http://docs.python-requests.org/\" target=\"_blank\" rel=\"noopener\">Requests: HTTP for Humans</a></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span> 从 pip 安装 ()</span><br><span class=\"line\">pip install requests</span><br></pre></td></tr></table></figure>\n<p>并在机器人中导入Requests包（写在程序最初）：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> requests</span><br></pre></td></tr></table></figure>\n</li>\n</ol>","more":"<h2 id=\"调用接口\"><a href=\"#调用接口\" class=\"headerlink\" title=\"调用接口\"></a>调用接口</h2><p>wxpy提供了图灵的接口，使用方法：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tuling = Tuling(api_key=<span class=\"string\">'Your API Key'</span>) <span class=\"comment\"># 刚才申请的key</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@bot.register(my_friend) # 注册消息</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">reply_my_friend</span><span class=\"params\">(msg)</span>:</span></span><br><span class=\"line\">    tuling.do_reply(msg)</span><br></pre></td></tr></table></figure>\n<p>为了让大家了解HTTP协议在python中的使用方式，我接下来会介绍如何使用请求获取信息。</p>\n<p>本节中内容如果没有特殊提示，都应写在你希望处理的某种注册了的消息方法中以保证它的正常运作。</p>\n<p>首先，将图灵API写入程序中：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TULING_TOKEN = <span class=\"string\">'Your API Key'</span></span><br></pre></td></tr></table></figure>\n<p>然后，定义接口链接和需要传输的数据：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">url_api = <span class=\"string\">'http://www.tuling123.com/openapi/api'</span></span><br><span class=\"line\">data = &#123;</span><br><span class=\"line\">    <span class=\"string\">'key'</span>    : TULING_TOKEN,</span><br><span class=\"line\">    <span class=\"string\">'info'</span>   : msg.text, <span class=\"comment\"># 收到消息的文字内容</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>根据文档，通过HTTP请求，我们将会得到一个json格式的文件。使用Requests包，我们可以简单的获得调用接口所返回的信息：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s = requests.post(url_api, data=data).json()</span><br><span class=\"line\"><span class=\"keyword\">print</span> s <span class=\"comment\"># 打印所获得的json查看如何使用</span></span><br><span class=\"line\"><span class=\"comment\"># &#123;u'text': u'回复的内容', u'code': 100000&#125;</span></span><br></pre></td></tr></table></figure>\n<p>我们发现经过请求，我们一般会得到一个字典内容，其中包括text和code两项：text是图灵机器人回复的文本，而code是返回的编号。详细的返回数据格式也可以在<a href=\"http://www.tuling123.com/help/h_cent_webapi.jhtml?nav=doc\" target=\"_blank\" rel=\"noopener\">图灵API</a>中看到，除了文字类还有新闻类、图片类、链接类等返回类型。在这里我们以文字类为例，介绍如何处理：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> s[<span class=\"string\">'code'</span>] == <span class=\"number\">100000</span>:</span><br><span class=\"line\">\t\t<span class=\"keyword\">print</span> s[<span class=\"string\">'text'</span>] <span class=\"comment\"># 查看回复消息的内容，可省略</span></span><br><span class=\"line\">\t\tmsg.reply(s[<span class=\"string\">'text'</span>]) <span class=\"comment\"># 回复消息</span></span><br></pre></td></tr></table></figure>\n<p>如果需要回复其他类型的消息，也完全可以通过判断code确定消息类型，再决定如何回复。这里给出我的回复方法供大家参考（也可以选择不处理这一类内容）：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> s[<span class=\"string\">'code'</span>] == <span class=\"number\">200000</span>: <span class=\"comment\"># 链接类：回复文字和链接</span></span><br><span class=\"line\">    msg.reply(s[<span class=\"string\">'text'</span>] + s[<span class=\"string\">'url'</span>])</span><br></pre></td></tr></table></figure>\n<p>至此，我们已经成功调用了图灵机器人的API接口进行回复，完整程序如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># -*- coding: utf-8 -*-</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> wxpy <span class=\"keyword\">import</span> *</span><br><span class=\"line\"><span class=\"keyword\">import</span> requests</span><br><span class=\"line\"></span><br><span class=\"line\">TULING_TOKEN = <span class=\"string\">'Your API Key'</span></span><br><span class=\"line\">bot = Bot()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@bot.register(Group, TEXT) # 这里注册了群聊中的文字消息，测试时可以设置为自己(上篇中提到过)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">group_msg</span><span class=\"params\">(msg)</span>:</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> msg.is_at:</span><br><span class=\"line\">\t\turl_api = <span class=\"string\">'http://www.tuling123.com/openapi/api'</span></span><br><span class=\"line\">\t\tdata = &#123;</span><br><span class=\"line\">\t\t    <span class=\"string\">'key'</span>    : TULING_TOKEN,</span><br><span class=\"line\">\t\t    <span class=\"string\">'info'</span>   : msg.text, <span class=\"comment\"># 收到消息的文字内容</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\ts = requests.post(url_api, data=data).json()</span><br><span class=\"line\">\t\t<span class=\"keyword\">print</span> s <span class=\"comment\"># 打印所获得的json查看如何使用</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> s[<span class=\"string\">'code'</span>] == <span class=\"number\">100000</span>:</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">print</span> s[<span class=\"string\">'text'</span>] <span class=\"comment\"># 查看回复消息的内容，可省略</span></span><br><span class=\"line\">\t\t\tmsg.reply(s[<span class=\"string\">'text'</span>]) <span class=\"comment\"># 回复消息</span></span><br><span class=\"line\">        </span><br><span class=\"line\">embed()</span><br></pre></td></tr></table></figure>\n<p>以下内容更加进阶，而文末有一些简单问题的解答。如果遇到其他问题，我也会在之后更新。</p>\n<h2 id=\"番外：使用上下文\"><a href=\"#番外：使用上下文\" class=\"headerlink\" title=\"番外：使用上下文\"></a>番外：使用上下文</h2><p>wxpy给每个用户定义了一个相对稳定的对象/用户id，为puid，可以始终被获取到并有唯一的稳定性（根据文档），我们可以使用这个id来作为userid传给图灵机器人，以方便识别机器人或航班/列成信息的上下文。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bot.enable_puid() <span class=\"comment\"># puid 需要手动开启，请将这句话写在登陆登录之后</span></span><br></pre></td></tr></table></figure>\n<p>这样传送给接口的数据也要同时修改为：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">data = &#123;</span><br><span class=\"line\">    <span class=\"string\">'key'</span>    : TULING_TOKEN,</span><br><span class=\"line\">    <span class=\"string\">'info'</span>   : msg.text, <span class=\"comment\"># 收到消息的文字内容</span></span><br><span class=\"line\">    <span class=\"string\">'userid'</span> : msg.member.puid, <span class=\"comment\"># 使用群聊中发送者的 puid 作为 userid 传送给图灵接口， 如果是私聊可以使用 msg.sender.puid</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样做的好处是，图灵机器人可以根据得userid来获取上下文信息。例如你询问『天气』，它会回复『亲爱的，悄悄地告诉我你在哪个城市？』。在这种情况下，如果你不使用userid参数，你再次回复城市，图灵机器人也无法正确找到天气；如果你使用了这一参数，且两次回复使用的userid相同，图灵机器人会为你回复你回复的城市的天气情况，完成这一对话。</p>\n<h1 id=\"使用api-ai\"><a href=\"#使用api-ai\" class=\"headerlink\" title=\"使用api.ai\"></a>使用api.ai</h1><p>api.ai是一家被谷歌收购的人机交互系统，主要着重于对话机器人的开发。图灵机器人虽然包括一个知识库，但其语义识别的能力较差。我所需要的机器人主要用于新生群，很多问题人与人之间会有相当多不同的表达，图灵机器人无法满足我对于群聊机器人的要求。因此，我尝试使用api.ai进行回复有针对性的一些问题。</p>\n<p>如果你的英语相对糟糕，我不建议使用api.ai。api.ai的配置大多需要使用英语，虽然接口简单，但是后台设置相对复杂，如果没有英文背景不推荐使用。</p>\n<p>这一部分内容相对进阶，如果没有特殊需要，完全可以跳过不看。这里只作一个对api.ai使用方式上大体的介绍，希望能帮助大家了解这一网站。</p>\n<h2 id=\"前期准备-1\"><a href=\"#前期准备-1\" class=\"headerlink\" title=\"前期准备\"></a>前期准备</h2><ol>\n<li><p>前往<a href=\"https://api.ai/\" target=\"_blank\" rel=\"noopener\">api.ai</a>注册，创建机器人，并获得APIkey。虽然被谷歌收购，但是这个网站是不需要翻墙的哦！</p>\n</li>\n<li><p>安装api.ai官方提供的Python SDK</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip install apiai</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在文件头部加入（处理返回的消息时使用）</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> json</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"调用接口-1\"><a href=\"#调用接口-1\" class=\"headerlink\" title=\"调用接口\"></a>调用接口</h2><p>首先，我们需要设置api.ai的Token，</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">APIAI_TOKEN = <span class=\"string\">'Your API Key'</span></span><br></pre></td></tr></table></figure>\n<p>而后我们发起一个最简单的请求，一下内容都可以通过<a href=\"https://github.com/api-ai/apiai-python-client/tree/master/examples\" target=\"_blank\" rel=\"noopener\">例子</a>找到：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ai = apiai.ApiAI(APIAI_TOKEN)</span><br><span class=\"line\">request = ai.text_request()</span><br><span class=\"line\">request.lang = <span class=\"string\">'zh-CN'</span> <span class=\"comment\"># 使用中文</span></span><br><span class=\"line\">request.session_id = msg.member.puid <span class=\"comment\"># api.ai 中用 session id 来区分对话对象，必须</span></span><br><span class=\"line\">request.query = msg.text <span class=\"comment\"># 消息文字内容</span></span><br></pre></td></tr></table></figure>\n<p>然后通过接口得到传回的json：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">response = request.getresponse()</span><br><span class=\"line\">s = json.loads(response.read(), encoding=<span class=\"string\">'UTF-8'</span>) <span class=\"comment\"># 讲传回的json转换为python字典</span></span><br><span class=\"line\"><span class=\"keyword\">print</span> s</span><br><span class=\"line\"><span class=\"comment\"># &#123;u'lang': u'zh-cn', u'status': &#123;u'errorType': u'success', u'code': 200&#125;, u'timestamp': u'20&#125;</span></span><br></pre></td></tr></table></figure>\n<p>我们发现，api.ai传回的json相对于图灵机器人更加复杂。参考<a href=\"https://docs.api.ai/docs/query\" target=\"_blank\" rel=\"noopener\">api.ai的query文档</a>，我对对这部分回复进行了如下处理：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> s[<span class=\"string\">'result'</span>][<span class=\"string\">'action'</span>] == <span class=\"string\">'input.unknown'</span>: <span class=\"comment\"># </span></span><br><span class=\"line\">    <span class=\"keyword\">raise</span> Exception(<span class=\"string\">'api.ai cannot reply this message'</span>) <span class=\"comment\"># 抛出异常：使用 try 语句捕捉后使用图灵机器人回复</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> s[<span class=\"string\">'status'</span>][<span class=\"string\">'code'</span>] == <span class=\"number\">200</span>:</span><br><span class=\"line\">    msg.reply(s[<span class=\"string\">'result'</span>][<span class=\"string\">'fulfillment'</span>][<span class=\"string\">'speech'</span>]) <span class=\"comment\"># 回复 api.ai 返回的内容</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"api-ai的设置和调试\"><a href=\"#api-ai的设置和调试\" class=\"headerlink\" title=\"api.ai的设置和调试\"></a>api.ai的设置和调试</h2><p>在进入api.ai的机器人后，你将会看到左边的多个菜单。</p>\n<p>如果你只是简单的需要特定语句回复的功能，只需要创建并设置<a href=\"https://docs.api.ai/docs/concept-intents\" target=\"_blank\" rel=\"noopener\">Intents</a>就可以实现。在User Says一栏中填写消息可能是什么，在下方Response处填写可能回复的内容，然后保存即可。</p>\n<p>api.ai自带机器学习功能，它的参数可以在机器人设置中的ML settings里找到。可以通过调整参数和方式让你的机器人回复更加准确。</p>\n<p>在进入机器人后，api.ai的右侧会出现一个对话框。你可以使用它进行一些基础调试。在上方输入你的消息后，下方会给出机器人的回复，你可以通过这个对话框来了解是否正确设置了机器人。（需要翻墙）</p>\n<h1 id=\"你可能会遇到的一些问题\"><a href=\"#你可能会遇到的一些问题\" class=\"headerlink\" title=\"你可能会遇到的一些问题\"></a>你可能会遇到的一些问题</h1><h2 id=\"报错：No-handlers-could-be-found-for-logger-“wxpy-api-bot”\"><a href=\"#报错：No-handlers-could-be-found-for-logger-“wxpy-api-bot”\" class=\"headerlink\" title=\"报错：No handlers could be found for logger “wxpy.api.bot”\"></a>报错：No handlers could be found for logger “wxpy.api.bot”</h2><p>有报错但是无法显示，可以选择在代码头部加入：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> logging</span><br><span class=\"line\">logging.basicConfig()</span><br></pre></td></tr></table></figure>\n<h2 id=\"消息处理：删除-内容\"><a href=\"#消息处理：删除-内容\" class=\"headerlink\" title=\"消息处理：删除@内容\"></a>消息处理：删除@内容</h2><p>如果不删除消息中@部分的内容，图灵机器人的回复可能会受到昵称内容的影响，导致回复不准确，或是识别不出一些应当识别出的内容。我们可以用一段简单的代码删除@到空格之间的内容并去除首尾多余的空格。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">msg_content = re.sub(<span class=\"string\">'@[^\\s]*'</span>, <span class=\"string\">''</span>, unicodedata.normalize(<span class=\"string\">'NFKC'</span>, msg.text)).strip()</span><br></pre></td></tr></table></figure>\n<p>这里使用了正则表达式，匹配@以及它之后所有不为空的字符。如果你的微信昵称中没有空白字符，这条代码是可行的。（需要在代码开头添加<code>import re</code>）</p>"},{"title":"从零开始微信机器人（三）：表情机器人的制作","date":"2017-06-24T16:00:00.000Z","_content":"\n\n\n本篇的诞生来自于一朋友制作的表情机器人。当时觉得十分有趣，也希望加入到群聊机器人中，因此就向他讨要了[源代码](https://github.com/qwIvan/microMsg-bot)并制作了表情功能。在此我也再次感谢[吴毅凡](https://github.com/qwIvan)同学的协助！\n\n\n\n## 准备工作\n\n由于需要读取网页内容，本文中由于我个人偏好使用xpath来选择网页中元素，使用了[lxml](http://lxml.de/)包，安装的话需要：\n\n```shell\npip install lxml\n```\n\n如果你想要使用[BeautifulSoup](https://www.crummy.com/software/BeautifulSoup/bs4/doc/)来处理网页，请安装：\n\n```shell\npip install beautifulsoup4\n```\n\n<!--more-->\n\n## 使用斗图啦搜索表情\n\n由于[斗图啦](https://www.doutula.com/)是明文传输数据搜索的，我们可以简单地通过\n\n```python\nres = requests.get('https://www.doutula.com/search', {'keyword': keyword})\n```\n\n来获取关键词keyword的搜索结果页面。\n\n本例中我使用xpath来选择元素，其具体教程你可以查看[这里](http://www.w3school.com.cn/xpath/index.asp)。如果你想使用`BeautifulSoup`，可以查看[这里](https://github.com/qwIvan/microMsg-bot/blob/master/meme.py#L7)。\n\n```python\nhtml = etree.HTML(res.text)\nurl = 'http:' + random.choice(html.xpath('//div[@class=\"image-container\"][1]//img[contains(@class, \"img-responsive\")]/@data-original'))\n```\n\n其中`//div[@class=\"image-container\"][1]`选择了页面中的第一个`image-container`元素，如果你观察斗图啦搜索界面，你会发现它分为上下两部分：上面是表情的搜索结果，下半部分则是文章的搜索结果，这样我们就仅挑选了上半部分的表情搜索结果。而`//img[contains(@class, \"img-responsive\")]/@data-original'`部分则选择了所有`class`里包含`img-responsive`的`img`元素，也就是我们要的图片本身，仔细观察元素本身你会发现图片链接就在其中的`data-original`属性下（但是需要加上http协议）。\n\nChrome的审查元素功能可以帮助你快速判断自己编写的xpath能否准确选出你想要的元素，也能够查看元素本身。\n\n\n\n## 储存图片\n\n因为wxpy自动将gif文件判断作为表情发送，我们可以利用这一点把表情作为表情（而非图片）发送到聊天中。\n\n首先我们使用了临时文件：\n\n```python\nfrom tempfile import NamedTemporaryFile\n```\n\n通过request获取图片信息，然后写入到一个临时文件中。\n\n```python\nres = requests.get(url, allow_redirects=False)\ntmp = NamedTemporaryFile()\ntmp.write(res.content)\ntmp.flush()\n```\n\n\n\n## 上传图片并作为表情发送\n\nwxpy提供了上传文件的通道，而上传后的文件就可以免去重新上传直接发送。\n\n```python\nmedia_id = bot.upload_file(tmp.name)\ntmp.close()\nmsg.reply_image('.gif', media_id=media_id)\n```\n\n在这里，用我们前文提到的方法，使用`.gif`来进行表情的发送。\n\n如果你想直接发送图片，可以简单地讲`.gif`参数去除：\n\n```python\nmsg.reply_image('', media_id=media_id)\n```\n\nwxpy的作者表示将在之后的版本中更新图片发送的接口以将图片发送和表情发送分开，我相信这一设计会是更加优秀的。","source":"_posts/connector-wechat-bot-3.md","raw":"---\ntitle: 从零开始微信机器人（三）：表情机器人的制作\ndate: 2017-06-25\ncategory: 计算机课堂\ntags: \n- Python\n- 聊天机器人\n---\n\n\n\n本篇的诞生来自于一朋友制作的表情机器人。当时觉得十分有趣，也希望加入到群聊机器人中，因此就向他讨要了[源代码](https://github.com/qwIvan/microMsg-bot)并制作了表情功能。在此我也再次感谢[吴毅凡](https://github.com/qwIvan)同学的协助！\n\n\n\n## 准备工作\n\n由于需要读取网页内容，本文中由于我个人偏好使用xpath来选择网页中元素，使用了[lxml](http://lxml.de/)包，安装的话需要：\n\n```shell\npip install lxml\n```\n\n如果你想要使用[BeautifulSoup](https://www.crummy.com/software/BeautifulSoup/bs4/doc/)来处理网页，请安装：\n\n```shell\npip install beautifulsoup4\n```\n\n<!--more-->\n\n## 使用斗图啦搜索表情\n\n由于[斗图啦](https://www.doutula.com/)是明文传输数据搜索的，我们可以简单地通过\n\n```python\nres = requests.get('https://www.doutula.com/search', {'keyword': keyword})\n```\n\n来获取关键词keyword的搜索结果页面。\n\n本例中我使用xpath来选择元素，其具体教程你可以查看[这里](http://www.w3school.com.cn/xpath/index.asp)。如果你想使用`BeautifulSoup`，可以查看[这里](https://github.com/qwIvan/microMsg-bot/blob/master/meme.py#L7)。\n\n```python\nhtml = etree.HTML(res.text)\nurl = 'http:' + random.choice(html.xpath('//div[@class=\"image-container\"][1]//img[contains(@class, \"img-responsive\")]/@data-original'))\n```\n\n其中`//div[@class=\"image-container\"][1]`选择了页面中的第一个`image-container`元素，如果你观察斗图啦搜索界面，你会发现它分为上下两部分：上面是表情的搜索结果，下半部分则是文章的搜索结果，这样我们就仅挑选了上半部分的表情搜索结果。而`//img[contains(@class, \"img-responsive\")]/@data-original'`部分则选择了所有`class`里包含`img-responsive`的`img`元素，也就是我们要的图片本身，仔细观察元素本身你会发现图片链接就在其中的`data-original`属性下（但是需要加上http协议）。\n\nChrome的审查元素功能可以帮助你快速判断自己编写的xpath能否准确选出你想要的元素，也能够查看元素本身。\n\n\n\n## 储存图片\n\n因为wxpy自动将gif文件判断作为表情发送，我们可以利用这一点把表情作为表情（而非图片）发送到聊天中。\n\n首先我们使用了临时文件：\n\n```python\nfrom tempfile import NamedTemporaryFile\n```\n\n通过request获取图片信息，然后写入到一个临时文件中。\n\n```python\nres = requests.get(url, allow_redirects=False)\ntmp = NamedTemporaryFile()\ntmp.write(res.content)\ntmp.flush()\n```\n\n\n\n## 上传图片并作为表情发送\n\nwxpy提供了上传文件的通道，而上传后的文件就可以免去重新上传直接发送。\n\n```python\nmedia_id = bot.upload_file(tmp.name)\ntmp.close()\nmsg.reply_image('.gif', media_id=media_id)\n```\n\n在这里，用我们前文提到的方法，使用`.gif`来进行表情的发送。\n\n如果你想直接发送图片，可以简单地讲`.gif`参数去除：\n\n```python\nmsg.reply_image('', media_id=media_id)\n```\n\nwxpy的作者表示将在之后的版本中更新图片发送的接口以将图片发送和表情发送分开，我相信这一设计会是更加优秀的。","slug":"connector-wechat-bot-3","published":1,"updated":"2018-07-03T13:44:30.393Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj5repua00059pd39956zrtd","content":"<p>本篇的诞生来自于一朋友制作的表情机器人。当时觉得十分有趣，也希望加入到群聊机器人中，因此就向他讨要了<a href=\"https://github.com/qwIvan/microMsg-bot\" target=\"_blank\" rel=\"noopener\">源代码</a>并制作了表情功能。在此我也再次感谢<a href=\"https://github.com/qwIvan\" target=\"_blank\" rel=\"noopener\">吴毅凡</a>同学的协助！</p>\n<h2 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h2><p>由于需要读取网页内容，本文中由于我个人偏好使用xpath来选择网页中元素，使用了<a href=\"http://lxml.de/\" target=\"_blank\" rel=\"noopener\">lxml</a>包，安装的话需要：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip install lxml</span><br></pre></td></tr></table></figure>\n<p>如果你想要使用<a href=\"https://www.crummy.com/software/BeautifulSoup/bs4/doc/\" target=\"_blank\" rel=\"noopener\">BeautifulSoup</a>来处理网页，请安装：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip install beautifulsoup4</span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<h2 id=\"使用斗图啦搜索表情\"><a href=\"#使用斗图啦搜索表情\" class=\"headerlink\" title=\"使用斗图啦搜索表情\"></a>使用斗图啦搜索表情</h2><p>由于<a href=\"https://www.doutula.com/\" target=\"_blank\" rel=\"noopener\">斗图啦</a>是明文传输数据搜索的，我们可以简单地通过</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">res = requests.get(<span class=\"string\">'https://www.doutula.com/search'</span>, &#123;<span class=\"string\">'keyword'</span>: keyword&#125;)</span><br></pre></td></tr></table></figure>\n<p>来获取关键词keyword的搜索结果页面。</p>\n<p>本例中我使用xpath来选择元素，其具体教程你可以查看<a href=\"http://www.w3school.com.cn/xpath/index.asp\" target=\"_blank\" rel=\"noopener\">这里</a>。如果你想使用<code>BeautifulSoup</code>，可以查看<a href=\"https://github.com/qwIvan/microMsg-bot/blob/master/meme.py#L7\" target=\"_blank\" rel=\"noopener\">这里</a>。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">html = etree.HTML(res.text)</span><br><span class=\"line\">url = <span class=\"string\">'http:'</span> + random.choice(html.xpath(<span class=\"string\">'//div[@class=\"image-container\"][1]//img[contains(@class, \"img-responsive\")]/@data-original'</span>))</span><br></pre></td></tr></table></figure>\n<p>其中<code>//div[@class=&quot;image-container&quot;][1]</code>选择了页面中的第一个<code>image-container</code>元素，如果你观察斗图啦搜索界面，你会发现它分为上下两部分：上面是表情的搜索结果，下半部分则是文章的搜索结果，这样我们就仅挑选了上半部分的表情搜索结果。而<code>//img[contains(@class, &quot;img-responsive&quot;)]/@data-original&#39;</code>部分则选择了所有<code>class</code>里包含<code>img-responsive</code>的<code>img</code>元素，也就是我们要的图片本身，仔细观察元素本身你会发现图片链接就在其中的<code>data-original</code>属性下（但是需要加上http协议）。</p>\n<p>Chrome的审查元素功能可以帮助你快速判断自己编写的xpath能否准确选出你想要的元素，也能够查看元素本身。</p>\n<h2 id=\"储存图片\"><a href=\"#储存图片\" class=\"headerlink\" title=\"储存图片\"></a>储存图片</h2><p>因为wxpy自动将gif文件判断作为表情发送，我们可以利用这一点把表情作为表情（而非图片）发送到聊天中。</p>\n<p>首先我们使用了临时文件：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> tempfile <span class=\"keyword\">import</span> NamedTemporaryFile</span><br></pre></td></tr></table></figure>\n<p>通过request获取图片信息，然后写入到一个临时文件中。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">res = requests.get(url, allow_redirects=<span class=\"keyword\">False</span>)</span><br><span class=\"line\">tmp = NamedTemporaryFile()</span><br><span class=\"line\">tmp.write(res.content)</span><br><span class=\"line\">tmp.flush()</span><br></pre></td></tr></table></figure>\n<h2 id=\"上传图片并作为表情发送\"><a href=\"#上传图片并作为表情发送\" class=\"headerlink\" title=\"上传图片并作为表情发送\"></a>上传图片并作为表情发送</h2><p>wxpy提供了上传文件的通道，而上传后的文件就可以免去重新上传直接发送。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">media_id = bot.upload_file(tmp.name)</span><br><span class=\"line\">tmp.close()</span><br><span class=\"line\">msg.reply_image(<span class=\"string\">'.gif'</span>, media_id=media_id)</span><br></pre></td></tr></table></figure>\n<p>在这里，用我们前文提到的方法，使用<code>.gif</code>来进行表情的发送。</p>\n<p>如果你想直接发送图片，可以简单地讲<code>.gif</code>参数去除：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">msg.reply_image(<span class=\"string\">''</span>, media_id=media_id)</span><br></pre></td></tr></table></figure>\n<p>wxpy的作者表示将在之后的版本中更新图片发送的接口以将图片发送和表情发送分开，我相信这一设计会是更加优秀的。</p>\n","site":{"data":{}},"excerpt":"<p>本篇的诞生来自于一朋友制作的表情机器人。当时觉得十分有趣，也希望加入到群聊机器人中，因此就向他讨要了<a href=\"https://github.com/qwIvan/microMsg-bot\" target=\"_blank\" rel=\"noopener\">源代码</a>并制作了表情功能。在此我也再次感谢<a href=\"https://github.com/qwIvan\" target=\"_blank\" rel=\"noopener\">吴毅凡</a>同学的协助！</p>\n<h2 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h2><p>由于需要读取网页内容，本文中由于我个人偏好使用xpath来选择网页中元素，使用了<a href=\"http://lxml.de/\" target=\"_blank\" rel=\"noopener\">lxml</a>包，安装的话需要：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip install lxml</span><br></pre></td></tr></table></figure>\n<p>如果你想要使用<a href=\"https://www.crummy.com/software/BeautifulSoup/bs4/doc/\" target=\"_blank\" rel=\"noopener\">BeautifulSoup</a>来处理网页，请安装：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip install beautifulsoup4</span><br></pre></td></tr></table></figure>","more":"<h2 id=\"使用斗图啦搜索表情\"><a href=\"#使用斗图啦搜索表情\" class=\"headerlink\" title=\"使用斗图啦搜索表情\"></a>使用斗图啦搜索表情</h2><p>由于<a href=\"https://www.doutula.com/\" target=\"_blank\" rel=\"noopener\">斗图啦</a>是明文传输数据搜索的，我们可以简单地通过</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">res = requests.get(<span class=\"string\">'https://www.doutula.com/search'</span>, &#123;<span class=\"string\">'keyword'</span>: keyword&#125;)</span><br></pre></td></tr></table></figure>\n<p>来获取关键词keyword的搜索结果页面。</p>\n<p>本例中我使用xpath来选择元素，其具体教程你可以查看<a href=\"http://www.w3school.com.cn/xpath/index.asp\" target=\"_blank\" rel=\"noopener\">这里</a>。如果你想使用<code>BeautifulSoup</code>，可以查看<a href=\"https://github.com/qwIvan/microMsg-bot/blob/master/meme.py#L7\" target=\"_blank\" rel=\"noopener\">这里</a>。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">html = etree.HTML(res.text)</span><br><span class=\"line\">url = <span class=\"string\">'http:'</span> + random.choice(html.xpath(<span class=\"string\">'//div[@class=\"image-container\"][1]//img[contains(@class, \"img-responsive\")]/@data-original'</span>))</span><br></pre></td></tr></table></figure>\n<p>其中<code>//div[@class=&quot;image-container&quot;][1]</code>选择了页面中的第一个<code>image-container</code>元素，如果你观察斗图啦搜索界面，你会发现它分为上下两部分：上面是表情的搜索结果，下半部分则是文章的搜索结果，这样我们就仅挑选了上半部分的表情搜索结果。而<code>//img[contains(@class, &quot;img-responsive&quot;)]/@data-original&#39;</code>部分则选择了所有<code>class</code>里包含<code>img-responsive</code>的<code>img</code>元素，也就是我们要的图片本身，仔细观察元素本身你会发现图片链接就在其中的<code>data-original</code>属性下（但是需要加上http协议）。</p>\n<p>Chrome的审查元素功能可以帮助你快速判断自己编写的xpath能否准确选出你想要的元素，也能够查看元素本身。</p>\n<h2 id=\"储存图片\"><a href=\"#储存图片\" class=\"headerlink\" title=\"储存图片\"></a>储存图片</h2><p>因为wxpy自动将gif文件判断作为表情发送，我们可以利用这一点把表情作为表情（而非图片）发送到聊天中。</p>\n<p>首先我们使用了临时文件：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> tempfile <span class=\"keyword\">import</span> NamedTemporaryFile</span><br></pre></td></tr></table></figure>\n<p>通过request获取图片信息，然后写入到一个临时文件中。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">res = requests.get(url, allow_redirects=<span class=\"keyword\">False</span>)</span><br><span class=\"line\">tmp = NamedTemporaryFile()</span><br><span class=\"line\">tmp.write(res.content)</span><br><span class=\"line\">tmp.flush()</span><br></pre></td></tr></table></figure>\n<h2 id=\"上传图片并作为表情发送\"><a href=\"#上传图片并作为表情发送\" class=\"headerlink\" title=\"上传图片并作为表情发送\"></a>上传图片并作为表情发送</h2><p>wxpy提供了上传文件的通道，而上传后的文件就可以免去重新上传直接发送。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">media_id = bot.upload_file(tmp.name)</span><br><span class=\"line\">tmp.close()</span><br><span class=\"line\">msg.reply_image(<span class=\"string\">'.gif'</span>, media_id=media_id)</span><br></pre></td></tr></table></figure>\n<p>在这里，用我们前文提到的方法，使用<code>.gif</code>来进行表情的发送。</p>\n<p>如果你想直接发送图片，可以简单地讲<code>.gif</code>参数去除：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">msg.reply_image(<span class=\"string\">''</span>, media_id=media_id)</span><br></pre></td></tr></table></figure>\n<p>wxpy的作者表示将在之后的版本中更新图片发送的接口以将图片发送和表情发送分开，我相信这一设计会是更加优秀的。</p>"},{"title":"从零开始微信机器人（四）：监控机器人程序","date":"2017-06-25T16:00:00.000Z","_content":"\n\n\n由于使用网页版微信，机器人往往不能够永远地在线。如果无法一直在线，也就失去了自动回复程序的意义。在此，我们使用两种方式来监控机器人程序：\n\n1. 自动定时发送消息\n2. 使用supervisor进行监控\n\n\n\n# 自动发送消息\n\n## 准备\n\n如果需要定时发送消息，使用`sleep`方式来等待计时会阻塞线程，因此我们会使用`threading`来进行多线程的操作。把一个线程分配给自动给特定人发送微信消息。\n\n## 定义自动发送消息的方法\n\n在进行多线程操作之前，我们先定义一个自动发送消息的方法以备调用：\n\n```python\ndef send_online_notification(name):\n    my_friend = ensure_one(bot.search(name))\n    while True:\n        my_friend.send('Hello!') # 你想发送的消息\n        time.sleep(3600) # 一小时后在进行发送\n```\n\nwxpy的`ensure_one()`方法会确认返回的内容仅有一个值，如果返回的列表超过一个值（或是没有返回），它会进行报错。我们在这里寻找`name`相关的好友，并且保证只有一个这样的好友。如果你需要给多个好友发送消息，我建议再使用一个循环来遍历好友列表。\n\n<!--more-->\n\n我们写一个阻塞线程的死循环，在死循环中给需要寻找发送特定消息，并让线程停止一小时，由此来打成定时发送消息的方法。\n\n## 增加线程\n\n另一边，我们需要利用多线程调用这个方法。\n\n```python\npositiveSendingThread = threading.Thread(target=send_online_notification, args=(u'乙醚。',)) # 请在这里输入你想要寻找的好友昵称或备注\npositiveSendingThread.setDaemon(True)\npositiveSendingThread.start()\n```\n\n这样就成功启用了一个线程来进行自动发送消息了。\n\n\n\n# 利用Supervisor监控\n\n## 安装\n\nsupervisor是一个python写成的程序，因此可以简单地通过`pip`来进行安装：\n\n```shell\npip install supervisor\n```\n\n\n\n## 调整 wxpy设置\n\n如果想使用supervisor的重启功能，我们必须开启wxpy的缓存功能以储存登录状态，具体操作在登录时增加`cache_path`参数：\n\n```python\nbot = Bot(cache_path=True)\n```\n\n你也可以自由选择将缓存存在什么文件中，以免多个机器人冲突\n\n\n\n## 配置\n\n官方提供了一个默认的配置文件，你可以使用这条命令输出到你放置机器人的文件夹中：\n\n```shell\necho_supervisord_conf > supervisord.conf\n```\n\n在这个`supervisord.conf`后面，我们再追加对微信机器人程序的控制\n\n```shell\n[program:bot]  \ncommand=python ./wxbot.py              ;执行机器人文件，请修改文件名 \nprocess_name=%(program_name)s  \nautostart=true                   ; 程序是否随supervisor启动而启动  \nautorestart=true                 ;程序停止时，是否自动重启  \nstartsecs=10  \n```\n\n\n\n## 启动和控制\n\n从命令启动supervisor只需要一句：\n\n```\nsupervisord -c supervisord.conf\n```\n\n`-c`用以指定配置文件，也就是我们刚刚编写的文件。\n\n使用supervisor还可以方便的开始、重启和停止程序：\n\n```shell\nsupervisorctl start bot # 开始程序，bot 是刚刚填写的程序名\nsupervisorctl restart bot # 重启程序\nsupervisorctl stop bot # 停止程序\n```\n\n使用supervisor查看自己的程序运行状态\n\n```shell\nsupervisorctl status # 查看状态\n```\n\n因此，只要将wxpy的缓存打开，并且使用supervisor进行自动重启，我们就可以获得一个长时间保持登录的自动回复机器人啦！\n\n","source":"_posts/connector-wechat-bot-4.md","raw":"---\ntitle: 从零开始微信机器人（四）：监控机器人程序\ndate: 2017-06-26\ncategory: 计算机课堂\ntags: \n- Python\n- 聊天机器人\n---\n\n\n\n由于使用网页版微信，机器人往往不能够永远地在线。如果无法一直在线，也就失去了自动回复程序的意义。在此，我们使用两种方式来监控机器人程序：\n\n1. 自动定时发送消息\n2. 使用supervisor进行监控\n\n\n\n# 自动发送消息\n\n## 准备\n\n如果需要定时发送消息，使用`sleep`方式来等待计时会阻塞线程，因此我们会使用`threading`来进行多线程的操作。把一个线程分配给自动给特定人发送微信消息。\n\n## 定义自动发送消息的方法\n\n在进行多线程操作之前，我们先定义一个自动发送消息的方法以备调用：\n\n```python\ndef send_online_notification(name):\n    my_friend = ensure_one(bot.search(name))\n    while True:\n        my_friend.send('Hello!') # 你想发送的消息\n        time.sleep(3600) # 一小时后在进行发送\n```\n\nwxpy的`ensure_one()`方法会确认返回的内容仅有一个值，如果返回的列表超过一个值（或是没有返回），它会进行报错。我们在这里寻找`name`相关的好友，并且保证只有一个这样的好友。如果你需要给多个好友发送消息，我建议再使用一个循环来遍历好友列表。\n\n<!--more-->\n\n我们写一个阻塞线程的死循环，在死循环中给需要寻找发送特定消息，并让线程停止一小时，由此来打成定时发送消息的方法。\n\n## 增加线程\n\n另一边，我们需要利用多线程调用这个方法。\n\n```python\npositiveSendingThread = threading.Thread(target=send_online_notification, args=(u'乙醚。',)) # 请在这里输入你想要寻找的好友昵称或备注\npositiveSendingThread.setDaemon(True)\npositiveSendingThread.start()\n```\n\n这样就成功启用了一个线程来进行自动发送消息了。\n\n\n\n# 利用Supervisor监控\n\n## 安装\n\nsupervisor是一个python写成的程序，因此可以简单地通过`pip`来进行安装：\n\n```shell\npip install supervisor\n```\n\n\n\n## 调整 wxpy设置\n\n如果想使用supervisor的重启功能，我们必须开启wxpy的缓存功能以储存登录状态，具体操作在登录时增加`cache_path`参数：\n\n```python\nbot = Bot(cache_path=True)\n```\n\n你也可以自由选择将缓存存在什么文件中，以免多个机器人冲突\n\n\n\n## 配置\n\n官方提供了一个默认的配置文件，你可以使用这条命令输出到你放置机器人的文件夹中：\n\n```shell\necho_supervisord_conf > supervisord.conf\n```\n\n在这个`supervisord.conf`后面，我们再追加对微信机器人程序的控制\n\n```shell\n[program:bot]  \ncommand=python ./wxbot.py              ;执行机器人文件，请修改文件名 \nprocess_name=%(program_name)s  \nautostart=true                   ; 程序是否随supervisor启动而启动  \nautorestart=true                 ;程序停止时，是否自动重启  \nstartsecs=10  \n```\n\n\n\n## 启动和控制\n\n从命令启动supervisor只需要一句：\n\n```\nsupervisord -c supervisord.conf\n```\n\n`-c`用以指定配置文件，也就是我们刚刚编写的文件。\n\n使用supervisor还可以方便的开始、重启和停止程序：\n\n```shell\nsupervisorctl start bot # 开始程序，bot 是刚刚填写的程序名\nsupervisorctl restart bot # 重启程序\nsupervisorctl stop bot # 停止程序\n```\n\n使用supervisor查看自己的程序运行状态\n\n```shell\nsupervisorctl status # 查看状态\n```\n\n因此，只要将wxpy的缓存打开，并且使用supervisor进行自动重启，我们就可以获得一个长时间保持登录的自动回复机器人啦！\n\n","slug":"connector-wechat-bot-4","published":1,"updated":"2018-07-03T13:44:30.393Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj5repub00069pd3b3kq67j4","content":"<p>由于使用网页版微信，机器人往往不能够永远地在线。如果无法一直在线，也就失去了自动回复程序的意义。在此，我们使用两种方式来监控机器人程序：</p>\n<ol>\n<li>自动定时发送消息</li>\n<li>使用supervisor进行监控</li>\n</ol>\n<h1 id=\"自动发送消息\"><a href=\"#自动发送消息\" class=\"headerlink\" title=\"自动发送消息\"></a>自动发送消息</h1><h2 id=\"准备\"><a href=\"#准备\" class=\"headerlink\" title=\"准备\"></a>准备</h2><p>如果需要定时发送消息，使用<code>sleep</code>方式来等待计时会阻塞线程，因此我们会使用<code>threading</code>来进行多线程的操作。把一个线程分配给自动给特定人发送微信消息。</p>\n<h2 id=\"定义自动发送消息的方法\"><a href=\"#定义自动发送消息的方法\" class=\"headerlink\" title=\"定义自动发送消息的方法\"></a>定义自动发送消息的方法</h2><p>在进行多线程操作之前，我们先定义一个自动发送消息的方法以备调用：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">send_online_notification</span><span class=\"params\">(name)</span>:</span></span><br><span class=\"line\">    my_friend = ensure_one(bot.search(name))</span><br><span class=\"line\">    <span class=\"keyword\">while</span> <span class=\"keyword\">True</span>:</span><br><span class=\"line\">        my_friend.send(<span class=\"string\">'Hello!'</span>) <span class=\"comment\"># 你想发送的消息</span></span><br><span class=\"line\">        time.sleep(<span class=\"number\">3600</span>) <span class=\"comment\"># 一小时后在进行发送</span></span><br></pre></td></tr></table></figure>\n<p>wxpy的<code>ensure_one()</code>方法会确认返回的内容仅有一个值，如果返回的列表超过一个值（或是没有返回），它会进行报错。我们在这里寻找<code>name</code>相关的好友，并且保证只有一个这样的好友。如果你需要给多个好友发送消息，我建议再使用一个循环来遍历好友列表。</p>\n<a id=\"more\"></a>\n<p>我们写一个阻塞线程的死循环，在死循环中给需要寻找发送特定消息，并让线程停止一小时，由此来打成定时发送消息的方法。</p>\n<h2 id=\"增加线程\"><a href=\"#增加线程\" class=\"headerlink\" title=\"增加线程\"></a>增加线程</h2><p>另一边，我们需要利用多线程调用这个方法。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">positiveSendingThread = threading.Thread(target=send_online_notification, args=(<span class=\"string\">u'乙醚。'</span>,)) <span class=\"comment\"># 请在这里输入你想要寻找的好友昵称或备注</span></span><br><span class=\"line\">positiveSendingThread.setDaemon(<span class=\"keyword\">True</span>)</span><br><span class=\"line\">positiveSendingThread.start()</span><br></pre></td></tr></table></figure>\n<p>这样就成功启用了一个线程来进行自动发送消息了。</p>\n<h1 id=\"利用Supervisor监控\"><a href=\"#利用Supervisor监控\" class=\"headerlink\" title=\"利用Supervisor监控\"></a>利用Supervisor监控</h1><h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p>supervisor是一个python写成的程序，因此可以简单地通过<code>pip</code>来进行安装：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip install supervisor</span><br></pre></td></tr></table></figure>\n<h2 id=\"调整-wxpy设置\"><a href=\"#调整-wxpy设置\" class=\"headerlink\" title=\"调整 wxpy设置\"></a>调整 wxpy设置</h2><p>如果想使用supervisor的重启功能，我们必须开启wxpy的缓存功能以储存登录状态，具体操作在登录时增加<code>cache_path</code>参数：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bot = Bot(cache_path=<span class=\"keyword\">True</span>)</span><br></pre></td></tr></table></figure>\n<p>你也可以自由选择将缓存存在什么文件中，以免多个机器人冲突</p>\n<h2 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h2><p>官方提供了一个默认的配置文件，你可以使用这条命令输出到你放置机器人的文件夹中：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">echo_supervisord_conf &gt; supervisord.conf</span><br></pre></td></tr></table></figure>\n<p>在这个<code>supervisord.conf</code>后面，我们再追加对微信机器人程序的控制</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[program:bot]  </span><br><span class=\"line\">command=python ./wxbot.py              ;执行机器人文件，请修改文件名 </span><br><span class=\"line\">process_name=%(program_name)s  </span><br><span class=\"line\">autostart=true                   ; 程序是否随supervisor启动而启动  </span><br><span class=\"line\">autorestart=true                 ;程序停止时，是否自动重启  </span><br><span class=\"line\">startsecs=10</span><br></pre></td></tr></table></figure>\n<h2 id=\"启动和控制\"><a href=\"#启动和控制\" class=\"headerlink\" title=\"启动和控制\"></a>启动和控制</h2><p>从命令启动supervisor只需要一句：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">supervisord -c supervisord.conf</span><br></pre></td></tr></table></figure>\n<p><code>-c</code>用以指定配置文件，也就是我们刚刚编写的文件。</p>\n<p>使用supervisor还可以方便的开始、重启和停止程序：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">supervisorctl start bot # 开始程序，bot 是刚刚填写的程序名</span><br><span class=\"line\">supervisorctl restart bot # 重启程序</span><br><span class=\"line\">supervisorctl stop bot # 停止程序</span><br></pre></td></tr></table></figure>\n<p>使用supervisor查看自己的程序运行状态</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">supervisorctl status # 查看状态</span><br></pre></td></tr></table></figure>\n<p>因此，只要将wxpy的缓存打开，并且使用supervisor进行自动重启，我们就可以获得一个长时间保持登录的自动回复机器人啦！</p>\n","site":{"data":{}},"excerpt":"<p>由于使用网页版微信，机器人往往不能够永远地在线。如果无法一直在线，也就失去了自动回复程序的意义。在此，我们使用两种方式来监控机器人程序：</p>\n<ol>\n<li>自动定时发送消息</li>\n<li>使用supervisor进行监控</li>\n</ol>\n<h1 id=\"自动发送消息\"><a href=\"#自动发送消息\" class=\"headerlink\" title=\"自动发送消息\"></a>自动发送消息</h1><h2 id=\"准备\"><a href=\"#准备\" class=\"headerlink\" title=\"准备\"></a>准备</h2><p>如果需要定时发送消息，使用<code>sleep</code>方式来等待计时会阻塞线程，因此我们会使用<code>threading</code>来进行多线程的操作。把一个线程分配给自动给特定人发送微信消息。</p>\n<h2 id=\"定义自动发送消息的方法\"><a href=\"#定义自动发送消息的方法\" class=\"headerlink\" title=\"定义自动发送消息的方法\"></a>定义自动发送消息的方法</h2><p>在进行多线程操作之前，我们先定义一个自动发送消息的方法以备调用：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">send_online_notification</span><span class=\"params\">(name)</span>:</span></span><br><span class=\"line\">    my_friend = ensure_one(bot.search(name))</span><br><span class=\"line\">    <span class=\"keyword\">while</span> <span class=\"keyword\">True</span>:</span><br><span class=\"line\">        my_friend.send(<span class=\"string\">'Hello!'</span>) <span class=\"comment\"># 你想发送的消息</span></span><br><span class=\"line\">        time.sleep(<span class=\"number\">3600</span>) <span class=\"comment\"># 一小时后在进行发送</span></span><br></pre></td></tr></table></figure>\n<p>wxpy的<code>ensure_one()</code>方法会确认返回的内容仅有一个值，如果返回的列表超过一个值（或是没有返回），它会进行报错。我们在这里寻找<code>name</code>相关的好友，并且保证只有一个这样的好友。如果你需要给多个好友发送消息，我建议再使用一个循环来遍历好友列表。</p>","more":"<p>我们写一个阻塞线程的死循环，在死循环中给需要寻找发送特定消息，并让线程停止一小时，由此来打成定时发送消息的方法。</p>\n<h2 id=\"增加线程\"><a href=\"#增加线程\" class=\"headerlink\" title=\"增加线程\"></a>增加线程</h2><p>另一边，我们需要利用多线程调用这个方法。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">positiveSendingThread = threading.Thread(target=send_online_notification, args=(<span class=\"string\">u'乙醚。'</span>,)) <span class=\"comment\"># 请在这里输入你想要寻找的好友昵称或备注</span></span><br><span class=\"line\">positiveSendingThread.setDaemon(<span class=\"keyword\">True</span>)</span><br><span class=\"line\">positiveSendingThread.start()</span><br></pre></td></tr></table></figure>\n<p>这样就成功启用了一个线程来进行自动发送消息了。</p>\n<h1 id=\"利用Supervisor监控\"><a href=\"#利用Supervisor监控\" class=\"headerlink\" title=\"利用Supervisor监控\"></a>利用Supervisor监控</h1><h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p>supervisor是一个python写成的程序，因此可以简单地通过<code>pip</code>来进行安装：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip install supervisor</span><br></pre></td></tr></table></figure>\n<h2 id=\"调整-wxpy设置\"><a href=\"#调整-wxpy设置\" class=\"headerlink\" title=\"调整 wxpy设置\"></a>调整 wxpy设置</h2><p>如果想使用supervisor的重启功能，我们必须开启wxpy的缓存功能以储存登录状态，具体操作在登录时增加<code>cache_path</code>参数：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bot = Bot(cache_path=<span class=\"keyword\">True</span>)</span><br></pre></td></tr></table></figure>\n<p>你也可以自由选择将缓存存在什么文件中，以免多个机器人冲突</p>\n<h2 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h2><p>官方提供了一个默认的配置文件，你可以使用这条命令输出到你放置机器人的文件夹中：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">echo_supervisord_conf &gt; supervisord.conf</span><br></pre></td></tr></table></figure>\n<p>在这个<code>supervisord.conf</code>后面，我们再追加对微信机器人程序的控制</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[program:bot]  </span><br><span class=\"line\">command=python ./wxbot.py              ;执行机器人文件，请修改文件名 </span><br><span class=\"line\">process_name=%(program_name)s  </span><br><span class=\"line\">autostart=true                   ; 程序是否随supervisor启动而启动  </span><br><span class=\"line\">autorestart=true                 ;程序停止时，是否自动重启  </span><br><span class=\"line\">startsecs=10</span><br></pre></td></tr></table></figure>\n<h2 id=\"启动和控制\"><a href=\"#启动和控制\" class=\"headerlink\" title=\"启动和控制\"></a>启动和控制</h2><p>从命令启动supervisor只需要一句：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">supervisord -c supervisord.conf</span><br></pre></td></tr></table></figure>\n<p><code>-c</code>用以指定配置文件，也就是我们刚刚编写的文件。</p>\n<p>使用supervisor还可以方便的开始、重启和停止程序：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">supervisorctl start bot # 开始程序，bot 是刚刚填写的程序名</span><br><span class=\"line\">supervisorctl restart bot # 重启程序</span><br><span class=\"line\">supervisorctl stop bot # 停止程序</span><br></pre></td></tr></table></figure>\n<p>使用supervisor查看自己的程序运行状态</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">supervisorctl status # 查看状态</span><br></pre></td></tr></table></figure>\n<p>因此，只要将wxpy的缓存打开，并且使用supervisor进行自动重启，我们就可以获得一个长时间保持登录的自动回复机器人啦！</p>"},{"title":"TLDR pages：简易版的 man pages","date":"2017-09-18T16:00:00.000Z","_content":"\n\n\n# 什么是TLDR？\n\n## TLDR 它本身\n\ntl;dr 是一个网络词汇，和十动然拒这类差不多，是个缩写。它的全称是「Too Long; Don't Read」，翻译成中文的话就叫「太长不看」。它兴起于一些论坛，为了说明「楼主你的破文章又臭又长」，不过后来有许多文章的开头也用\n\n## 这个东西为啥叫太长不看？\n\n一个叫「太长不看」的命令行工具显然是解决一些令程序员一个脑袋两个大的太长的东西，而这个东西就是 **Linux man pages**。它到底有多长呢，man pages的官方压缩包是 2M 多的大小，解压后是 16M。 16M 确实不算大了，然而这 16M 可是纯文本啊。用来做类比的话，一本50万字的中文小说变成纯文本文件之后也就那么 1M 多，可想而知这甚至是全英文 man pages 有多长了。\n\n## 我们却需要它\n\n作为程序员有时又十分需要 man pages。 虽然它长，你又不得不去读它：比如说，你知道 ssh 的基本用法是\n\n```shell\nssh username@remote_host\n```\n\n然而当你想换个端口或是利用私钥登入服务器的时候就傻眼了，不得不打开 man pages：\n\n```\nSH(1)                    BSD General Commands Manual                   SSH(1)\n\nNAME\n     ssh -- OpenSSH SSH client (remote login program)\n\nSYNOPSIS\n     ssh [-1246AaCfGgKkMNnqsTtVvXxYy] [-b bind_address] [-c cipher_spec]\n         [-D [bind_address:]port] [-E log_file] [-e escape_char]\n         [-F configfile] [-I pkcs11] [-i identity_file]\n         [-J [user@]host[:port]] [-L address] [-l login_name] [-m mac_spec]\n         [-O ctl_cmd] [-o option] [-p port] [-Q query_option] [-R address]\n         [-S ctl_path] [-W host:port] [-w local_tun[:remote_tun]]\n         [user@]hostname [command]\n\nDESCRIPTION\n```\n\n以下省略一万字……\n\n<!--more-->\n\n于是想找如何使用私钥登录的你感到了一阵绝望……（虽然它确实存在于[-i identity_file]这里，你找到了吗？）\n\n## 所以就有了 TLDR\n\ntldr 很好地解决了这个问题，把 man pages 中最常用的选项用更简单的方式叙述了出来：\n\n```shell\n$ tldr ssh\n\n  ssh\n\n  Secure Shell is a protocol used to securely log onto remote systems.\n  It can be used for logging or executing commands on a remote server.\n\n  - Connect to a remote server:\n    ssh username@remote_host\n\n  - Connect to a remote server with a specific identity (private key):\n    ssh -i path/to/key_file username@remote_host\n\n  - Connect to a remote server using a specific port:\n    ssh username@remote_host -p 2222\n\n  - Run a command on a remote server:\n    ssh remote_host command -with -flags\n\n  - SSH tunneling: Dynamic port forwarding (SOCKS proxy on localhost:9999):\n    ssh -D 9999 -C username@remote_host\n\n  - SSH tunneling: Forward a specific port (localhost:9999 to slashdot.org:80):\n    ssh -L 9999:slashdot.org:80 username@remote_host\n\n  - Enable the option to forward the authentication information to the remote machine (see man ssh_config for available options):\n    ssh -o \"ForwardAgent=yes\" username@remote_host\n```\n\n是的，tldr 的 ssh page 就这么长，而且你几乎还能一下就找到怎么使用私钥登录。虽然它确实非常不全，但是它可以解决你绝大部分想查 man 的问题。\n\n## 而且它是社区驱动的呀！\n\n它是一个开源的项目，每个人都可以为它贡献或修改其中的 page。如果你想去围观这个作品，可以到 [**tldr**](https://github.com/tldr-pages/tldr) 这个 GitHub 代码仓库去做出一些自己的贡献。\n\n\n\n# 安装和使用\n\n## 网页版\n\n最简单的使用方法是打开[网页版](https://tldr.ostera.io/)。在上方的搜索框中找到你想查看的命令。例如：\n\n![网页版的 tldr](http://osvlzj5nm.bkt.clouddn.com/17-9-20/91829078.jpg)\n\n\n\n## Node.js 版本\n\nTLDR 最初的版本用 Node.js 写成，所以官方最为推荐的安装方法是：\n\n```shell\nnpm install -g tldr\n```\n\n如果你不了解以下一接中提到的任何一种编程语言/包管理器（当然我觉得这种情况也不需要这个破软件就是了），我们也在这里推荐使用 npm 安装。如果你还没有 npm， 可以到[这里](https://www.npmjs.com/get-npm)下载。\n\n\n\n## 其他版本\n\nTLDR 的官网也给除了其他一些安装方式：\n\n| Client                                   | Installation instructions                |\n| ---------------------------------------- | ---------------------------------------- |\n| [Ruby client](https://github.com/YellowApple/tldrb) | `gem install tldrb`                      |\n| [Haskell client](https://github.com/psibi/tldr-hs) | `stack install tldr`                     |\n| [Python client](https://github.com/lord63/tldr.py) | `pip install tldr.py`                    |\n| [C++ client](https://github.com/tldr-pages/tldr-cpp-client) | `brew install tldr`                      |\n| [Android client](https://github.com/gianasista/tldr-viewer) | [tldr-viewer on Google Play](https://play.google.com/store/apps/details?id=de.gianasista.tldr_viewer) |\n| [iOS client](https://github.com/freesuraj/TLDR) | [TLDR Man Page in App Store](https://appsto.re/sg/IQ0-_.i) |\n| [Dash for OSX](https://github.com/Moddus/tldr-python-dash-docset) | open `Preferences > Downloads > User Contributed` and find `tldr pages` in the list |\n| [Bash client](https://github.com/pepa65/tldr-bash-client) | `bpkg install pepa65/tldr`               |\n\n##使用方法\n\n简单而言，你只要在命令行输入 `tldr` 加上任何命令即可，例如 `tldr ssh` 或是 `tldr tar`，你就可以获得在第一节中所见的简洁的介绍啦！","source":"_posts/tldr-pages.md","raw":"---\ntitle: TLDR pages：简易版的 man pages\ndate: 2017-09-19\ncategory: 软件推荐\ntags: \n- 软件\n- 命令行\n---\n\n\n\n# 什么是TLDR？\n\n## TLDR 它本身\n\ntl;dr 是一个网络词汇，和十动然拒这类差不多，是个缩写。它的全称是「Too Long; Don't Read」，翻译成中文的话就叫「太长不看」。它兴起于一些论坛，为了说明「楼主你的破文章又臭又长」，不过后来有许多文章的开头也用\n\n## 这个东西为啥叫太长不看？\n\n一个叫「太长不看」的命令行工具显然是解决一些令程序员一个脑袋两个大的太长的东西，而这个东西就是 **Linux man pages**。它到底有多长呢，man pages的官方压缩包是 2M 多的大小，解压后是 16M。 16M 确实不算大了，然而这 16M 可是纯文本啊。用来做类比的话，一本50万字的中文小说变成纯文本文件之后也就那么 1M 多，可想而知这甚至是全英文 man pages 有多长了。\n\n## 我们却需要它\n\n作为程序员有时又十分需要 man pages。 虽然它长，你又不得不去读它：比如说，你知道 ssh 的基本用法是\n\n```shell\nssh username@remote_host\n```\n\n然而当你想换个端口或是利用私钥登入服务器的时候就傻眼了，不得不打开 man pages：\n\n```\nSH(1)                    BSD General Commands Manual                   SSH(1)\n\nNAME\n     ssh -- OpenSSH SSH client (remote login program)\n\nSYNOPSIS\n     ssh [-1246AaCfGgKkMNnqsTtVvXxYy] [-b bind_address] [-c cipher_spec]\n         [-D [bind_address:]port] [-E log_file] [-e escape_char]\n         [-F configfile] [-I pkcs11] [-i identity_file]\n         [-J [user@]host[:port]] [-L address] [-l login_name] [-m mac_spec]\n         [-O ctl_cmd] [-o option] [-p port] [-Q query_option] [-R address]\n         [-S ctl_path] [-W host:port] [-w local_tun[:remote_tun]]\n         [user@]hostname [command]\n\nDESCRIPTION\n```\n\n以下省略一万字……\n\n<!--more-->\n\n于是想找如何使用私钥登录的你感到了一阵绝望……（虽然它确实存在于[-i identity_file]这里，你找到了吗？）\n\n## 所以就有了 TLDR\n\ntldr 很好地解决了这个问题，把 man pages 中最常用的选项用更简单的方式叙述了出来：\n\n```shell\n$ tldr ssh\n\n  ssh\n\n  Secure Shell is a protocol used to securely log onto remote systems.\n  It can be used for logging or executing commands on a remote server.\n\n  - Connect to a remote server:\n    ssh username@remote_host\n\n  - Connect to a remote server with a specific identity (private key):\n    ssh -i path/to/key_file username@remote_host\n\n  - Connect to a remote server using a specific port:\n    ssh username@remote_host -p 2222\n\n  - Run a command on a remote server:\n    ssh remote_host command -with -flags\n\n  - SSH tunneling: Dynamic port forwarding (SOCKS proxy on localhost:9999):\n    ssh -D 9999 -C username@remote_host\n\n  - SSH tunneling: Forward a specific port (localhost:9999 to slashdot.org:80):\n    ssh -L 9999:slashdot.org:80 username@remote_host\n\n  - Enable the option to forward the authentication information to the remote machine (see man ssh_config for available options):\n    ssh -o \"ForwardAgent=yes\" username@remote_host\n```\n\n是的，tldr 的 ssh page 就这么长，而且你几乎还能一下就找到怎么使用私钥登录。虽然它确实非常不全，但是它可以解决你绝大部分想查 man 的问题。\n\n## 而且它是社区驱动的呀！\n\n它是一个开源的项目，每个人都可以为它贡献或修改其中的 page。如果你想去围观这个作品，可以到 [**tldr**](https://github.com/tldr-pages/tldr) 这个 GitHub 代码仓库去做出一些自己的贡献。\n\n\n\n# 安装和使用\n\n## 网页版\n\n最简单的使用方法是打开[网页版](https://tldr.ostera.io/)。在上方的搜索框中找到你想查看的命令。例如：\n\n![网页版的 tldr](http://osvlzj5nm.bkt.clouddn.com/17-9-20/91829078.jpg)\n\n\n\n## Node.js 版本\n\nTLDR 最初的版本用 Node.js 写成，所以官方最为推荐的安装方法是：\n\n```shell\nnpm install -g tldr\n```\n\n如果你不了解以下一接中提到的任何一种编程语言/包管理器（当然我觉得这种情况也不需要这个破软件就是了），我们也在这里推荐使用 npm 安装。如果你还没有 npm， 可以到[这里](https://www.npmjs.com/get-npm)下载。\n\n\n\n## 其他版本\n\nTLDR 的官网也给除了其他一些安装方式：\n\n| Client                                   | Installation instructions                |\n| ---------------------------------------- | ---------------------------------------- |\n| [Ruby client](https://github.com/YellowApple/tldrb) | `gem install tldrb`                      |\n| [Haskell client](https://github.com/psibi/tldr-hs) | `stack install tldr`                     |\n| [Python client](https://github.com/lord63/tldr.py) | `pip install tldr.py`                    |\n| [C++ client](https://github.com/tldr-pages/tldr-cpp-client) | `brew install tldr`                      |\n| [Android client](https://github.com/gianasista/tldr-viewer) | [tldr-viewer on Google Play](https://play.google.com/store/apps/details?id=de.gianasista.tldr_viewer) |\n| [iOS client](https://github.com/freesuraj/TLDR) | [TLDR Man Page in App Store](https://appsto.re/sg/IQ0-_.i) |\n| [Dash for OSX](https://github.com/Moddus/tldr-python-dash-docset) | open `Preferences > Downloads > User Contributed` and find `tldr pages` in the list |\n| [Bash client](https://github.com/pepa65/tldr-bash-client) | `bpkg install pepa65/tldr`               |\n\n##使用方法\n\n简单而言，你只要在命令行输入 `tldr` 加上任何命令即可，例如 `tldr ssh` 或是 `tldr tar`，你就可以获得在第一节中所见的简洁的介绍啦！","slug":"tldr-pages","published":1,"updated":"2018-07-03T13:44:30.393Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj5repuf00099pd3h9zm5pcb","content":"<h1 id=\"什么是TLDR？\"><a href=\"#什么是TLDR？\" class=\"headerlink\" title=\"什么是TLDR？\"></a>什么是TLDR？</h1><h2 id=\"TLDR-它本身\"><a href=\"#TLDR-它本身\" class=\"headerlink\" title=\"TLDR 它本身\"></a>TLDR 它本身</h2><p>tl;dr 是一个网络词汇，和十动然拒这类差不多，是个缩写。它的全称是「Too Long; Don’t Read」，翻译成中文的话就叫「太长不看」。它兴起于一些论坛，为了说明「楼主你的破文章又臭又长」，不过后来有许多文章的开头也用</p>\n<h2 id=\"这个东西为啥叫太长不看？\"><a href=\"#这个东西为啥叫太长不看？\" class=\"headerlink\" title=\"这个东西为啥叫太长不看？\"></a>这个东西为啥叫太长不看？</h2><p>一个叫「太长不看」的命令行工具显然是解决一些令程序员一个脑袋两个大的太长的东西，而这个东西就是 <strong>Linux man pages</strong>。它到底有多长呢，man pages的官方压缩包是 2M 多的大小，解压后是 16M。 16M 确实不算大了，然而这 16M 可是纯文本啊。用来做类比的话，一本50万字的中文小说变成纯文本文件之后也就那么 1M 多，可想而知这甚至是全英文 man pages 有多长了。</p>\n<h2 id=\"我们却需要它\"><a href=\"#我们却需要它\" class=\"headerlink\" title=\"我们却需要它\"></a>我们却需要它</h2><p>作为程序员有时又十分需要 man pages。 虽然它长，你又不得不去读它：比如说，你知道 ssh 的基本用法是</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh username@remote_host</span><br></pre></td></tr></table></figure>\n<p>然而当你想换个端口或是利用私钥登入服务器的时候就傻眼了，不得不打开 man pages：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SH(1)                    BSD General Commands Manual                   SSH(1)</span><br><span class=\"line\"></span><br><span class=\"line\">NAME</span><br><span class=\"line\">     ssh -- OpenSSH SSH client (remote login program)</span><br><span class=\"line\"></span><br><span class=\"line\">SYNOPSIS</span><br><span class=\"line\">     ssh [-1246AaCfGgKkMNnqsTtVvXxYy] [-b bind_address] [-c cipher_spec]</span><br><span class=\"line\">         [-D [bind_address:]port] [-E log_file] [-e escape_char]</span><br><span class=\"line\">         [-F configfile] [-I pkcs11] [-i identity_file]</span><br><span class=\"line\">         [-J [user@]host[:port]] [-L address] [-l login_name] [-m mac_spec]</span><br><span class=\"line\">         [-O ctl_cmd] [-o option] [-p port] [-Q query_option] [-R address]</span><br><span class=\"line\">         [-S ctl_path] [-W host:port] [-w local_tun[:remote_tun]]</span><br><span class=\"line\">         [user@]hostname [command]</span><br><span class=\"line\"></span><br><span class=\"line\">DESCRIPTION</span><br></pre></td></tr></table></figure>\n<p>以下省略一万字……</p>\n<a id=\"more\"></a>\n<p>于是想找如何使用私钥登录的你感到了一阵绝望……（虽然它确实存在于[-i identity_file]这里，你找到了吗？）</p>\n<h2 id=\"所以就有了-TLDR\"><a href=\"#所以就有了-TLDR\" class=\"headerlink\" title=\"所以就有了 TLDR\"></a>所以就有了 TLDR</h2><p>tldr 很好地解决了这个问题，把 man pages 中最常用的选项用更简单的方式叙述了出来：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> tldr ssh</span><br><span class=\"line\"></span><br><span class=\"line\">  ssh</span><br><span class=\"line\"></span><br><span class=\"line\">  Secure Shell is a protocol used to securely log onto remote systems.</span><br><span class=\"line\">  It can be used for logging or executing commands on a remote server.</span><br><span class=\"line\"></span><br><span class=\"line\">  - Connect to a remote server:</span><br><span class=\"line\">    ssh username@remote_host</span><br><span class=\"line\"></span><br><span class=\"line\">  - Connect to a remote server with a specific identity (private key):</span><br><span class=\"line\">    ssh -i path/to/key_file username@remote_host</span><br><span class=\"line\"></span><br><span class=\"line\">  - Connect to a remote server using a specific port:</span><br><span class=\"line\">    ssh username@remote_host -p 2222</span><br><span class=\"line\"></span><br><span class=\"line\">  - Run a command on a remote server:</span><br><span class=\"line\">    ssh remote_host command -with -flags</span><br><span class=\"line\"></span><br><span class=\"line\">  - SSH tunneling: Dynamic port forwarding (SOCKS proxy on localhost:9999):</span><br><span class=\"line\">    ssh -D 9999 -C username@remote_host</span><br><span class=\"line\"></span><br><span class=\"line\">  - SSH tunneling: Forward a specific port (localhost:9999 to slashdot.org:80):</span><br><span class=\"line\">    ssh -L 9999:slashdot.org:80 username@remote_host</span><br><span class=\"line\"></span><br><span class=\"line\">  - Enable the option to forward the authentication information to the remote machine (see man ssh_config for available options):</span><br><span class=\"line\">    ssh -o \"ForwardAgent=yes\" username@remote_host</span><br></pre></td></tr></table></figure>\n<p>是的，tldr 的 ssh page 就这么长，而且你几乎还能一下就找到怎么使用私钥登录。虽然它确实非常不全，但是它可以解决你绝大部分想查 man 的问题。</p>\n<h2 id=\"而且它是社区驱动的呀！\"><a href=\"#而且它是社区驱动的呀！\" class=\"headerlink\" title=\"而且它是社区驱动的呀！\"></a>而且它是社区驱动的呀！</h2><p>它是一个开源的项目，每个人都可以为它贡献或修改其中的 page。如果你想去围观这个作品，可以到 <a href=\"https://github.com/tldr-pages/tldr\" target=\"_blank\" rel=\"noopener\"><strong>tldr</strong></a> 这个 GitHub 代码仓库去做出一些自己的贡献。</p>\n<h1 id=\"安装和使用\"><a href=\"#安装和使用\" class=\"headerlink\" title=\"安装和使用\"></a>安装和使用</h1><h2 id=\"网页版\"><a href=\"#网页版\" class=\"headerlink\" title=\"网页版\"></a>网页版</h2><p>最简单的使用方法是打开<a href=\"https://tldr.ostera.io/\" target=\"_blank\" rel=\"noopener\">网页版</a>。在上方的搜索框中找到你想查看的命令。例如：</p>\n<p><img src=\"http://osvlzj5nm.bkt.clouddn.com/17-9-20/91829078.jpg\" alt=\"网页版的 tldr\"></p>\n<h2 id=\"Node-js-版本\"><a href=\"#Node-js-版本\" class=\"headerlink\" title=\"Node.js 版本\"></a>Node.js 版本</h2><p>TLDR 最初的版本用 Node.js 写成，所以官方最为推荐的安装方法是：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g tldr</span><br></pre></td></tr></table></figure>\n<p>如果你不了解以下一接中提到的任何一种编程语言/包管理器（当然我觉得这种情况也不需要这个破软件就是了），我们也在这里推荐使用 npm 安装。如果你还没有 npm， 可以到<a href=\"https://www.npmjs.com/get-npm\" target=\"_blank\" rel=\"noopener\">这里</a>下载。</p>\n<h2 id=\"其他版本\"><a href=\"#其他版本\" class=\"headerlink\" title=\"其他版本\"></a>其他版本</h2><p>TLDR 的官网也给除了其他一些安装方式：</p>\n<table>\n<thead>\n<tr>\n<th>Client</th>\n<th>Installation instructions</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://github.com/YellowApple/tldrb\" target=\"_blank\" rel=\"noopener\">Ruby client</a></td>\n<td><code>gem install tldrb</code></td>\n</tr>\n<tr>\n<td><a href=\"https://github.com/psibi/tldr-hs\" target=\"_blank\" rel=\"noopener\">Haskell client</a></td>\n<td><code>stack install tldr</code></td>\n</tr>\n<tr>\n<td><a href=\"https://github.com/lord63/tldr.py\" target=\"_blank\" rel=\"noopener\">Python client</a></td>\n<td><code>pip install tldr.py</code></td>\n</tr>\n<tr>\n<td><a href=\"https://github.com/tldr-pages/tldr-cpp-client\" target=\"_blank\" rel=\"noopener\">C++ client</a></td>\n<td><code>brew install tldr</code></td>\n</tr>\n<tr>\n<td><a href=\"https://github.com/gianasista/tldr-viewer\" target=\"_blank\" rel=\"noopener\">Android client</a></td>\n<td><a href=\"https://play.google.com/store/apps/details?id=de.gianasista.tldr_viewer\" target=\"_blank\" rel=\"noopener\">tldr-viewer on Google Play</a></td>\n</tr>\n<tr>\n<td><a href=\"https://github.com/freesuraj/TLDR\" target=\"_blank\" rel=\"noopener\">iOS client</a></td>\n<td><a href=\"https://appsto.re/sg/IQ0-_.i\" target=\"_blank\" rel=\"noopener\">TLDR Man Page in App Store</a></td>\n</tr>\n<tr>\n<td><a href=\"https://github.com/Moddus/tldr-python-dash-docset\" target=\"_blank\" rel=\"noopener\">Dash for OSX</a></td>\n<td>open <code>Preferences &gt; Downloads &gt; User Contributed</code> and find <code>tldr pages</code> in the list</td>\n</tr>\n<tr>\n<td><a href=\"https://github.com/pepa65/tldr-bash-client\" target=\"_blank\" rel=\"noopener\">Bash client</a></td>\n<td><code>bpkg install pepa65/tldr</code></td>\n</tr>\n</tbody>\n</table>\n<p>##使用方法</p>\n<p>简单而言，你只要在命令行输入 <code>tldr</code> 加上任何命令即可，例如 <code>tldr ssh</code> 或是 <code>tldr tar</code>，你就可以获得在第一节中所见的简洁的介绍啦！</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"什么是TLDR？\"><a href=\"#什么是TLDR？\" class=\"headerlink\" title=\"什么是TLDR？\"></a>什么是TLDR？</h1><h2 id=\"TLDR-它本身\"><a href=\"#TLDR-它本身\" class=\"headerlink\" title=\"TLDR 它本身\"></a>TLDR 它本身</h2><p>tl;dr 是一个网络词汇，和十动然拒这类差不多，是个缩写。它的全称是「Too Long; Don’t Read」，翻译成中文的话就叫「太长不看」。它兴起于一些论坛，为了说明「楼主你的破文章又臭又长」，不过后来有许多文章的开头也用</p>\n<h2 id=\"这个东西为啥叫太长不看？\"><a href=\"#这个东西为啥叫太长不看？\" class=\"headerlink\" title=\"这个东西为啥叫太长不看？\"></a>这个东西为啥叫太长不看？</h2><p>一个叫「太长不看」的命令行工具显然是解决一些令程序员一个脑袋两个大的太长的东西，而这个东西就是 <strong>Linux man pages</strong>。它到底有多长呢，man pages的官方压缩包是 2M 多的大小，解压后是 16M。 16M 确实不算大了，然而这 16M 可是纯文本啊。用来做类比的话，一本50万字的中文小说变成纯文本文件之后也就那么 1M 多，可想而知这甚至是全英文 man pages 有多长了。</p>\n<h2 id=\"我们却需要它\"><a href=\"#我们却需要它\" class=\"headerlink\" title=\"我们却需要它\"></a>我们却需要它</h2><p>作为程序员有时又十分需要 man pages。 虽然它长，你又不得不去读它：比如说，你知道 ssh 的基本用法是</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh username@remote_host</span><br></pre></td></tr></table></figure>\n<p>然而当你想换个端口或是利用私钥登入服务器的时候就傻眼了，不得不打开 man pages：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SH(1)                    BSD General Commands Manual                   SSH(1)</span><br><span class=\"line\"></span><br><span class=\"line\">NAME</span><br><span class=\"line\">     ssh -- OpenSSH SSH client (remote login program)</span><br><span class=\"line\"></span><br><span class=\"line\">SYNOPSIS</span><br><span class=\"line\">     ssh [-1246AaCfGgKkMNnqsTtVvXxYy] [-b bind_address] [-c cipher_spec]</span><br><span class=\"line\">         [-D [bind_address:]port] [-E log_file] [-e escape_char]</span><br><span class=\"line\">         [-F configfile] [-I pkcs11] [-i identity_file]</span><br><span class=\"line\">         [-J [user@]host[:port]] [-L address] [-l login_name] [-m mac_spec]</span><br><span class=\"line\">         [-O ctl_cmd] [-o option] [-p port] [-Q query_option] [-R address]</span><br><span class=\"line\">         [-S ctl_path] [-W host:port] [-w local_tun[:remote_tun]]</span><br><span class=\"line\">         [user@]hostname [command]</span><br><span class=\"line\"></span><br><span class=\"line\">DESCRIPTION</span><br></pre></td></tr></table></figure>\n<p>以下省略一万字……</p>","more":"<p>于是想找如何使用私钥登录的你感到了一阵绝望……（虽然它确实存在于[-i identity_file]这里，你找到了吗？）</p>\n<h2 id=\"所以就有了-TLDR\"><a href=\"#所以就有了-TLDR\" class=\"headerlink\" title=\"所以就有了 TLDR\"></a>所以就有了 TLDR</h2><p>tldr 很好地解决了这个问题，把 man pages 中最常用的选项用更简单的方式叙述了出来：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> tldr ssh</span><br><span class=\"line\"></span><br><span class=\"line\">  ssh</span><br><span class=\"line\"></span><br><span class=\"line\">  Secure Shell is a protocol used to securely log onto remote systems.</span><br><span class=\"line\">  It can be used for logging or executing commands on a remote server.</span><br><span class=\"line\"></span><br><span class=\"line\">  - Connect to a remote server:</span><br><span class=\"line\">    ssh username@remote_host</span><br><span class=\"line\"></span><br><span class=\"line\">  - Connect to a remote server with a specific identity (private key):</span><br><span class=\"line\">    ssh -i path/to/key_file username@remote_host</span><br><span class=\"line\"></span><br><span class=\"line\">  - Connect to a remote server using a specific port:</span><br><span class=\"line\">    ssh username@remote_host -p 2222</span><br><span class=\"line\"></span><br><span class=\"line\">  - Run a command on a remote server:</span><br><span class=\"line\">    ssh remote_host command -with -flags</span><br><span class=\"line\"></span><br><span class=\"line\">  - SSH tunneling: Dynamic port forwarding (SOCKS proxy on localhost:9999):</span><br><span class=\"line\">    ssh -D 9999 -C username@remote_host</span><br><span class=\"line\"></span><br><span class=\"line\">  - SSH tunneling: Forward a specific port (localhost:9999 to slashdot.org:80):</span><br><span class=\"line\">    ssh -L 9999:slashdot.org:80 username@remote_host</span><br><span class=\"line\"></span><br><span class=\"line\">  - Enable the option to forward the authentication information to the remote machine (see man ssh_config for available options):</span><br><span class=\"line\">    ssh -o \"ForwardAgent=yes\" username@remote_host</span><br></pre></td></tr></table></figure>\n<p>是的，tldr 的 ssh page 就这么长，而且你几乎还能一下就找到怎么使用私钥登录。虽然它确实非常不全，但是它可以解决你绝大部分想查 man 的问题。</p>\n<h2 id=\"而且它是社区驱动的呀！\"><a href=\"#而且它是社区驱动的呀！\" class=\"headerlink\" title=\"而且它是社区驱动的呀！\"></a>而且它是社区驱动的呀！</h2><p>它是一个开源的项目，每个人都可以为它贡献或修改其中的 page。如果你想去围观这个作品，可以到 <a href=\"https://github.com/tldr-pages/tldr\" target=\"_blank\" rel=\"noopener\"><strong>tldr</strong></a> 这个 GitHub 代码仓库去做出一些自己的贡献。</p>\n<h1 id=\"安装和使用\"><a href=\"#安装和使用\" class=\"headerlink\" title=\"安装和使用\"></a>安装和使用</h1><h2 id=\"网页版\"><a href=\"#网页版\" class=\"headerlink\" title=\"网页版\"></a>网页版</h2><p>最简单的使用方法是打开<a href=\"https://tldr.ostera.io/\" target=\"_blank\" rel=\"noopener\">网页版</a>。在上方的搜索框中找到你想查看的命令。例如：</p>\n<p><img src=\"http://osvlzj5nm.bkt.clouddn.com/17-9-20/91829078.jpg\" alt=\"网页版的 tldr\"></p>\n<h2 id=\"Node-js-版本\"><a href=\"#Node-js-版本\" class=\"headerlink\" title=\"Node.js 版本\"></a>Node.js 版本</h2><p>TLDR 最初的版本用 Node.js 写成，所以官方最为推荐的安装方法是：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g tldr</span><br></pre></td></tr></table></figure>\n<p>如果你不了解以下一接中提到的任何一种编程语言/包管理器（当然我觉得这种情况也不需要这个破软件就是了），我们也在这里推荐使用 npm 安装。如果你还没有 npm， 可以到<a href=\"https://www.npmjs.com/get-npm\" target=\"_blank\" rel=\"noopener\">这里</a>下载。</p>\n<h2 id=\"其他版本\"><a href=\"#其他版本\" class=\"headerlink\" title=\"其他版本\"></a>其他版本</h2><p>TLDR 的官网也给除了其他一些安装方式：</p>\n<table>\n<thead>\n<tr>\n<th>Client</th>\n<th>Installation instructions</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://github.com/YellowApple/tldrb\" target=\"_blank\" rel=\"noopener\">Ruby client</a></td>\n<td><code>gem install tldrb</code></td>\n</tr>\n<tr>\n<td><a href=\"https://github.com/psibi/tldr-hs\" target=\"_blank\" rel=\"noopener\">Haskell client</a></td>\n<td><code>stack install tldr</code></td>\n</tr>\n<tr>\n<td><a href=\"https://github.com/lord63/tldr.py\" target=\"_blank\" rel=\"noopener\">Python client</a></td>\n<td><code>pip install tldr.py</code></td>\n</tr>\n<tr>\n<td><a href=\"https://github.com/tldr-pages/tldr-cpp-client\" target=\"_blank\" rel=\"noopener\">C++ client</a></td>\n<td><code>brew install tldr</code></td>\n</tr>\n<tr>\n<td><a href=\"https://github.com/gianasista/tldr-viewer\" target=\"_blank\" rel=\"noopener\">Android client</a></td>\n<td><a href=\"https://play.google.com/store/apps/details?id=de.gianasista.tldr_viewer\" target=\"_blank\" rel=\"noopener\">tldr-viewer on Google Play</a></td>\n</tr>\n<tr>\n<td><a href=\"https://github.com/freesuraj/TLDR\" target=\"_blank\" rel=\"noopener\">iOS client</a></td>\n<td><a href=\"https://appsto.re/sg/IQ0-_.i\" target=\"_blank\" rel=\"noopener\">TLDR Man Page in App Store</a></td>\n</tr>\n<tr>\n<td><a href=\"https://github.com/Moddus/tldr-python-dash-docset\" target=\"_blank\" rel=\"noopener\">Dash for OSX</a></td>\n<td>open <code>Preferences &gt; Downloads &gt; User Contributed</code> and find <code>tldr pages</code> in the list</td>\n</tr>\n<tr>\n<td><a href=\"https://github.com/pepa65/tldr-bash-client\" target=\"_blank\" rel=\"noopener\">Bash client</a></td>\n<td><code>bpkg install pepa65/tldr</code></td>\n</tr>\n</tbody>\n</table>\n<p>##使用方法</p>\n<p>简单而言，你只要在命令行输入 <code>tldr</code> 加上任何命令即可，例如 <code>tldr ssh</code> 或是 <code>tldr tar</code>，你就可以获得在第一节中所见的简洁的介绍啦！</p>"},{"title":"猴子都能学会的20行代码登录微博","date":"2017-07-13T16:00:00.000Z","_content":"\n如何登录新浪微博是令许多数据新手（包括我）头疼的大问题。由于新浪的反爬虫策略，网上的教程往往撑不过几个月，查阅到的资料在半年前或是一年前——而它们早就无法使用了，在你想开始爬虫的时候被活生生卡在了第一步。\n\n简单而言，我使用的方法是通过 Selenium 模拟浏览器的行为，直接在浏览器中输入用户名和密码并登录，然后直接从浏览器中获取 Cookies。虽然听起来十分简单（实际上也十分简单），但是确实是十分有效的方式。只要一个网站能通过浏览器登陆，我们就可以简单改造这个程序来登录并获得想要的资料。\n\n\n\n# 什么是Selenium？如何使用？\n\nSelenium 是一个项目的名称，都与浏览器和网页测试相关。主要的工具也就是今天我们所要使用的，是WebDriver，是一个浏览器自动化工具。它为很多不同的语言提供了库，包括 Python、Java、Ruby 等。本文中我选择使用 Python 来进行操作，当然你也可以使用你熟悉的语言来进行操作。\n\n在 Python中使用 Selenium 只需要通过`pip`安装 Selenium 提供的 Python 库。\n\n```shell\npip3 install selenium  # 如果你使用 Python 2 ，请使用 pip install selenium\n```\n\n仅仅安装 Selenium 本身是不够的，你同时还需要安装 Driver 。你可以将 Driver 理解为浏览器本身的『驱动』，在程序中使用 Driver 就相当于你打开了一个浏览器做了些什么事情。\n\n<!--more-->\n\n在这里我们推荐几个 Driver ：\n\n1. Firefox: https://github.com/mozilla/geckodriver/releases\n2. Chrome: https://sites.google.com/a/chromium.org/chromedriver/downloads\n3. PhantomJS: http://phantomjs.org/download.html\n\n（如果你是Windows用户，这部分内容也需要参考：http://selenium-python.readthedocs.io/installation.html#detailed-instructions-for-windows-users）\n\n下载后，我建议将可执行文件加入环境中，以备使用。\n\nFirefox 和 Chrome 相信大家都比较熟悉。PhantomJS 是一个可以让你无需浏览器就进行网页相关操作的[WebKit](https://zh.wikipedia.org/wiki/WebKit)，它也没有图形界面。个人比较推荐在调试程序期间使用 Firefox 或是 Chrome ，这样你可以通过观察发现自己哪里出了错。在调试完成后使用 PhantomJS ，来避免多余的可视化渲染。\n\n\n\n# 创建一个 WebDriver\n\n利用 Selenium 创建 WebDriver 十分简单粗暴：\n\n```python\nfrom selenium import webdriver\ndriver = webdriver.Firefox()  # 如果 Firefox 所时使用的 geckodriver 在环境中\n# driver = webdriver.PhantomJS()  # 如果你想使用 PhantomJS\n```\n\n如果你需要自定义路径，你可以通过传入参数 `executable_path`：\n\n```python\ndriver = webdriver.Firefox(executable_path=\"/path/to/geckodriver\")\n```\n\n如果你使用 Firefox 或 Chrome，你会看到这个操作打开一个浏览器。\n\n\n\n# 观察网页本身\n\n为了方便演示，我们使用新浪的移动版进行登录。如果想决定如何操作一个网页，首先我们要观察网页本身。\n\n右键登录的地方并审查元素，你会发现用户名和密码其实是简单的输入框，而登录按钮是一个链接而已。\n\n![](http://osvlzj5nm.bkt.clouddn.com/17-7-14/91396431.jpg)\n\n因此我们简单规划之后要做的事情：\n\n1. 输入用户名和密码\n2. 点击登录按钮（或摁回车）\n\n\n\n# 利用 Selenium 进行登录操作\n\n## 打开网页\n\nSelenium 提供了方法的`get`方法用以获取网页：\n\n```python\ndriver.get('https://passport.weibo.cn/signin/login')\n```\n\n如果你使用 Firefox 或 Chrome，你会看到这个操作打开微博手机版的登录页面。\n\n## 定位元素\n\n由网页本身的结构我们发现，这两个输入框和登录链接元素的`id`属性都是页面中独一无二的，我们便可以利用这一特点寻找到元素本身。\n\n```python\nname_field = driver.find_element_by_id('loginName')  # 用户名输入框\npassword_field = driver.find_element_by_id('loginPassword')  # 密码输入框\nsubmit_button = driver.find_element_by_id('loginAction')  # 登录键\n```\n\n## 输入内容\n\nSelenium 提供了为元素输入的方法 `send_keys()`，直接调用这一方法就可以把内容输入到网页中的输入框内：\n\n```python\nname_field.send_keys('你的用户名')\npassword_field.send_keys('你的密码')\n```\n\n如果你使用 Firefox 或 Chrome ，你会看到页面中的两个输入框被填入你在程序中输入的文字。\n\n点击按钮的方法也很简单，如果你已经获取了元素，只要使用`click()`方法：\n\n```python\nsubmit_button.click()  # 单击元素\n```\n\n如果你需要使用回车键，可以使用`send_keys()`来发送回车（`Keys.RETURN`），我在这里不展开描述。\n\n如果你担心两个输入框在你输入前就已经有了其他内容而影响操作，你可以使用`clear()`方法，并且我在这里也更加推荐这样的做法：\n\n```python\nname_field.clear()  # 清除用户名区域\nname_field.send_keys('你的用户名')\n\npassword_field.clear()  # 清除密码区域\npassword_field.send_keys('你的密码')\n```\n\n## 获取 Cookies\n\n从 WebDriver 获取 Cookies 只需要一个操作 `get_cookies()`：\n\n```python\ndriver.get_cookies()\n```\n\n它是一个字典文件的列表，每一个字典文件是一个 Cookie。如果你们要在其他 WebDriver 或浏览器中使用这组 Cookies ，使用一个循环来给 WebDriver 利用`add_cookie`方法添加是比较标准的方法：\n\n```python\nfor cookie in driver.get_cookies():\n    another_driver.add_cookie(cookie)\n```\n\n## 等待网页载入\n\n如果你仅仅执行上述代码，你会发现如果你的网速不够快，或是电脑不够好，就非常容易在元素出现前就进行操作，然后出现无法找到元素或是元素不可见等错误，我们可以通过等待一段时间来解决这个问题：\n\n```python\nimport time\n\n# 在获取网页后\ntime.sleep(2) # 等待2秒\n```\n\n这种做法比较简单，但也十分粗暴：因为你无法确定2秒时间足够让网页加载完成。每次打开网页的时间受限于许多因素，你可能很难用一个固定的时间来决定。而 Selenium 本身也提供了一些好用的方法：\n\n```python\nfrom selenium.webdriver.common.by import By\nfrom selenium.webdriver.support.ui import WebDriverWait\nfrom selenium.webdriver.support import expected_conditions as EC\n\n# 在获取网页后\nWebDriverWait(driver, 20).until(\n    EC.presence_of_element_located((By.ID, 'loginName'))) \n# 等待 id 为 loginName的元素出现，最多20秒\n```\n\n\n\n# 结语\n\n如何登录网站对于收集数据的人而言是个不大不小的问题。通过使用 Selenium，我们几乎可以通过各种方法模拟浏览器的操作，而且这种方法是只要浏览器存在就可以使用的。我相信如何观察网页的结构以及利用是非常有用的技能。\n\n## 完整代码\n\n```python\nimport time\nfrom selenium import webdriver\nfrom selenium.webdriver.common.by import By\nfrom selenium.webdriver.support.ui import WebDriverWait\nfrom selenium.webdriver.support import expected_conditions as EC\n\ndriver = webdriver.PhantomJS()\ndriver.get('https://passport.weibo.cn/signin/login')\nWebDriverWait(driver, 20).until(\n    EC.presence_of_element_located((By.ID, 'loginName')))\ntime.sleep(1)\n\nname_field = driver.find_element_by_id('loginName')\nname_field.clear()\nname_field.send_keys('你的用户名')\npassword_field = driver.find_element_by_id('loginPassword')\npassword_field.clear()\npassword_field.send_keys('你的密码')\nsubmit_button = driver.find_element_by_id('loginAction')\nsubmit_button.click()\n\nprint(driver.get_cookies())\n```\n\n","source":"_posts/weibo-login-20lines.md","raw":"---\ntitle: 猴子都能学会的20行代码登录微博\ndate: 2017-07-14\ncategory: 计算机课堂\ntags: \n- Python\n- 爬虫\n---\n\n如何登录新浪微博是令许多数据新手（包括我）头疼的大问题。由于新浪的反爬虫策略，网上的教程往往撑不过几个月，查阅到的资料在半年前或是一年前——而它们早就无法使用了，在你想开始爬虫的时候被活生生卡在了第一步。\n\n简单而言，我使用的方法是通过 Selenium 模拟浏览器的行为，直接在浏览器中输入用户名和密码并登录，然后直接从浏览器中获取 Cookies。虽然听起来十分简单（实际上也十分简单），但是确实是十分有效的方式。只要一个网站能通过浏览器登陆，我们就可以简单改造这个程序来登录并获得想要的资料。\n\n\n\n# 什么是Selenium？如何使用？\n\nSelenium 是一个项目的名称，都与浏览器和网页测试相关。主要的工具也就是今天我们所要使用的，是WebDriver，是一个浏览器自动化工具。它为很多不同的语言提供了库，包括 Python、Java、Ruby 等。本文中我选择使用 Python 来进行操作，当然你也可以使用你熟悉的语言来进行操作。\n\n在 Python中使用 Selenium 只需要通过`pip`安装 Selenium 提供的 Python 库。\n\n```shell\npip3 install selenium  # 如果你使用 Python 2 ，请使用 pip install selenium\n```\n\n仅仅安装 Selenium 本身是不够的，你同时还需要安装 Driver 。你可以将 Driver 理解为浏览器本身的『驱动』，在程序中使用 Driver 就相当于你打开了一个浏览器做了些什么事情。\n\n<!--more-->\n\n在这里我们推荐几个 Driver ：\n\n1. Firefox: https://github.com/mozilla/geckodriver/releases\n2. Chrome: https://sites.google.com/a/chromium.org/chromedriver/downloads\n3. PhantomJS: http://phantomjs.org/download.html\n\n（如果你是Windows用户，这部分内容也需要参考：http://selenium-python.readthedocs.io/installation.html#detailed-instructions-for-windows-users）\n\n下载后，我建议将可执行文件加入环境中，以备使用。\n\nFirefox 和 Chrome 相信大家都比较熟悉。PhantomJS 是一个可以让你无需浏览器就进行网页相关操作的[WebKit](https://zh.wikipedia.org/wiki/WebKit)，它也没有图形界面。个人比较推荐在调试程序期间使用 Firefox 或是 Chrome ，这样你可以通过观察发现自己哪里出了错。在调试完成后使用 PhantomJS ，来避免多余的可视化渲染。\n\n\n\n# 创建一个 WebDriver\n\n利用 Selenium 创建 WebDriver 十分简单粗暴：\n\n```python\nfrom selenium import webdriver\ndriver = webdriver.Firefox()  # 如果 Firefox 所时使用的 geckodriver 在环境中\n# driver = webdriver.PhantomJS()  # 如果你想使用 PhantomJS\n```\n\n如果你需要自定义路径，你可以通过传入参数 `executable_path`：\n\n```python\ndriver = webdriver.Firefox(executable_path=\"/path/to/geckodriver\")\n```\n\n如果你使用 Firefox 或 Chrome，你会看到这个操作打开一个浏览器。\n\n\n\n# 观察网页本身\n\n为了方便演示，我们使用新浪的移动版进行登录。如果想决定如何操作一个网页，首先我们要观察网页本身。\n\n右键登录的地方并审查元素，你会发现用户名和密码其实是简单的输入框，而登录按钮是一个链接而已。\n\n![](http://osvlzj5nm.bkt.clouddn.com/17-7-14/91396431.jpg)\n\n因此我们简单规划之后要做的事情：\n\n1. 输入用户名和密码\n2. 点击登录按钮（或摁回车）\n\n\n\n# 利用 Selenium 进行登录操作\n\n## 打开网页\n\nSelenium 提供了方法的`get`方法用以获取网页：\n\n```python\ndriver.get('https://passport.weibo.cn/signin/login')\n```\n\n如果你使用 Firefox 或 Chrome，你会看到这个操作打开微博手机版的登录页面。\n\n## 定位元素\n\n由网页本身的结构我们发现，这两个输入框和登录链接元素的`id`属性都是页面中独一无二的，我们便可以利用这一特点寻找到元素本身。\n\n```python\nname_field = driver.find_element_by_id('loginName')  # 用户名输入框\npassword_field = driver.find_element_by_id('loginPassword')  # 密码输入框\nsubmit_button = driver.find_element_by_id('loginAction')  # 登录键\n```\n\n## 输入内容\n\nSelenium 提供了为元素输入的方法 `send_keys()`，直接调用这一方法就可以把内容输入到网页中的输入框内：\n\n```python\nname_field.send_keys('你的用户名')\npassword_field.send_keys('你的密码')\n```\n\n如果你使用 Firefox 或 Chrome ，你会看到页面中的两个输入框被填入你在程序中输入的文字。\n\n点击按钮的方法也很简单，如果你已经获取了元素，只要使用`click()`方法：\n\n```python\nsubmit_button.click()  # 单击元素\n```\n\n如果你需要使用回车键，可以使用`send_keys()`来发送回车（`Keys.RETURN`），我在这里不展开描述。\n\n如果你担心两个输入框在你输入前就已经有了其他内容而影响操作，你可以使用`clear()`方法，并且我在这里也更加推荐这样的做法：\n\n```python\nname_field.clear()  # 清除用户名区域\nname_field.send_keys('你的用户名')\n\npassword_field.clear()  # 清除密码区域\npassword_field.send_keys('你的密码')\n```\n\n## 获取 Cookies\n\n从 WebDriver 获取 Cookies 只需要一个操作 `get_cookies()`：\n\n```python\ndriver.get_cookies()\n```\n\n它是一个字典文件的列表，每一个字典文件是一个 Cookie。如果你们要在其他 WebDriver 或浏览器中使用这组 Cookies ，使用一个循环来给 WebDriver 利用`add_cookie`方法添加是比较标准的方法：\n\n```python\nfor cookie in driver.get_cookies():\n    another_driver.add_cookie(cookie)\n```\n\n## 等待网页载入\n\n如果你仅仅执行上述代码，你会发现如果你的网速不够快，或是电脑不够好，就非常容易在元素出现前就进行操作，然后出现无法找到元素或是元素不可见等错误，我们可以通过等待一段时间来解决这个问题：\n\n```python\nimport time\n\n# 在获取网页后\ntime.sleep(2) # 等待2秒\n```\n\n这种做法比较简单，但也十分粗暴：因为你无法确定2秒时间足够让网页加载完成。每次打开网页的时间受限于许多因素，你可能很难用一个固定的时间来决定。而 Selenium 本身也提供了一些好用的方法：\n\n```python\nfrom selenium.webdriver.common.by import By\nfrom selenium.webdriver.support.ui import WebDriverWait\nfrom selenium.webdriver.support import expected_conditions as EC\n\n# 在获取网页后\nWebDriverWait(driver, 20).until(\n    EC.presence_of_element_located((By.ID, 'loginName'))) \n# 等待 id 为 loginName的元素出现，最多20秒\n```\n\n\n\n# 结语\n\n如何登录网站对于收集数据的人而言是个不大不小的问题。通过使用 Selenium，我们几乎可以通过各种方法模拟浏览器的操作，而且这种方法是只要浏览器存在就可以使用的。我相信如何观察网页的结构以及利用是非常有用的技能。\n\n## 完整代码\n\n```python\nimport time\nfrom selenium import webdriver\nfrom selenium.webdriver.common.by import By\nfrom selenium.webdriver.support.ui import WebDriverWait\nfrom selenium.webdriver.support import expected_conditions as EC\n\ndriver = webdriver.PhantomJS()\ndriver.get('https://passport.weibo.cn/signin/login')\nWebDriverWait(driver, 20).until(\n    EC.presence_of_element_located((By.ID, 'loginName')))\ntime.sleep(1)\n\nname_field = driver.find_element_by_id('loginName')\nname_field.clear()\nname_field.send_keys('你的用户名')\npassword_field = driver.find_element_by_id('loginPassword')\npassword_field.clear()\npassword_field.send_keys('你的密码')\nsubmit_button = driver.find_element_by_id('loginAction')\nsubmit_button.click()\n\nprint(driver.get_cookies())\n```\n\n","slug":"weibo-login-20lines","published":1,"updated":"2018-07-03T13:44:30.394Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj5repuj000a9pd31zj1bem2","content":"<p>如何登录新浪微博是令许多数据新手（包括我）头疼的大问题。由于新浪的反爬虫策略，网上的教程往往撑不过几个月，查阅到的资料在半年前或是一年前——而它们早就无法使用了，在你想开始爬虫的时候被活生生卡在了第一步。</p>\n<p>简单而言，我使用的方法是通过 Selenium 模拟浏览器的行为，直接在浏览器中输入用户名和密码并登录，然后直接从浏览器中获取 Cookies。虽然听起来十分简单（实际上也十分简单），但是确实是十分有效的方式。只要一个网站能通过浏览器登陆，我们就可以简单改造这个程序来登录并获得想要的资料。</p>\n<h1 id=\"什么是Selenium？如何使用？\"><a href=\"#什么是Selenium？如何使用？\" class=\"headerlink\" title=\"什么是Selenium？如何使用？\"></a>什么是Selenium？如何使用？</h1><p>Selenium 是一个项目的名称，都与浏览器和网页测试相关。主要的工具也就是今天我们所要使用的，是WebDriver，是一个浏览器自动化工具。它为很多不同的语言提供了库，包括 Python、Java、Ruby 等。本文中我选择使用 Python 来进行操作，当然你也可以使用你熟悉的语言来进行操作。</p>\n<p>在 Python中使用 Selenium 只需要通过<code>pip</code>安装 Selenium 提供的 Python 库。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip3 install selenium  # 如果你使用 Python 2 ，请使用 pip install selenium</span><br></pre></td></tr></table></figure>\n<p>仅仅安装 Selenium 本身是不够的，你同时还需要安装 Driver 。你可以将 Driver 理解为浏览器本身的『驱动』，在程序中使用 Driver 就相当于你打开了一个浏览器做了些什么事情。</p>\n<a id=\"more\"></a>\n<p>在这里我们推荐几个 Driver ：</p>\n<ol>\n<li>Firefox: <a href=\"https://github.com/mozilla/geckodriver/releases\" target=\"_blank\" rel=\"noopener\">https://github.com/mozilla/geckodriver/releases</a></li>\n<li>Chrome: <a href=\"https://sites.google.com/a/chromium.org/chromedriver/downloads\" target=\"_blank\" rel=\"noopener\">https://sites.google.com/a/chromium.org/chromedriver/downloads</a></li>\n<li>PhantomJS: <a href=\"http://phantomjs.org/download.html\" target=\"_blank\" rel=\"noopener\">http://phantomjs.org/download.html</a></li>\n</ol>\n<p>（如果你是Windows用户，这部分内容也需要参考：<a href=\"http://selenium-python.readthedocs.io/installation.html#detailed-instructions-for-windows-users）\" target=\"_blank\" rel=\"noopener\">http://selenium-python.readthedocs.io/installation.html#detailed-instructions-for-windows-users）</a></p>\n<p>下载后，我建议将可执行文件加入环境中，以备使用。</p>\n<p>Firefox 和 Chrome 相信大家都比较熟悉。PhantomJS 是一个可以让你无需浏览器就进行网页相关操作的<a href=\"https://zh.wikipedia.org/wiki/WebKit\" target=\"_blank\" rel=\"noopener\">WebKit</a>，它也没有图形界面。个人比较推荐在调试程序期间使用 Firefox 或是 Chrome ，这样你可以通过观察发现自己哪里出了错。在调试完成后使用 PhantomJS ，来避免多余的可视化渲染。</p>\n<h1 id=\"创建一个-WebDriver\"><a href=\"#创建一个-WebDriver\" class=\"headerlink\" title=\"创建一个 WebDriver\"></a>创建一个 WebDriver</h1><p>利用 Selenium 创建 WebDriver 十分简单粗暴：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> selenium <span class=\"keyword\">import</span> webdriver</span><br><span class=\"line\">driver = webdriver.Firefox()  <span class=\"comment\"># 如果 Firefox 所时使用的 geckodriver 在环境中</span></span><br><span class=\"line\"><span class=\"comment\"># driver = webdriver.PhantomJS()  # 如果你想使用 PhantomJS</span></span><br></pre></td></tr></table></figure>\n<p>如果你需要自定义路径，你可以通过传入参数 <code>executable_path</code>：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">driver = webdriver.Firefox(executable_path=<span class=\"string\">\"/path/to/geckodriver\"</span>)</span><br></pre></td></tr></table></figure>\n<p>如果你使用 Firefox 或 Chrome，你会看到这个操作打开一个浏览器。</p>\n<h1 id=\"观察网页本身\"><a href=\"#观察网页本身\" class=\"headerlink\" title=\"观察网页本身\"></a>观察网页本身</h1><p>为了方便演示，我们使用新浪的移动版进行登录。如果想决定如何操作一个网页，首先我们要观察网页本身。</p>\n<p>右键登录的地方并审查元素，你会发现用户名和密码其实是简单的输入框，而登录按钮是一个链接而已。</p>\n<p><img src=\"http://osvlzj5nm.bkt.clouddn.com/17-7-14/91396431.jpg\" alt=\"\"></p>\n<p>因此我们简单规划之后要做的事情：</p>\n<ol>\n<li>输入用户名和密码</li>\n<li>点击登录按钮（或摁回车）</li>\n</ol>\n<h1 id=\"利用-Selenium-进行登录操作\"><a href=\"#利用-Selenium-进行登录操作\" class=\"headerlink\" title=\"利用 Selenium 进行登录操作\"></a>利用 Selenium 进行登录操作</h1><h2 id=\"打开网页\"><a href=\"#打开网页\" class=\"headerlink\" title=\"打开网页\"></a>打开网页</h2><p>Selenium 提供了方法的<code>get</code>方法用以获取网页：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">driver.get(<span class=\"string\">'https://passport.weibo.cn/signin/login'</span>)</span><br></pre></td></tr></table></figure>\n<p>如果你使用 Firefox 或 Chrome，你会看到这个操作打开微博手机版的登录页面。</p>\n<h2 id=\"定位元素\"><a href=\"#定位元素\" class=\"headerlink\" title=\"定位元素\"></a>定位元素</h2><p>由网页本身的结构我们发现，这两个输入框和登录链接元素的<code>id</code>属性都是页面中独一无二的，我们便可以利用这一特点寻找到元素本身。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">name_field = driver.find_element_by_id(<span class=\"string\">'loginName'</span>)  <span class=\"comment\"># 用户名输入框</span></span><br><span class=\"line\">password_field = driver.find_element_by_id(<span class=\"string\">'loginPassword'</span>)  <span class=\"comment\"># 密码输入框</span></span><br><span class=\"line\">submit_button = driver.find_element_by_id(<span class=\"string\">'loginAction'</span>)  <span class=\"comment\"># 登录键</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"输入内容\"><a href=\"#输入内容\" class=\"headerlink\" title=\"输入内容\"></a>输入内容</h2><p>Selenium 提供了为元素输入的方法 <code>send_keys()</code>，直接调用这一方法就可以把内容输入到网页中的输入框内：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">name_field.send_keys(<span class=\"string\">'你的用户名'</span>)</span><br><span class=\"line\">password_field.send_keys(<span class=\"string\">'你的密码'</span>)</span><br></pre></td></tr></table></figure>\n<p>如果你使用 Firefox 或 Chrome ，你会看到页面中的两个输入框被填入你在程序中输入的文字。</p>\n<p>点击按钮的方法也很简单，如果你已经获取了元素，只要使用<code>click()</code>方法：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">submit_button.click()  <span class=\"comment\"># 单击元素</span></span><br></pre></td></tr></table></figure>\n<p>如果你需要使用回车键，可以使用<code>send_keys()</code>来发送回车（<code>Keys.RETURN</code>），我在这里不展开描述。</p>\n<p>如果你担心两个输入框在你输入前就已经有了其他内容而影响操作，你可以使用<code>clear()</code>方法，并且我在这里也更加推荐这样的做法：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">name_field.clear()  <span class=\"comment\"># 清除用户名区域</span></span><br><span class=\"line\">name_field.send_keys(<span class=\"string\">'你的用户名'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">password_field.clear()  <span class=\"comment\"># 清除密码区域</span></span><br><span class=\"line\">password_field.send_keys(<span class=\"string\">'你的密码'</span>)</span><br></pre></td></tr></table></figure>\n<h2 id=\"获取-Cookies\"><a href=\"#获取-Cookies\" class=\"headerlink\" title=\"获取 Cookies\"></a>获取 Cookies</h2><p>从 WebDriver 获取 Cookies 只需要一个操作 <code>get_cookies()</code>：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">driver.get_cookies()</span><br></pre></td></tr></table></figure>\n<p>它是一个字典文件的列表，每一个字典文件是一个 Cookie。如果你们要在其他 WebDriver 或浏览器中使用这组 Cookies ，使用一个循环来给 WebDriver 利用<code>add_cookie</code>方法添加是比较标准的方法：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> cookie <span class=\"keyword\">in</span> driver.get_cookies():</span><br><span class=\"line\">    another_driver.add_cookie(cookie)</span><br></pre></td></tr></table></figure>\n<h2 id=\"等待网页载入\"><a href=\"#等待网页载入\" class=\"headerlink\" title=\"等待网页载入\"></a>等待网页载入</h2><p>如果你仅仅执行上述代码，你会发现如果你的网速不够快，或是电脑不够好，就非常容易在元素出现前就进行操作，然后出现无法找到元素或是元素不可见等错误，我们可以通过等待一段时间来解决这个问题：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> time</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 在获取网页后</span></span><br><span class=\"line\">time.sleep(<span class=\"number\">2</span>) <span class=\"comment\"># 等待2秒</span></span><br></pre></td></tr></table></figure>\n<p>这种做法比较简单，但也十分粗暴：因为你无法确定2秒时间足够让网页加载完成。每次打开网页的时间受限于许多因素，你可能很难用一个固定的时间来决定。而 Selenium 本身也提供了一些好用的方法：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> selenium.webdriver.common.by <span class=\"keyword\">import</span> By</span><br><span class=\"line\"><span class=\"keyword\">from</span> selenium.webdriver.support.ui <span class=\"keyword\">import</span> WebDriverWait</span><br><span class=\"line\"><span class=\"keyword\">from</span> selenium.webdriver.support <span class=\"keyword\">import</span> expected_conditions <span class=\"keyword\">as</span> EC</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 在获取网页后</span></span><br><span class=\"line\">WebDriverWait(driver, <span class=\"number\">20</span>).until(</span><br><span class=\"line\">    EC.presence_of_element_located((By.ID, <span class=\"string\">'loginName'</span>))) </span><br><span class=\"line\"><span class=\"comment\"># 等待 id 为 loginName的元素出现，最多20秒</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h1><p>如何登录网站对于收集数据的人而言是个不大不小的问题。通过使用 Selenium，我们几乎可以通过各种方法模拟浏览器的操作，而且这种方法是只要浏览器存在就可以使用的。我相信如何观察网页的结构以及利用是非常有用的技能。</p>\n<h2 id=\"完整代码\"><a href=\"#完整代码\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> time</span><br><span class=\"line\"><span class=\"keyword\">from</span> selenium <span class=\"keyword\">import</span> webdriver</span><br><span class=\"line\"><span class=\"keyword\">from</span> selenium.webdriver.common.by <span class=\"keyword\">import</span> By</span><br><span class=\"line\"><span class=\"keyword\">from</span> selenium.webdriver.support.ui <span class=\"keyword\">import</span> WebDriverWait</span><br><span class=\"line\"><span class=\"keyword\">from</span> selenium.webdriver.support <span class=\"keyword\">import</span> expected_conditions <span class=\"keyword\">as</span> EC</span><br><span class=\"line\"></span><br><span class=\"line\">driver = webdriver.PhantomJS()</span><br><span class=\"line\">driver.get(<span class=\"string\">'https://passport.weibo.cn/signin/login'</span>)</span><br><span class=\"line\">WebDriverWait(driver, <span class=\"number\">20</span>).until(</span><br><span class=\"line\">    EC.presence_of_element_located((By.ID, <span class=\"string\">'loginName'</span>)))</span><br><span class=\"line\">time.sleep(<span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">name_field = driver.find_element_by_id(<span class=\"string\">'loginName'</span>)</span><br><span class=\"line\">name_field.clear()</span><br><span class=\"line\">name_field.send_keys(<span class=\"string\">'你的用户名'</span>)</span><br><span class=\"line\">password_field = driver.find_element_by_id(<span class=\"string\">'loginPassword'</span>)</span><br><span class=\"line\">password_field.clear()</span><br><span class=\"line\">password_field.send_keys(<span class=\"string\">'你的密码'</span>)</span><br><span class=\"line\">submit_button = driver.find_element_by_id(<span class=\"string\">'loginAction'</span>)</span><br><span class=\"line\">submit_button.click()</span><br><span class=\"line\"></span><br><span class=\"line\">print(driver.get_cookies())</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>如何登录新浪微博是令许多数据新手（包括我）头疼的大问题。由于新浪的反爬虫策略，网上的教程往往撑不过几个月，查阅到的资料在半年前或是一年前——而它们早就无法使用了，在你想开始爬虫的时候被活生生卡在了第一步。</p>\n<p>简单而言，我使用的方法是通过 Selenium 模拟浏览器的行为，直接在浏览器中输入用户名和密码并登录，然后直接从浏览器中获取 Cookies。虽然听起来十分简单（实际上也十分简单），但是确实是十分有效的方式。只要一个网站能通过浏览器登陆，我们就可以简单改造这个程序来登录并获得想要的资料。</p>\n<h1 id=\"什么是Selenium？如何使用？\"><a href=\"#什么是Selenium？如何使用？\" class=\"headerlink\" title=\"什么是Selenium？如何使用？\"></a>什么是Selenium？如何使用？</h1><p>Selenium 是一个项目的名称，都与浏览器和网页测试相关。主要的工具也就是今天我们所要使用的，是WebDriver，是一个浏览器自动化工具。它为很多不同的语言提供了库，包括 Python、Java、Ruby 等。本文中我选择使用 Python 来进行操作，当然你也可以使用你熟悉的语言来进行操作。</p>\n<p>在 Python中使用 Selenium 只需要通过<code>pip</code>安装 Selenium 提供的 Python 库。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip3 install selenium  # 如果你使用 Python 2 ，请使用 pip install selenium</span><br></pre></td></tr></table></figure>\n<p>仅仅安装 Selenium 本身是不够的，你同时还需要安装 Driver 。你可以将 Driver 理解为浏览器本身的『驱动』，在程序中使用 Driver 就相当于你打开了一个浏览器做了些什么事情。</p>","more":"<p>在这里我们推荐几个 Driver ：</p>\n<ol>\n<li>Firefox: <a href=\"https://github.com/mozilla/geckodriver/releases\" target=\"_blank\" rel=\"noopener\">https://github.com/mozilla/geckodriver/releases</a></li>\n<li>Chrome: <a href=\"https://sites.google.com/a/chromium.org/chromedriver/downloads\" target=\"_blank\" rel=\"noopener\">https://sites.google.com/a/chromium.org/chromedriver/downloads</a></li>\n<li>PhantomJS: <a href=\"http://phantomjs.org/download.html\" target=\"_blank\" rel=\"noopener\">http://phantomjs.org/download.html</a></li>\n</ol>\n<p>（如果你是Windows用户，这部分内容也需要参考：<a href=\"http://selenium-python.readthedocs.io/installation.html#detailed-instructions-for-windows-users）\" target=\"_blank\" rel=\"noopener\">http://selenium-python.readthedocs.io/installation.html#detailed-instructions-for-windows-users）</a></p>\n<p>下载后，我建议将可执行文件加入环境中，以备使用。</p>\n<p>Firefox 和 Chrome 相信大家都比较熟悉。PhantomJS 是一个可以让你无需浏览器就进行网页相关操作的<a href=\"https://zh.wikipedia.org/wiki/WebKit\" target=\"_blank\" rel=\"noopener\">WebKit</a>，它也没有图形界面。个人比较推荐在调试程序期间使用 Firefox 或是 Chrome ，这样你可以通过观察发现自己哪里出了错。在调试完成后使用 PhantomJS ，来避免多余的可视化渲染。</p>\n<h1 id=\"创建一个-WebDriver\"><a href=\"#创建一个-WebDriver\" class=\"headerlink\" title=\"创建一个 WebDriver\"></a>创建一个 WebDriver</h1><p>利用 Selenium 创建 WebDriver 十分简单粗暴：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> selenium <span class=\"keyword\">import</span> webdriver</span><br><span class=\"line\">driver = webdriver.Firefox()  <span class=\"comment\"># 如果 Firefox 所时使用的 geckodriver 在环境中</span></span><br><span class=\"line\"><span class=\"comment\"># driver = webdriver.PhantomJS()  # 如果你想使用 PhantomJS</span></span><br></pre></td></tr></table></figure>\n<p>如果你需要自定义路径，你可以通过传入参数 <code>executable_path</code>：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">driver = webdriver.Firefox(executable_path=<span class=\"string\">\"/path/to/geckodriver\"</span>)</span><br></pre></td></tr></table></figure>\n<p>如果你使用 Firefox 或 Chrome，你会看到这个操作打开一个浏览器。</p>\n<h1 id=\"观察网页本身\"><a href=\"#观察网页本身\" class=\"headerlink\" title=\"观察网页本身\"></a>观察网页本身</h1><p>为了方便演示，我们使用新浪的移动版进行登录。如果想决定如何操作一个网页，首先我们要观察网页本身。</p>\n<p>右键登录的地方并审查元素，你会发现用户名和密码其实是简单的输入框，而登录按钮是一个链接而已。</p>\n<p><img src=\"http://osvlzj5nm.bkt.clouddn.com/17-7-14/91396431.jpg\" alt=\"\"></p>\n<p>因此我们简单规划之后要做的事情：</p>\n<ol>\n<li>输入用户名和密码</li>\n<li>点击登录按钮（或摁回车）</li>\n</ol>\n<h1 id=\"利用-Selenium-进行登录操作\"><a href=\"#利用-Selenium-进行登录操作\" class=\"headerlink\" title=\"利用 Selenium 进行登录操作\"></a>利用 Selenium 进行登录操作</h1><h2 id=\"打开网页\"><a href=\"#打开网页\" class=\"headerlink\" title=\"打开网页\"></a>打开网页</h2><p>Selenium 提供了方法的<code>get</code>方法用以获取网页：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">driver.get(<span class=\"string\">'https://passport.weibo.cn/signin/login'</span>)</span><br></pre></td></tr></table></figure>\n<p>如果你使用 Firefox 或 Chrome，你会看到这个操作打开微博手机版的登录页面。</p>\n<h2 id=\"定位元素\"><a href=\"#定位元素\" class=\"headerlink\" title=\"定位元素\"></a>定位元素</h2><p>由网页本身的结构我们发现，这两个输入框和登录链接元素的<code>id</code>属性都是页面中独一无二的，我们便可以利用这一特点寻找到元素本身。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">name_field = driver.find_element_by_id(<span class=\"string\">'loginName'</span>)  <span class=\"comment\"># 用户名输入框</span></span><br><span class=\"line\">password_field = driver.find_element_by_id(<span class=\"string\">'loginPassword'</span>)  <span class=\"comment\"># 密码输入框</span></span><br><span class=\"line\">submit_button = driver.find_element_by_id(<span class=\"string\">'loginAction'</span>)  <span class=\"comment\"># 登录键</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"输入内容\"><a href=\"#输入内容\" class=\"headerlink\" title=\"输入内容\"></a>输入内容</h2><p>Selenium 提供了为元素输入的方法 <code>send_keys()</code>，直接调用这一方法就可以把内容输入到网页中的输入框内：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">name_field.send_keys(<span class=\"string\">'你的用户名'</span>)</span><br><span class=\"line\">password_field.send_keys(<span class=\"string\">'你的密码'</span>)</span><br></pre></td></tr></table></figure>\n<p>如果你使用 Firefox 或 Chrome ，你会看到页面中的两个输入框被填入你在程序中输入的文字。</p>\n<p>点击按钮的方法也很简单，如果你已经获取了元素，只要使用<code>click()</code>方法：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">submit_button.click()  <span class=\"comment\"># 单击元素</span></span><br></pre></td></tr></table></figure>\n<p>如果你需要使用回车键，可以使用<code>send_keys()</code>来发送回车（<code>Keys.RETURN</code>），我在这里不展开描述。</p>\n<p>如果你担心两个输入框在你输入前就已经有了其他内容而影响操作，你可以使用<code>clear()</code>方法，并且我在这里也更加推荐这样的做法：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">name_field.clear()  <span class=\"comment\"># 清除用户名区域</span></span><br><span class=\"line\">name_field.send_keys(<span class=\"string\">'你的用户名'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">password_field.clear()  <span class=\"comment\"># 清除密码区域</span></span><br><span class=\"line\">password_field.send_keys(<span class=\"string\">'你的密码'</span>)</span><br></pre></td></tr></table></figure>\n<h2 id=\"获取-Cookies\"><a href=\"#获取-Cookies\" class=\"headerlink\" title=\"获取 Cookies\"></a>获取 Cookies</h2><p>从 WebDriver 获取 Cookies 只需要一个操作 <code>get_cookies()</code>：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">driver.get_cookies()</span><br></pre></td></tr></table></figure>\n<p>它是一个字典文件的列表，每一个字典文件是一个 Cookie。如果你们要在其他 WebDriver 或浏览器中使用这组 Cookies ，使用一个循环来给 WebDriver 利用<code>add_cookie</code>方法添加是比较标准的方法：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> cookie <span class=\"keyword\">in</span> driver.get_cookies():</span><br><span class=\"line\">    another_driver.add_cookie(cookie)</span><br></pre></td></tr></table></figure>\n<h2 id=\"等待网页载入\"><a href=\"#等待网页载入\" class=\"headerlink\" title=\"等待网页载入\"></a>等待网页载入</h2><p>如果你仅仅执行上述代码，你会发现如果你的网速不够快，或是电脑不够好，就非常容易在元素出现前就进行操作，然后出现无法找到元素或是元素不可见等错误，我们可以通过等待一段时间来解决这个问题：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> time</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 在获取网页后</span></span><br><span class=\"line\">time.sleep(<span class=\"number\">2</span>) <span class=\"comment\"># 等待2秒</span></span><br></pre></td></tr></table></figure>\n<p>这种做法比较简单，但也十分粗暴：因为你无法确定2秒时间足够让网页加载完成。每次打开网页的时间受限于许多因素，你可能很难用一个固定的时间来决定。而 Selenium 本身也提供了一些好用的方法：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> selenium.webdriver.common.by <span class=\"keyword\">import</span> By</span><br><span class=\"line\"><span class=\"keyword\">from</span> selenium.webdriver.support.ui <span class=\"keyword\">import</span> WebDriverWait</span><br><span class=\"line\"><span class=\"keyword\">from</span> selenium.webdriver.support <span class=\"keyword\">import</span> expected_conditions <span class=\"keyword\">as</span> EC</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 在获取网页后</span></span><br><span class=\"line\">WebDriverWait(driver, <span class=\"number\">20</span>).until(</span><br><span class=\"line\">    EC.presence_of_element_located((By.ID, <span class=\"string\">'loginName'</span>))) </span><br><span class=\"line\"><span class=\"comment\"># 等待 id 为 loginName的元素出现，最多20秒</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h1><p>如何登录网站对于收集数据的人而言是个不大不小的问题。通过使用 Selenium，我们几乎可以通过各种方法模拟浏览器的操作，而且这种方法是只要浏览器存在就可以使用的。我相信如何观察网页的结构以及利用是非常有用的技能。</p>\n<h2 id=\"完整代码\"><a href=\"#完整代码\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> time</span><br><span class=\"line\"><span class=\"keyword\">from</span> selenium <span class=\"keyword\">import</span> webdriver</span><br><span class=\"line\"><span class=\"keyword\">from</span> selenium.webdriver.common.by <span class=\"keyword\">import</span> By</span><br><span class=\"line\"><span class=\"keyword\">from</span> selenium.webdriver.support.ui <span class=\"keyword\">import</span> WebDriverWait</span><br><span class=\"line\"><span class=\"keyword\">from</span> selenium.webdriver.support <span class=\"keyword\">import</span> expected_conditions <span class=\"keyword\">as</span> EC</span><br><span class=\"line\"></span><br><span class=\"line\">driver = webdriver.PhantomJS()</span><br><span class=\"line\">driver.get(<span class=\"string\">'https://passport.weibo.cn/signin/login'</span>)</span><br><span class=\"line\">WebDriverWait(driver, <span class=\"number\">20</span>).until(</span><br><span class=\"line\">    EC.presence_of_element_located((By.ID, <span class=\"string\">'loginName'</span>)))</span><br><span class=\"line\">time.sleep(<span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">name_field = driver.find_element_by_id(<span class=\"string\">'loginName'</span>)</span><br><span class=\"line\">name_field.clear()</span><br><span class=\"line\">name_field.send_keys(<span class=\"string\">'你的用户名'</span>)</span><br><span class=\"line\">password_field = driver.find_element_by_id(<span class=\"string\">'loginPassword'</span>)</span><br><span class=\"line\">password_field.clear()</span><br><span class=\"line\">password_field.send_keys(<span class=\"string\">'你的密码'</span>)</span><br><span class=\"line\">submit_button = driver.find_element_by_id(<span class=\"string\">'loginAction'</span>)</span><br><span class=\"line\">submit_button.click()</span><br><span class=\"line\"></span><br><span class=\"line\">print(driver.get_cookies())</span><br></pre></td></tr></table></figure>"},{"title":"youtube-dl：一个命令行视频下载利器","date":"2017-07-05T16:00:00.000Z","_content":"\nyoutube-dl 的官网：http://rg3.github.io/youtube-dl/index.html\n\nyoutube-dl 的 GitHub 页面：https://github.com/rg3/youtube-dl（喜欢的话给作者star哦~）\n\n## Youtube-dl 有什么用？\n\nyoutube-dl 是一个命令行工具，对我所知的[大部分视频网站](https://github.com/rg3/youtube-dl/tree/master/youtube_dl/extractor)有不错的支持，你可以选择下载视频，或是将视频流直接导出到自己想使用的播放器中，也可以以JSON的形式获取可下载资源的URL。\n\n使用方便、足够简洁，这是我在这里推荐的理由。\n\n\n\n## 安装 Youtube-dl\n\nYoutube-dl 通过 PyPi 分发，如果你的系统安装有 `pip3` 或 `pip` ，请直接使用：\n\n```shell\nsudo pip install --upgrade youtube_dl # 或pip3\n```\n\n如果你是 macOS 用户，也可以使用：\n\n```shell\nbrew install youtube-dl\n```\n\n官网上的[这个页面](http://rg3.github.io/youtube-dl/download.html)还提供了 Windows 可用的 exe 和直接通过 curl 或 wget 安装的方法。\n\n\n\n## 利用 Youtube-dl 下载\n\n#### 普通下载\n\n通过 Youtube-dl 下载视频十分简洁，例如你需要下载http://www.bilibili.com/video/av11728123/ 你可以这样：\n\n```shell\nyoutube-dl 'http://www.bilibili.com/video/av11728123/'\n```\n\n<!--more-->\n\n你会得到这样的结果：\n\n```\n[BiliBili] 11728123: Downloading webpage\n[BiliBili] 11728123: Downloading video info page\n[download] Destination: 【全明星freestyle】音浪-11728123.mp4\n[download] 100% of 9.07MiB in 00:01\n```\n\n如果你不进行任何特殊的指定，它会分析网页、自动选择默认画质并下载至`Destination`显示的文件中。\n\n\n\n#### 输出文件的名字\n\n如果你想指定输出文件的名字（有时对批量下载的人来说十分重要），你可以使用`-o`：\n\n```shell\nyoutube-dl 'http://www.bilibili.com/video/av11728123/' -o '你要的名字'\n# 下载至文件：你要的名字 (无后缀)\n```\n\n当然，请注意你选择的名字的拓展名，youtube-dl 并不会自动修改你所指定的后缀名。youtube-dl 同时也支持 [OUTPUT TEMPLATE](https://github.com/rg3/youtube-dl#output-template)，你可以利用 `%(title)s`等参数（参考 Python 的字符串形式）将文件命名，例如：\n\n```shell\nyoutube-dl 'http://www.bilibili.com/video/av11728123/' -o '%(title)s.%(ext)s'\n# 下载至文件：【全明星freestyle】音浪.mp4\n```\n\n\n\n#### 使用代理下载\n\nyoutube-dl 提供了使用代理的参数，你可以简单地将自己代理的地址填入：\n\n```shell\nyoutube-dl --proxy 127.0.0.1:1087 'https://www.youtube.com/watch\\?v\\=_fc_TLg3eQ4'\n# 成功通过ss在国内下载某不存在网站的视频\n```\n\n如果你不清楚如何使用自己的代理网址，请询问你的代理提供商。\n\n\n\n#### 将流文件直接转发到播放器\n\n你可以使用标准输入输出进行这一操作，下面是使用 vlc 播放的方法：\n\n```shell\nyoutube-dl -o - \"https://www.youtube.com/watch\\?v\\=_fc_TLg3eQ4\" | vlc -\n```\n\n\n\n#### 其他下载选项\n\nyoutube-dl 还提供很多其他的下载选项，如挑选合适的分辨率，下载一个播放列表等，你可以研究并自定义如何下载一个文件。\n\n\n\n## 国内的 youtube-dl： You-Get\n\nYou-Get的GitHub地址：https://github.com/soimort/you-get\n\n事实上而言，我发现You-Get对国内视频网站的支持更加全面，但是由于作者已经有大约两个月的时间没有维护了，我在这里不作推荐。但是如果你遇到无法使用youtube-dl下载的视频页面，不妨试试这个同类小工具。","source":"_posts/youtube-dl.md","raw":"---\ntitle: youtube-dl：一个命令行视频下载利器\ndate: 2017-07-06\ncategory: 软件推荐\ntags: \n- 软件\n- 命令行\n---\n\nyoutube-dl 的官网：http://rg3.github.io/youtube-dl/index.html\n\nyoutube-dl 的 GitHub 页面：https://github.com/rg3/youtube-dl（喜欢的话给作者star哦~）\n\n## Youtube-dl 有什么用？\n\nyoutube-dl 是一个命令行工具，对我所知的[大部分视频网站](https://github.com/rg3/youtube-dl/tree/master/youtube_dl/extractor)有不错的支持，你可以选择下载视频，或是将视频流直接导出到自己想使用的播放器中，也可以以JSON的形式获取可下载资源的URL。\n\n使用方便、足够简洁，这是我在这里推荐的理由。\n\n\n\n## 安装 Youtube-dl\n\nYoutube-dl 通过 PyPi 分发，如果你的系统安装有 `pip3` 或 `pip` ，请直接使用：\n\n```shell\nsudo pip install --upgrade youtube_dl # 或pip3\n```\n\n如果你是 macOS 用户，也可以使用：\n\n```shell\nbrew install youtube-dl\n```\n\n官网上的[这个页面](http://rg3.github.io/youtube-dl/download.html)还提供了 Windows 可用的 exe 和直接通过 curl 或 wget 安装的方法。\n\n\n\n## 利用 Youtube-dl 下载\n\n#### 普通下载\n\n通过 Youtube-dl 下载视频十分简洁，例如你需要下载http://www.bilibili.com/video/av11728123/ 你可以这样：\n\n```shell\nyoutube-dl 'http://www.bilibili.com/video/av11728123/'\n```\n\n<!--more-->\n\n你会得到这样的结果：\n\n```\n[BiliBili] 11728123: Downloading webpage\n[BiliBili] 11728123: Downloading video info page\n[download] Destination: 【全明星freestyle】音浪-11728123.mp4\n[download] 100% of 9.07MiB in 00:01\n```\n\n如果你不进行任何特殊的指定，它会分析网页、自动选择默认画质并下载至`Destination`显示的文件中。\n\n\n\n#### 输出文件的名字\n\n如果你想指定输出文件的名字（有时对批量下载的人来说十分重要），你可以使用`-o`：\n\n```shell\nyoutube-dl 'http://www.bilibili.com/video/av11728123/' -o '你要的名字'\n# 下载至文件：你要的名字 (无后缀)\n```\n\n当然，请注意你选择的名字的拓展名，youtube-dl 并不会自动修改你所指定的后缀名。youtube-dl 同时也支持 [OUTPUT TEMPLATE](https://github.com/rg3/youtube-dl#output-template)，你可以利用 `%(title)s`等参数（参考 Python 的字符串形式）将文件命名，例如：\n\n```shell\nyoutube-dl 'http://www.bilibili.com/video/av11728123/' -o '%(title)s.%(ext)s'\n# 下载至文件：【全明星freestyle】音浪.mp4\n```\n\n\n\n#### 使用代理下载\n\nyoutube-dl 提供了使用代理的参数，你可以简单地将自己代理的地址填入：\n\n```shell\nyoutube-dl --proxy 127.0.0.1:1087 'https://www.youtube.com/watch\\?v\\=_fc_TLg3eQ4'\n# 成功通过ss在国内下载某不存在网站的视频\n```\n\n如果你不清楚如何使用自己的代理网址，请询问你的代理提供商。\n\n\n\n#### 将流文件直接转发到播放器\n\n你可以使用标准输入输出进行这一操作，下面是使用 vlc 播放的方法：\n\n```shell\nyoutube-dl -o - \"https://www.youtube.com/watch\\?v\\=_fc_TLg3eQ4\" | vlc -\n```\n\n\n\n#### 其他下载选项\n\nyoutube-dl 还提供很多其他的下载选项，如挑选合适的分辨率，下载一个播放列表等，你可以研究并自定义如何下载一个文件。\n\n\n\n## 国内的 youtube-dl： You-Get\n\nYou-Get的GitHub地址：https://github.com/soimort/you-get\n\n事实上而言，我发现You-Get对国内视频网站的支持更加全面，但是由于作者已经有大约两个月的时间没有维护了，我在这里不作推荐。但是如果你遇到无法使用youtube-dl下载的视频页面，不妨试试这个同类小工具。","slug":"youtube-dl","published":1,"updated":"2018-07-03T13:44:30.394Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj5repum000e9pd3ywmjtr5r","content":"<p>youtube-dl 的官网：<a href=\"http://rg3.github.io/youtube-dl/index.html\" target=\"_blank\" rel=\"noopener\">http://rg3.github.io/youtube-dl/index.html</a></p>\n<p>youtube-dl 的 GitHub 页面：<a href=\"https://github.com/rg3/youtube-dl（喜欢的话给作者star哦~）\" target=\"_blank\" rel=\"noopener\">https://github.com/rg3/youtube-dl（喜欢的话给作者star哦~）</a></p>\n<h2 id=\"Youtube-dl-有什么用？\"><a href=\"#Youtube-dl-有什么用？\" class=\"headerlink\" title=\"Youtube-dl 有什么用？\"></a>Youtube-dl 有什么用？</h2><p>youtube-dl 是一个命令行工具，对我所知的<a href=\"https://github.com/rg3/youtube-dl/tree/master/youtube_dl/extractor\" target=\"_blank\" rel=\"noopener\">大部分视频网站</a>有不错的支持，你可以选择下载视频，或是将视频流直接导出到自己想使用的播放器中，也可以以JSON的形式获取可下载资源的URL。</p>\n<p>使用方便、足够简洁，这是我在这里推荐的理由。</p>\n<h2 id=\"安装-Youtube-dl\"><a href=\"#安装-Youtube-dl\" class=\"headerlink\" title=\"安装 Youtube-dl\"></a>安装 Youtube-dl</h2><p>Youtube-dl 通过 PyPi 分发，如果你的系统安装有 <code>pip3</code> 或 <code>pip</code> ，请直接使用：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo pip install --upgrade youtube_dl # 或pip3</span><br></pre></td></tr></table></figure>\n<p>如果你是 macOS 用户，也可以使用：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew install youtube-dl</span><br></pre></td></tr></table></figure>\n<p>官网上的<a href=\"http://rg3.github.io/youtube-dl/download.html\" target=\"_blank\" rel=\"noopener\">这个页面</a>还提供了 Windows 可用的 exe 和直接通过 curl 或 wget 安装的方法。</p>\n<h2 id=\"利用-Youtube-dl-下载\"><a href=\"#利用-Youtube-dl-下载\" class=\"headerlink\" title=\"利用 Youtube-dl 下载\"></a>利用 Youtube-dl 下载</h2><h4 id=\"普通下载\"><a href=\"#普通下载\" class=\"headerlink\" title=\"普通下载\"></a>普通下载</h4><p>通过 Youtube-dl 下载视频十分简洁，例如你需要下载<a href=\"http://www.bilibili.com/video/av11728123/\" target=\"_blank\" rel=\"noopener\">http://www.bilibili.com/video/av11728123/</a> 你可以这样：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">youtube-dl 'http://www.bilibili.com/video/av11728123/'</span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<p>你会得到这样的结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[BiliBili] 11728123: Downloading webpage</span><br><span class=\"line\">[BiliBili] 11728123: Downloading video info page</span><br><span class=\"line\">[download] Destination: 【全明星freestyle】音浪-11728123.mp4</span><br><span class=\"line\">[download] 100% of 9.07MiB in 00:01</span><br></pre></td></tr></table></figure>\n<p>如果你不进行任何特殊的指定，它会分析网页、自动选择默认画质并下载至<code>Destination</code>显示的文件中。</p>\n<h4 id=\"输出文件的名字\"><a href=\"#输出文件的名字\" class=\"headerlink\" title=\"输出文件的名字\"></a>输出文件的名字</h4><p>如果你想指定输出文件的名字（有时对批量下载的人来说十分重要），你可以使用<code>-o</code>：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">youtube-dl 'http://www.bilibili.com/video/av11728123/' -o '你要的名字'</span><br><span class=\"line\"><span class=\"meta\">#</span> 下载至文件：你要的名字 (无后缀)</span><br></pre></td></tr></table></figure>\n<p>当然，请注意你选择的名字的拓展名，youtube-dl 并不会自动修改你所指定的后缀名。youtube-dl 同时也支持 <a href=\"https://github.com/rg3/youtube-dl#output-template\" target=\"_blank\" rel=\"noopener\">OUTPUT TEMPLATE</a>，你可以利用 <code>%(title)s</code>等参数（参考 Python 的字符串形式）将文件命名，例如：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">youtube-dl 'http://www.bilibili.com/video/av11728123/' -o '%(title)s.%(ext)s'</span><br><span class=\"line\"><span class=\"meta\">#</span> 下载至文件：【全明星freestyle】音浪.mp4</span><br></pre></td></tr></table></figure>\n<h4 id=\"使用代理下载\"><a href=\"#使用代理下载\" class=\"headerlink\" title=\"使用代理下载\"></a>使用代理下载</h4><p>youtube-dl 提供了使用代理的参数，你可以简单地将自己代理的地址填入：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">youtube-dl --proxy 127.0.0.1:1087 'https://www.youtube.com/watch\\?v\\=_fc_TLg3eQ4'</span><br><span class=\"line\"><span class=\"meta\">#</span> 成功通过ss在国内下载某不存在网站的视频</span><br></pre></td></tr></table></figure>\n<p>如果你不清楚如何使用自己的代理网址，请询问你的代理提供商。</p>\n<h4 id=\"将流文件直接转发到播放器\"><a href=\"#将流文件直接转发到播放器\" class=\"headerlink\" title=\"将流文件直接转发到播放器\"></a>将流文件直接转发到播放器</h4><p>你可以使用标准输入输出进行这一操作，下面是使用 vlc 播放的方法：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">youtube-dl -o - \"https://www.youtube.com/watch\\?v\\=_fc_TLg3eQ4\" | vlc -</span><br></pre></td></tr></table></figure>\n<h4 id=\"其他下载选项\"><a href=\"#其他下载选项\" class=\"headerlink\" title=\"其他下载选项\"></a>其他下载选项</h4><p>youtube-dl 还提供很多其他的下载选项，如挑选合适的分辨率，下载一个播放列表等，你可以研究并自定义如何下载一个文件。</p>\n<h2 id=\"国内的-youtube-dl：-You-Get\"><a href=\"#国内的-youtube-dl：-You-Get\" class=\"headerlink\" title=\"国内的 youtube-dl： You-Get\"></a>国内的 youtube-dl： You-Get</h2><p>You-Get的GitHub地址：<a href=\"https://github.com/soimort/you-get\" target=\"_blank\" rel=\"noopener\">https://github.com/soimort/you-get</a></p>\n<p>事实上而言，我发现You-Get对国内视频网站的支持更加全面，但是由于作者已经有大约两个月的时间没有维护了，我在这里不作推荐。但是如果你遇到无法使用youtube-dl下载的视频页面，不妨试试这个同类小工具。</p>\n","site":{"data":{}},"excerpt":"<p>youtube-dl 的官网：<a href=\"http://rg3.github.io/youtube-dl/index.html\" target=\"_blank\" rel=\"noopener\">http://rg3.github.io/youtube-dl/index.html</a></p>\n<p>youtube-dl 的 GitHub 页面：<a href=\"https://github.com/rg3/youtube-dl（喜欢的话给作者star哦~）\" target=\"_blank\" rel=\"noopener\">https://github.com/rg3/youtube-dl（喜欢的话给作者star哦~）</a></p>\n<h2 id=\"Youtube-dl-有什么用？\"><a href=\"#Youtube-dl-有什么用？\" class=\"headerlink\" title=\"Youtube-dl 有什么用？\"></a>Youtube-dl 有什么用？</h2><p>youtube-dl 是一个命令行工具，对我所知的<a href=\"https://github.com/rg3/youtube-dl/tree/master/youtube_dl/extractor\" target=\"_blank\" rel=\"noopener\">大部分视频网站</a>有不错的支持，你可以选择下载视频，或是将视频流直接导出到自己想使用的播放器中，也可以以JSON的形式获取可下载资源的URL。</p>\n<p>使用方便、足够简洁，这是我在这里推荐的理由。</p>\n<h2 id=\"安装-Youtube-dl\"><a href=\"#安装-Youtube-dl\" class=\"headerlink\" title=\"安装 Youtube-dl\"></a>安装 Youtube-dl</h2><p>Youtube-dl 通过 PyPi 分发，如果你的系统安装有 <code>pip3</code> 或 <code>pip</code> ，请直接使用：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo pip install --upgrade youtube_dl # 或pip3</span><br></pre></td></tr></table></figure>\n<p>如果你是 macOS 用户，也可以使用：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew install youtube-dl</span><br></pre></td></tr></table></figure>\n<p>官网上的<a href=\"http://rg3.github.io/youtube-dl/download.html\" target=\"_blank\" rel=\"noopener\">这个页面</a>还提供了 Windows 可用的 exe 和直接通过 curl 或 wget 安装的方法。</p>\n<h2 id=\"利用-Youtube-dl-下载\"><a href=\"#利用-Youtube-dl-下载\" class=\"headerlink\" title=\"利用 Youtube-dl 下载\"></a>利用 Youtube-dl 下载</h2><h4 id=\"普通下载\"><a href=\"#普通下载\" class=\"headerlink\" title=\"普通下载\"></a>普通下载</h4><p>通过 Youtube-dl 下载视频十分简洁，例如你需要下载<a href=\"http://www.bilibili.com/video/av11728123/\" target=\"_blank\" rel=\"noopener\">http://www.bilibili.com/video/av11728123/</a> 你可以这样：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">youtube-dl 'http://www.bilibili.com/video/av11728123/'</span><br></pre></td></tr></table></figure>","more":"<p>你会得到这样的结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[BiliBili] 11728123: Downloading webpage</span><br><span class=\"line\">[BiliBili] 11728123: Downloading video info page</span><br><span class=\"line\">[download] Destination: 【全明星freestyle】音浪-11728123.mp4</span><br><span class=\"line\">[download] 100% of 9.07MiB in 00:01</span><br></pre></td></tr></table></figure>\n<p>如果你不进行任何特殊的指定，它会分析网页、自动选择默认画质并下载至<code>Destination</code>显示的文件中。</p>\n<h4 id=\"输出文件的名字\"><a href=\"#输出文件的名字\" class=\"headerlink\" title=\"输出文件的名字\"></a>输出文件的名字</h4><p>如果你想指定输出文件的名字（有时对批量下载的人来说十分重要），你可以使用<code>-o</code>：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">youtube-dl 'http://www.bilibili.com/video/av11728123/' -o '你要的名字'</span><br><span class=\"line\"><span class=\"meta\">#</span> 下载至文件：你要的名字 (无后缀)</span><br></pre></td></tr></table></figure>\n<p>当然，请注意你选择的名字的拓展名，youtube-dl 并不会自动修改你所指定的后缀名。youtube-dl 同时也支持 <a href=\"https://github.com/rg3/youtube-dl#output-template\" target=\"_blank\" rel=\"noopener\">OUTPUT TEMPLATE</a>，你可以利用 <code>%(title)s</code>等参数（参考 Python 的字符串形式）将文件命名，例如：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">youtube-dl 'http://www.bilibili.com/video/av11728123/' -o '%(title)s.%(ext)s'</span><br><span class=\"line\"><span class=\"meta\">#</span> 下载至文件：【全明星freestyle】音浪.mp4</span><br></pre></td></tr></table></figure>\n<h4 id=\"使用代理下载\"><a href=\"#使用代理下载\" class=\"headerlink\" title=\"使用代理下载\"></a>使用代理下载</h4><p>youtube-dl 提供了使用代理的参数，你可以简单地将自己代理的地址填入：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">youtube-dl --proxy 127.0.0.1:1087 'https://www.youtube.com/watch\\?v\\=_fc_TLg3eQ4'</span><br><span class=\"line\"><span class=\"meta\">#</span> 成功通过ss在国内下载某不存在网站的视频</span><br></pre></td></tr></table></figure>\n<p>如果你不清楚如何使用自己的代理网址，请询问你的代理提供商。</p>\n<h4 id=\"将流文件直接转发到播放器\"><a href=\"#将流文件直接转发到播放器\" class=\"headerlink\" title=\"将流文件直接转发到播放器\"></a>将流文件直接转发到播放器</h4><p>你可以使用标准输入输出进行这一操作，下面是使用 vlc 播放的方法：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">youtube-dl -o - \"https://www.youtube.com/watch\\?v\\=_fc_TLg3eQ4\" | vlc -</span><br></pre></td></tr></table></figure>\n<h4 id=\"其他下载选项\"><a href=\"#其他下载选项\" class=\"headerlink\" title=\"其他下载选项\"></a>其他下载选项</h4><p>youtube-dl 还提供很多其他的下载选项，如挑选合适的分辨率，下载一个播放列表等，你可以研究并自定义如何下载一个文件。</p>\n<h2 id=\"国内的-youtube-dl：-You-Get\"><a href=\"#国内的-youtube-dl：-You-Get\" class=\"headerlink\" title=\"国内的 youtube-dl： You-Get\"></a>国内的 youtube-dl： You-Get</h2><p>You-Get的GitHub地址：<a href=\"https://github.com/soimort/you-get\" target=\"_blank\" rel=\"noopener\">https://github.com/soimort/you-get</a></p>\n<p>事实上而言，我发现You-Get对国内视频网站的支持更加全面，但是由于作者已经有大约两个月的时间没有维护了，我在这里不作推荐。但是如果你遇到无法使用youtube-dl下载的视频页面，不妨试试这个同类小工具。</p>"},{"title":"第一次的机器学习：机器学习基础概念和名词","date":"2017-07-29T16:00:00.000Z","_content":"\n\n\n尽管机器学习从分类上而言只是人工智能（也就是常说的AI）的分支之一，但其本身也是一个相当巨大的命题。在未来的一段时间里，我将花时间在专栏写一些我比较熟悉的机器学习相关的概念和算法，最主要的目的是为了梳理自己的知识体系，也是希望和大家分享学习的历程和感悟，以达到交流的目的。\n\n这两年大数据火了，机器学习、神经网络、数据挖掘、强化学习等等这些名词都火了，然而我常常在想，把这些名词挂在嘴边的我们，究竟能否在这个领域飞速发展的情况下，清楚地了解到自己说的每一个名词——谁是谁的分支，哪个和哪个又是同等关系或是没有关系的——在名词爆炸的状态下，想学什么，了解其基础概念是必不可少的。\n\n\n\n#  与数据相关的概念\n\n假如我们有一组天气数据，是来自全世界不同国家和地区的每日天气，内容包括最高温度、最低温度、平均湿度、风速之类的相关数据，例如数据的一部分是这样的：\n\n| 城市   | 最高温度 | 最低温度 | 相对湿度 | 某时刻风速    |\n| ---- | ---- | ---- | ---- | -------- |\n| A市   | 36℃  | 28℃  | 58%  | 16.7km/h |\n| B市   | 28℃  | 17℃  | 86%  | /        |\n| C市   | 34℃  | 29℃  | 39%  | 20.4km/h |\n\n在这组数据中，我们将称A市、B市、C市等市以及其情况的总和称为**数据集（data set）**。表格中的每一行，也就是某城市和它的情况被称为一个**样例（sample/instance）**。表格中的每一列（不包括城市），例如最高温度、最低温度，被称为**特征（feature/attribute）**，而每一列中的具体数值，例如36℃ 、28℃，被称为**属性值（attribute value）**。数据中也可能会有**缺失数据（missing data）**，例如B市的某时刻风速，我们会将它视作缺失数据。\n\n<!--more-->\n\n如果我们想预测城市的天气，例如是晴朗还是阴雨天，这些数据是不够的，除了**特征**以外，我们还需要每个城市的具体天气情况，也就是通常语境下的结果。在机器学习中，它会被称为**标签（label）**，用于标记数据。值得注意的是，数据集中不一定包含标签信息，而这种区别会引起方法上的差别。我们可以给上述示例加上一组标签：\n\n| 城市   | 天气   |\n| ---- | ---- |\n| A市   | 晴朗   |\n| B市   | 阴雨   |\n| C市   | 晴朗   |\n\n视具体情况，用来进行机器学习的一个数据集往往会被分为两个数据集——**训练数据（training data）**和**测试数据（testing data）**。  顾名思义，训练数据在机器学习的过程中使用，目的是找出一套机器学习的方法；而测试数据用于判断找出的方法是否足够有效。如果在训练的过程中需要确定方法的准确度，有时会将训练数据分成**训练集（training set）**和**验证集（validation set）**——验证集合测试数据不同的地方在于验证集在训练过程中使用，而测试数据事实上是在模型建立后才被使用的。\n\n# 与方法相关的概念\n\n根据数据有没有标签，我们可以将机器学习分类为**监督学习（Supervised Learning）**、**无监督学习（Unsupervised Learning）**和**半监督学习（Semi-Supervised Learning）**。\n\n**监督学习**是学习**给定标签**的数据集，比如说有一组病人，给出他们的详细资料，将他们是否已确诊癌症作为标签，然后预测一名（其他的）病人是否会患有癌症，就是一种典型的监督学习。监督学习中也有不同的分类，如果我们训练的结果是得癌症和不得癌症之类**离散的类型**，则称为**分类（Classification）**，如果只有两种类型的话可以进一步称为**二分类（Binary Classification）**；如果我们训练的结果是得癌症的概率为0.87之类**连续的数字**，则称为**回归（Regression）**。\n\n**无监督学习**是学习**没有标签的数据集**，比如在分析大量语句之后，训练出一个模型将较为接近的词分为一类，而后可以根据一个新的词在句子中的用法（和其他信息）将这个词分入某一类中。其中比较微妙的地方在于，这种问题下使用**聚类（Clustering）**（方法）所获得的**簇（Cluster）**（结果），有时候是无法人为地观察出其特征的，但是在得到聚类后，可能会对数据集有新的启发。\n\n**半监督学习**的数据集比较特殊，是部分有标签部分无标签的数据集。由于有标签的数据很多时候需要花大量人力物力去分类和生成，半监督学习也被视作当前机器学习的重要部分。半监督问题往往会**利用一些假设**，将半监督学习转化为传统的监督学习或非监督学习问题。\n\n\n\n# 与结果相关的概念\n\n## 二分类问题\n\n衡量结果精度的有一些相关术语，首当其冲的是**准确率（Accuracy）**、**精确率（Precision）**和**召回率（Recall）**。这三个词汇应用于**二分类问题**：将数据分为**正例（Positive Class）**和**反例（Negative Class）**\n\n一张形象的维基百科图：![](https://upload.wikimedia.org/wikipedia/commons/2/26/Precisionrecall.svg)\n\n也就是说，**准确率**是预测和标签一致的样本在所有样本中所占的比例；**精确率**是你预测为正类的数据中，有多少确实是正类；**召回率**是所有正类的数据中，你预测为正类的数据有多少。这三个数据往往用来衡量一个二分类算法的优劣。\n\n## 回归问题\n\n回归问题往往会通过计算**误差（Error）**来确定模型的精确性。误差由于训练集和验证集的不同，会被分为**训练误差（Training Error）**和**验证误差（Validation Error）**。但值得注意的是，模型并不是误差越小就一定越好，因为如果仅仅基于误差，我们可能会得到一个**过拟合（Overfitting）**的模型；但是如果不考虑误差，我们可能会得到一个**欠拟合（Underfitting）**的模型，用图像来说的话大致可以这样理解：\n\n![](http://pingax.com/wp-content/uploads/2014/05/underfitting-overfitting.png)\n\n如果模型十分简单，往往会欠拟合，对于训练数据和测试数据的误差都会很大；但如果模型太过于复杂，往往会过拟合，那么训练数据的误差可能相当小，但是测试数据的误差会增大。好的模型应当平衡于这两者之间：\n\n![](https://i.stack.imgur.com/S0tRm.png)\n\n## 聚类问题\n\n聚类问题的标准一般基于距离：**簇内距离（Intra-cluster Distance）**和**簇间距离（Inter-cluster Distance）**。根据常识而言，簇内距离是越小越好，也就是簇内的元素越相似越好；而簇间距离越大越好，也就是说簇间（不同簇）元素越不相同越好。一般来说，衡量聚类问题会给出一个结合簇内距离和簇间距离的公式。\n\n\n\n# 总结\n\n机器学习的基本概念并不多，但搞清楚具体每个算法适用于怎样的数据、应当怎样去评价是比较重要的一点。\n\n![](http://osvlzj5nm.bkt.clouddn.com/17-7-30/20918915.jpg)\n\n在之后的专栏中，我们将更多的讨论具体的算法，比较它们的优劣，研究它们的局限性和适用性。\n\n希望大家在了解机器学习的时候把一句话永远放在心中：\n\n> All models are wrong but some are useful.","source":"_posts/machine-learning-basic-concepts.md","raw":"---\ntitle: 第一次的机器学习：机器学习基础概念和名词\ndate: 2017-07-30\ncategory: 计算机课堂\ntags: \n- 机器学习\n---\n\n\n\n尽管机器学习从分类上而言只是人工智能（也就是常说的AI）的分支之一，但其本身也是一个相当巨大的命题。在未来的一段时间里，我将花时间在专栏写一些我比较熟悉的机器学习相关的概念和算法，最主要的目的是为了梳理自己的知识体系，也是希望和大家分享学习的历程和感悟，以达到交流的目的。\n\n这两年大数据火了，机器学习、神经网络、数据挖掘、强化学习等等这些名词都火了，然而我常常在想，把这些名词挂在嘴边的我们，究竟能否在这个领域飞速发展的情况下，清楚地了解到自己说的每一个名词——谁是谁的分支，哪个和哪个又是同等关系或是没有关系的——在名词爆炸的状态下，想学什么，了解其基础概念是必不可少的。\n\n\n\n#  与数据相关的概念\n\n假如我们有一组天气数据，是来自全世界不同国家和地区的每日天气，内容包括最高温度、最低温度、平均湿度、风速之类的相关数据，例如数据的一部分是这样的：\n\n| 城市   | 最高温度 | 最低温度 | 相对湿度 | 某时刻风速    |\n| ---- | ---- | ---- | ---- | -------- |\n| A市   | 36℃  | 28℃  | 58%  | 16.7km/h |\n| B市   | 28℃  | 17℃  | 86%  | /        |\n| C市   | 34℃  | 29℃  | 39%  | 20.4km/h |\n\n在这组数据中，我们将称A市、B市、C市等市以及其情况的总和称为**数据集（data set）**。表格中的每一行，也就是某城市和它的情况被称为一个**样例（sample/instance）**。表格中的每一列（不包括城市），例如最高温度、最低温度，被称为**特征（feature/attribute）**，而每一列中的具体数值，例如36℃ 、28℃，被称为**属性值（attribute value）**。数据中也可能会有**缺失数据（missing data）**，例如B市的某时刻风速，我们会将它视作缺失数据。\n\n<!--more-->\n\n如果我们想预测城市的天气，例如是晴朗还是阴雨天，这些数据是不够的，除了**特征**以外，我们还需要每个城市的具体天气情况，也就是通常语境下的结果。在机器学习中，它会被称为**标签（label）**，用于标记数据。值得注意的是，数据集中不一定包含标签信息，而这种区别会引起方法上的差别。我们可以给上述示例加上一组标签：\n\n| 城市   | 天气   |\n| ---- | ---- |\n| A市   | 晴朗   |\n| B市   | 阴雨   |\n| C市   | 晴朗   |\n\n视具体情况，用来进行机器学习的一个数据集往往会被分为两个数据集——**训练数据（training data）**和**测试数据（testing data）**。  顾名思义，训练数据在机器学习的过程中使用，目的是找出一套机器学习的方法；而测试数据用于判断找出的方法是否足够有效。如果在训练的过程中需要确定方法的准确度，有时会将训练数据分成**训练集（training set）**和**验证集（validation set）**——验证集合测试数据不同的地方在于验证集在训练过程中使用，而测试数据事实上是在模型建立后才被使用的。\n\n# 与方法相关的概念\n\n根据数据有没有标签，我们可以将机器学习分类为**监督学习（Supervised Learning）**、**无监督学习（Unsupervised Learning）**和**半监督学习（Semi-Supervised Learning）**。\n\n**监督学习**是学习**给定标签**的数据集，比如说有一组病人，给出他们的详细资料，将他们是否已确诊癌症作为标签，然后预测一名（其他的）病人是否会患有癌症，就是一种典型的监督学习。监督学习中也有不同的分类，如果我们训练的结果是得癌症和不得癌症之类**离散的类型**，则称为**分类（Classification）**，如果只有两种类型的话可以进一步称为**二分类（Binary Classification）**；如果我们训练的结果是得癌症的概率为0.87之类**连续的数字**，则称为**回归（Regression）**。\n\n**无监督学习**是学习**没有标签的数据集**，比如在分析大量语句之后，训练出一个模型将较为接近的词分为一类，而后可以根据一个新的词在句子中的用法（和其他信息）将这个词分入某一类中。其中比较微妙的地方在于，这种问题下使用**聚类（Clustering）**（方法）所获得的**簇（Cluster）**（结果），有时候是无法人为地观察出其特征的，但是在得到聚类后，可能会对数据集有新的启发。\n\n**半监督学习**的数据集比较特殊，是部分有标签部分无标签的数据集。由于有标签的数据很多时候需要花大量人力物力去分类和生成，半监督学习也被视作当前机器学习的重要部分。半监督问题往往会**利用一些假设**，将半监督学习转化为传统的监督学习或非监督学习问题。\n\n\n\n# 与结果相关的概念\n\n## 二分类问题\n\n衡量结果精度的有一些相关术语，首当其冲的是**准确率（Accuracy）**、**精确率（Precision）**和**召回率（Recall）**。这三个词汇应用于**二分类问题**：将数据分为**正例（Positive Class）**和**反例（Negative Class）**\n\n一张形象的维基百科图：![](https://upload.wikimedia.org/wikipedia/commons/2/26/Precisionrecall.svg)\n\n也就是说，**准确率**是预测和标签一致的样本在所有样本中所占的比例；**精确率**是你预测为正类的数据中，有多少确实是正类；**召回率**是所有正类的数据中，你预测为正类的数据有多少。这三个数据往往用来衡量一个二分类算法的优劣。\n\n## 回归问题\n\n回归问题往往会通过计算**误差（Error）**来确定模型的精确性。误差由于训练集和验证集的不同，会被分为**训练误差（Training Error）**和**验证误差（Validation Error）**。但值得注意的是，模型并不是误差越小就一定越好，因为如果仅仅基于误差，我们可能会得到一个**过拟合（Overfitting）**的模型；但是如果不考虑误差，我们可能会得到一个**欠拟合（Underfitting）**的模型，用图像来说的话大致可以这样理解：\n\n![](http://pingax.com/wp-content/uploads/2014/05/underfitting-overfitting.png)\n\n如果模型十分简单，往往会欠拟合，对于训练数据和测试数据的误差都会很大；但如果模型太过于复杂，往往会过拟合，那么训练数据的误差可能相当小，但是测试数据的误差会增大。好的模型应当平衡于这两者之间：\n\n![](https://i.stack.imgur.com/S0tRm.png)\n\n## 聚类问题\n\n聚类问题的标准一般基于距离：**簇内距离（Intra-cluster Distance）**和**簇间距离（Inter-cluster Distance）**。根据常识而言，簇内距离是越小越好，也就是簇内的元素越相似越好；而簇间距离越大越好，也就是说簇间（不同簇）元素越不相同越好。一般来说，衡量聚类问题会给出一个结合簇内距离和簇间距离的公式。\n\n\n\n# 总结\n\n机器学习的基本概念并不多，但搞清楚具体每个算法适用于怎样的数据、应当怎样去评价是比较重要的一点。\n\n![](http://osvlzj5nm.bkt.clouddn.com/17-7-30/20918915.jpg)\n\n在之后的专栏中，我们将更多的讨论具体的算法，比较它们的优劣，研究它们的局限性和适用性。\n\n希望大家在了解机器学习的时候把一句话永远放在心中：\n\n> All models are wrong but some are useful.","slug":"machine-learning-basic-concepts","published":1,"updated":"2018-07-03T13:44:30.393Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj5repup000h9pd3tvwa6ows","content":"<p>尽管机器学习从分类上而言只是人工智能（也就是常说的AI）的分支之一，但其本身也是一个相当巨大的命题。在未来的一段时间里，我将花时间在专栏写一些我比较熟悉的机器学习相关的概念和算法，最主要的目的是为了梳理自己的知识体系，也是希望和大家分享学习的历程和感悟，以达到交流的目的。</p>\n<p>这两年大数据火了，机器学习、神经网络、数据挖掘、强化学习等等这些名词都火了，然而我常常在想，把这些名词挂在嘴边的我们，究竟能否在这个领域飞速发展的情况下，清楚地了解到自己说的每一个名词——谁是谁的分支，哪个和哪个又是同等关系或是没有关系的——在名词爆炸的状态下，想学什么，了解其基础概念是必不可少的。</p>\n<h1 id=\"与数据相关的概念\"><a href=\"#与数据相关的概念\" class=\"headerlink\" title=\"与数据相关的概念\"></a>与数据相关的概念</h1><p>假如我们有一组天气数据，是来自全世界不同国家和地区的每日天气，内容包括最高温度、最低温度、平均湿度、风速之类的相关数据，例如数据的一部分是这样的：</p>\n<table>\n<thead>\n<tr>\n<th>城市</th>\n<th>最高温度</th>\n<th>最低温度</th>\n<th>相对湿度</th>\n<th>某时刻风速</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>A市</td>\n<td>36℃</td>\n<td>28℃</td>\n<td>58%</td>\n<td>16.7km/h</td>\n</tr>\n<tr>\n<td>B市</td>\n<td>28℃</td>\n<td>17℃</td>\n<td>86%</td>\n<td>/</td>\n</tr>\n<tr>\n<td>C市</td>\n<td>34℃</td>\n<td>29℃</td>\n<td>39%</td>\n<td>20.4km/h</td>\n</tr>\n</tbody>\n</table>\n<p>在这组数据中，我们将称A市、B市、C市等市以及其情况的总和称为<strong>数据集（data set）</strong>。表格中的每一行，也就是某城市和它的情况被称为一个<strong>样例（sample/instance）</strong>。表格中的每一列（不包括城市），例如最高温度、最低温度，被称为<strong>特征（feature/attribute）</strong>，而每一列中的具体数值，例如36℃ 、28℃，被称为<strong>属性值（attribute value）</strong>。数据中也可能会有<strong>缺失数据（missing data）</strong>，例如B市的某时刻风速，我们会将它视作缺失数据。</p>\n<a id=\"more\"></a>\n<p>如果我们想预测城市的天气，例如是晴朗还是阴雨天，这些数据是不够的，除了<strong>特征</strong>以外，我们还需要每个城市的具体天气情况，也就是通常语境下的结果。在机器学习中，它会被称为<strong>标签（label）</strong>，用于标记数据。值得注意的是，数据集中不一定包含标签信息，而这种区别会引起方法上的差别。我们可以给上述示例加上一组标签：</p>\n<table>\n<thead>\n<tr>\n<th>城市</th>\n<th>天气</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>A市</td>\n<td>晴朗</td>\n</tr>\n<tr>\n<td>B市</td>\n<td>阴雨</td>\n</tr>\n<tr>\n<td>C市</td>\n<td>晴朗</td>\n</tr>\n</tbody>\n</table>\n<p>视具体情况，用来进行机器学习的一个数据集往往会被分为两个数据集——<strong>训练数据（training data）</strong>和<strong>测试数据（testing data）</strong>。  顾名思义，训练数据在机器学习的过程中使用，目的是找出一套机器学习的方法；而测试数据用于判断找出的方法是否足够有效。如果在训练的过程中需要确定方法的准确度，有时会将训练数据分成<strong>训练集（training set）</strong>和<strong>验证集（validation set）</strong>——验证集合测试数据不同的地方在于验证集在训练过程中使用，而测试数据事实上是在模型建立后才被使用的。</p>\n<h1 id=\"与方法相关的概念\"><a href=\"#与方法相关的概念\" class=\"headerlink\" title=\"与方法相关的概念\"></a>与方法相关的概念</h1><p>根据数据有没有标签，我们可以将机器学习分类为<strong>监督学习（Supervised Learning）</strong>、<strong>无监督学习（Unsupervised Learning）</strong>和<strong>半监督学习（Semi-Supervised Learning）</strong>。</p>\n<p><strong>监督学习</strong>是学习<strong>给定标签</strong>的数据集，比如说有一组病人，给出他们的详细资料，将他们是否已确诊癌症作为标签，然后预测一名（其他的）病人是否会患有癌症，就是一种典型的监督学习。监督学习中也有不同的分类，如果我们训练的结果是得癌症和不得癌症之类<strong>离散的类型</strong>，则称为<strong>分类（Classification）</strong>，如果只有两种类型的话可以进一步称为<strong>二分类（Binary Classification）</strong>；如果我们训练的结果是得癌症的概率为0.87之类<strong>连续的数字</strong>，则称为<strong>回归（Regression）</strong>。</p>\n<p><strong>无监督学习</strong>是学习<strong>没有标签的数据集</strong>，比如在分析大量语句之后，训练出一个模型将较为接近的词分为一类，而后可以根据一个新的词在句子中的用法（和其他信息）将这个词分入某一类中。其中比较微妙的地方在于，这种问题下使用<strong>聚类（Clustering）</strong>（方法）所获得的<strong>簇（Cluster）</strong>（结果），有时候是无法人为地观察出其特征的，但是在得到聚类后，可能会对数据集有新的启发。</p>\n<p><strong>半监督学习</strong>的数据集比较特殊，是部分有标签部分无标签的数据集。由于有标签的数据很多时候需要花大量人力物力去分类和生成，半监督学习也被视作当前机器学习的重要部分。半监督问题往往会<strong>利用一些假设</strong>，将半监督学习转化为传统的监督学习或非监督学习问题。</p>\n<h1 id=\"与结果相关的概念\"><a href=\"#与结果相关的概念\" class=\"headerlink\" title=\"与结果相关的概念\"></a>与结果相关的概念</h1><h2 id=\"二分类问题\"><a href=\"#二分类问题\" class=\"headerlink\" title=\"二分类问题\"></a>二分类问题</h2><p>衡量结果精度的有一些相关术语，首当其冲的是<strong>准确率（Accuracy）</strong>、<strong>精确率（Precision）</strong>和<strong>召回率（Recall）</strong>。这三个词汇应用于<strong>二分类问题</strong>：将数据分为<strong>正例（Positive Class）</strong>和<strong>反例（Negative Class）</strong></p>\n<p>一张形象的维基百科图：<img src=\"https://upload.wikimedia.org/wikipedia/commons/2/26/Precisionrecall.svg\" alt=\"\"></p>\n<p>也就是说，<strong>准确率</strong>是预测和标签一致的样本在所有样本中所占的比例；<strong>精确率</strong>是你预测为正类的数据中，有多少确实是正类；<strong>召回率</strong>是所有正类的数据中，你预测为正类的数据有多少。这三个数据往往用来衡量一个二分类算法的优劣。</p>\n<h2 id=\"回归问题\"><a href=\"#回归问题\" class=\"headerlink\" title=\"回归问题\"></a>回归问题</h2><p>回归问题往往会通过计算<strong>误差（Error）</strong>来确定模型的精确性。误差由于训练集和验证集的不同，会被分为<strong>训练误差（Training Error）</strong>和<strong>验证误差（Validation Error）</strong>。但值得注意的是，模型并不是误差越小就一定越好，因为如果仅仅基于误差，我们可能会得到一个<strong>过拟合（Overfitting）</strong>的模型；但是如果不考虑误差，我们可能会得到一个<strong>欠拟合（Underfitting）</strong>的模型，用图像来说的话大致可以这样理解：</p>\n<p><img src=\"http://pingax.com/wp-content/uploads/2014/05/underfitting-overfitting.png\" alt=\"\"></p>\n<p>如果模型十分简单，往往会欠拟合，对于训练数据和测试数据的误差都会很大；但如果模型太过于复杂，往往会过拟合，那么训练数据的误差可能相当小，但是测试数据的误差会增大。好的模型应当平衡于这两者之间：</p>\n<p><img src=\"https://i.stack.imgur.com/S0tRm.png\" alt=\"\"></p>\n<h2 id=\"聚类问题\"><a href=\"#聚类问题\" class=\"headerlink\" title=\"聚类问题\"></a>聚类问题</h2><p>聚类问题的标准一般基于距离：<strong>簇内距离（Intra-cluster Distance）</strong>和<strong>簇间距离（Inter-cluster Distance）</strong>。根据常识而言，簇内距离是越小越好，也就是簇内的元素越相似越好；而簇间距离越大越好，也就是说簇间（不同簇）元素越不相同越好。一般来说，衡量聚类问题会给出一个结合簇内距离和簇间距离的公式。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>机器学习的基本概念并不多，但搞清楚具体每个算法适用于怎样的数据、应当怎样去评价是比较重要的一点。</p>\n<p><img src=\"http://osvlzj5nm.bkt.clouddn.com/17-7-30/20918915.jpg\" alt=\"\"></p>\n<p>在之后的专栏中，我们将更多的讨论具体的算法，比较它们的优劣，研究它们的局限性和适用性。</p>\n<p>希望大家在了解机器学习的时候把一句话永远放在心中：</p>\n<blockquote>\n<p>All models are wrong but some are useful.</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>尽管机器学习从分类上而言只是人工智能（也就是常说的AI）的分支之一，但其本身也是一个相当巨大的命题。在未来的一段时间里，我将花时间在专栏写一些我比较熟悉的机器学习相关的概念和算法，最主要的目的是为了梳理自己的知识体系，也是希望和大家分享学习的历程和感悟，以达到交流的目的。</p>\n<p>这两年大数据火了，机器学习、神经网络、数据挖掘、强化学习等等这些名词都火了，然而我常常在想，把这些名词挂在嘴边的我们，究竟能否在这个领域飞速发展的情况下，清楚地了解到自己说的每一个名词——谁是谁的分支，哪个和哪个又是同等关系或是没有关系的——在名词爆炸的状态下，想学什么，了解其基础概念是必不可少的。</p>\n<h1 id=\"与数据相关的概念\"><a href=\"#与数据相关的概念\" class=\"headerlink\" title=\"与数据相关的概念\"></a>与数据相关的概念</h1><p>假如我们有一组天气数据，是来自全世界不同国家和地区的每日天气，内容包括最高温度、最低温度、平均湿度、风速之类的相关数据，例如数据的一部分是这样的：</p>\n<table>\n<thead>\n<tr>\n<th>城市</th>\n<th>最高温度</th>\n<th>最低温度</th>\n<th>相对湿度</th>\n<th>某时刻风速</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>A市</td>\n<td>36℃</td>\n<td>28℃</td>\n<td>58%</td>\n<td>16.7km/h</td>\n</tr>\n<tr>\n<td>B市</td>\n<td>28℃</td>\n<td>17℃</td>\n<td>86%</td>\n<td>/</td>\n</tr>\n<tr>\n<td>C市</td>\n<td>34℃</td>\n<td>29℃</td>\n<td>39%</td>\n<td>20.4km/h</td>\n</tr>\n</tbody>\n</table>\n<p>在这组数据中，我们将称A市、B市、C市等市以及其情况的总和称为<strong>数据集（data set）</strong>。表格中的每一行，也就是某城市和它的情况被称为一个<strong>样例（sample/instance）</strong>。表格中的每一列（不包括城市），例如最高温度、最低温度，被称为<strong>特征（feature/attribute）</strong>，而每一列中的具体数值，例如36℃ 、28℃，被称为<strong>属性值（attribute value）</strong>。数据中也可能会有<strong>缺失数据（missing data）</strong>，例如B市的某时刻风速，我们会将它视作缺失数据。</p>","more":"<p>如果我们想预测城市的天气，例如是晴朗还是阴雨天，这些数据是不够的，除了<strong>特征</strong>以外，我们还需要每个城市的具体天气情况，也就是通常语境下的结果。在机器学习中，它会被称为<strong>标签（label）</strong>，用于标记数据。值得注意的是，数据集中不一定包含标签信息，而这种区别会引起方法上的差别。我们可以给上述示例加上一组标签：</p>\n<table>\n<thead>\n<tr>\n<th>城市</th>\n<th>天气</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>A市</td>\n<td>晴朗</td>\n</tr>\n<tr>\n<td>B市</td>\n<td>阴雨</td>\n</tr>\n<tr>\n<td>C市</td>\n<td>晴朗</td>\n</tr>\n</tbody>\n</table>\n<p>视具体情况，用来进行机器学习的一个数据集往往会被分为两个数据集——<strong>训练数据（training data）</strong>和<strong>测试数据（testing data）</strong>。  顾名思义，训练数据在机器学习的过程中使用，目的是找出一套机器学习的方法；而测试数据用于判断找出的方法是否足够有效。如果在训练的过程中需要确定方法的准确度，有时会将训练数据分成<strong>训练集（training set）</strong>和<strong>验证集（validation set）</strong>——验证集合测试数据不同的地方在于验证集在训练过程中使用，而测试数据事实上是在模型建立后才被使用的。</p>\n<h1 id=\"与方法相关的概念\"><a href=\"#与方法相关的概念\" class=\"headerlink\" title=\"与方法相关的概念\"></a>与方法相关的概念</h1><p>根据数据有没有标签，我们可以将机器学习分类为<strong>监督学习（Supervised Learning）</strong>、<strong>无监督学习（Unsupervised Learning）</strong>和<strong>半监督学习（Semi-Supervised Learning）</strong>。</p>\n<p><strong>监督学习</strong>是学习<strong>给定标签</strong>的数据集，比如说有一组病人，给出他们的详细资料，将他们是否已确诊癌症作为标签，然后预测一名（其他的）病人是否会患有癌症，就是一种典型的监督学习。监督学习中也有不同的分类，如果我们训练的结果是得癌症和不得癌症之类<strong>离散的类型</strong>，则称为<strong>分类（Classification）</strong>，如果只有两种类型的话可以进一步称为<strong>二分类（Binary Classification）</strong>；如果我们训练的结果是得癌症的概率为0.87之类<strong>连续的数字</strong>，则称为<strong>回归（Regression）</strong>。</p>\n<p><strong>无监督学习</strong>是学习<strong>没有标签的数据集</strong>，比如在分析大量语句之后，训练出一个模型将较为接近的词分为一类，而后可以根据一个新的词在句子中的用法（和其他信息）将这个词分入某一类中。其中比较微妙的地方在于，这种问题下使用<strong>聚类（Clustering）</strong>（方法）所获得的<strong>簇（Cluster）</strong>（结果），有时候是无法人为地观察出其特征的，但是在得到聚类后，可能会对数据集有新的启发。</p>\n<p><strong>半监督学习</strong>的数据集比较特殊，是部分有标签部分无标签的数据集。由于有标签的数据很多时候需要花大量人力物力去分类和生成，半监督学习也被视作当前机器学习的重要部分。半监督问题往往会<strong>利用一些假设</strong>，将半监督学习转化为传统的监督学习或非监督学习问题。</p>\n<h1 id=\"与结果相关的概念\"><a href=\"#与结果相关的概念\" class=\"headerlink\" title=\"与结果相关的概念\"></a>与结果相关的概念</h1><h2 id=\"二分类问题\"><a href=\"#二分类问题\" class=\"headerlink\" title=\"二分类问题\"></a>二分类问题</h2><p>衡量结果精度的有一些相关术语，首当其冲的是<strong>准确率（Accuracy）</strong>、<strong>精确率（Precision）</strong>和<strong>召回率（Recall）</strong>。这三个词汇应用于<strong>二分类问题</strong>：将数据分为<strong>正例（Positive Class）</strong>和<strong>反例（Negative Class）</strong></p>\n<p>一张形象的维基百科图：<img src=\"https://upload.wikimedia.org/wikipedia/commons/2/26/Precisionrecall.svg\" alt=\"\"></p>\n<p>也就是说，<strong>准确率</strong>是预测和标签一致的样本在所有样本中所占的比例；<strong>精确率</strong>是你预测为正类的数据中，有多少确实是正类；<strong>召回率</strong>是所有正类的数据中，你预测为正类的数据有多少。这三个数据往往用来衡量一个二分类算法的优劣。</p>\n<h2 id=\"回归问题\"><a href=\"#回归问题\" class=\"headerlink\" title=\"回归问题\"></a>回归问题</h2><p>回归问题往往会通过计算<strong>误差（Error）</strong>来确定模型的精确性。误差由于训练集和验证集的不同，会被分为<strong>训练误差（Training Error）</strong>和<strong>验证误差（Validation Error）</strong>。但值得注意的是，模型并不是误差越小就一定越好，因为如果仅仅基于误差，我们可能会得到一个<strong>过拟合（Overfitting）</strong>的模型；但是如果不考虑误差，我们可能会得到一个<strong>欠拟合（Underfitting）</strong>的模型，用图像来说的话大致可以这样理解：</p>\n<p><img src=\"http://pingax.com/wp-content/uploads/2014/05/underfitting-overfitting.png\" alt=\"\"></p>\n<p>如果模型十分简单，往往会欠拟合，对于训练数据和测试数据的误差都会很大；但如果模型太过于复杂，往往会过拟合，那么训练数据的误差可能相当小，但是测试数据的误差会增大。好的模型应当平衡于这两者之间：</p>\n<p><img src=\"https://i.stack.imgur.com/S0tRm.png\" alt=\"\"></p>\n<h2 id=\"聚类问题\"><a href=\"#聚类问题\" class=\"headerlink\" title=\"聚类问题\"></a>聚类问题</h2><p>聚类问题的标准一般基于距离：<strong>簇内距离（Intra-cluster Distance）</strong>和<strong>簇间距离（Inter-cluster Distance）</strong>。根据常识而言，簇内距离是越小越好，也就是簇内的元素越相似越好；而簇间距离越大越好，也就是说簇间（不同簇）元素越不相同越好。一般来说，衡量聚类问题会给出一个结合簇内距离和簇间距离的公式。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>机器学习的基本概念并不多，但搞清楚具体每个算法适用于怎样的数据、应当怎样去评价是比较重要的一点。</p>\n<p><img src=\"http://osvlzj5nm.bkt.clouddn.com/17-7-30/20918915.jpg\" alt=\"\"></p>\n<p>在之后的专栏中，我们将更多的讨论具体的算法，比较它们的优劣，研究它们的局限性和适用性。</p>\n<p>希望大家在了解机器学习的时候把一句话永远放在心中：</p>\n<blockquote>\n<p>All models are wrong but some are useful.</p>\n</blockquote>"},{"title":"[LeetCode] 189. Rotate Array","date":"2018-07-01T16:00:00.000Z","_content":"\n## 题目\n\n[LeetCode链接](https://leetcode.com/problems/rotate-array/description/)\n\nGiven an array, rotate the array to the right by *k* steps, where *k* is non-negative.\n\n**Example 1:**\n\n```\nInput: [1,2,3,4,5,6,7] and k = 3\nOutput: [5,6,7,1,2,3,4]\nExplanation:\nrotate 1 steps to the right: [7,1,2,3,4,5,6]\nrotate 2 steps to the right: [6,7,1,2,3,4,5]\nrotate 3 steps to the right: [5,6,7,1,2,3,4]\n```\n\n<!--more-->\n\n**Example 2:**\n\n```\nInput: [-1,-100,3,99] and k = 2\nOutput: [3,99,-1,-100]\nExplanation: \nrotate 1 steps to the right: [99,-1,-100,3]\nrotate 2 steps to the right: [3,99,-1,-100]\n```\n\n**Note:**\n\n- Try to come up as many solutions as you can, there are at least 3 different ways to solve this problem.\n- Could you do it in-place with O(1) extra space?\n\n \n\n\n\n## 解题报告\n\n### 思路\n\n这是一道原题相对简单的模拟题。要写出一个简单能够通过而不超时的方法并不难，只要利用至多k元素的空间，就可以完成数组的拆解和重新拼接。\n\n难点在思考题中的 **O(1) extra space** 部分。这说明我们只能使用常数个临时元素，而这个常数不能随数组长度或事 k 的大小而变化。因此，我们使用 k 个元素的临时数组完成交换的想法是无法实现的。因此解法涉及到一些想法和数论知识。\n\n\n\n### 方法一：暴力拆解\n\n暴力拆解的解法就不多说了，就是将数组拆为两个部分再拼接，只需要计算好拆解的位置即可：\n\n```python\nclass Solution(object):\n    def rotate(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        k = k % len(nums)\n        nums[:] = nums[len(nums)-k:] + nums[:len(nums)-k]\n        # 或是利用 Python 负数 index 的特性：nums[:] = nums[-k:] + nums[:-k] \n```\n\n需要提示的是，虽然不进行第一步的取模操作也仍然能通过，我还是建议对 k 取模以保证解法的严谨性，因为题目中从未保证 k 是一个小于 n 的数字。\n\n另外数组的更新需要使用 `nums[:]` 而非`nums`，原因是`nums`在函数中被重新赋值会被视作是本地变量，而非传入的参数（很复杂，需要研究 Python 原理了……）。\n\n#### 复杂度\n\n该算法的时间复杂度可以视作 O(1)，但数组的拆解利用了额外 O(n) 的空间。\n\n\n\n### 方法二：循环更新 \n\n循环更新的方法更多的思考，但是也是为数不多时间复杂度够好也仅用 O(1) 空间复杂度的方法。\n\n如果只给一个临时变量的话，很多人的第一想法一定是一位一位移、循环 k 次，就可以得到结果数组，但这种往往太过复杂；而第二想法就会是，把 0 位的数移到 k 位，再把 k 位的移到 2k 位，以此类推……\n\n但是我们如何保证这种做法遍历一次数组呢？不如想想跳跃多少个 k 次可以回到原点点吧。为了简化问题，我们就从 0 开始跳跃，跳回到 0 点的条件便是所在位置是 n 的倍数。我们把 k 和 n = len(nums) 的关系简单分成三种：\n\n1. n 是 k 的倍数时：一共需要 $\\frac{n}{k}$ 次到达越界的 n 次，从而重新回到 0 点。\n2. n 和 k 互质时：由于互质，在 $k \\times n$ 前，k 的倍数无法成为 n 的倍数，因此一共需要 $n$ 次才能达到 n 的倍数，从而重新回到 0 点。\n3. 当 n 和 k 既不互素也不是倍数的时候：一共需要$\\frac{最小公倍数}{k}$次跳跃，就能回到 0 点了。\n\n当这样理下来之后，我们就会发现三种情况完全就是一模一样的：不论 k 和 n 是什么关系，循环一次所需的跳跃步数一共是 k 和 n 的**最小公倍数除以 k **次。由于每一个数字在交换一次时就会处于自己应该在的地方，所以总共需要的交换的次数是 n 次，因此一共需要 $\\frac{n\\times k}{最小公倍数}=最大公约数$次循环。\n\n那么这最大公约数次的循环如果从 0 开始，第二个数字要怎么选呢？反过来想，如果我们选的下一个数字就是 1 会怎样呢？我们看看 0 的下一个数字 1 有什么看法。假如说 0 和 1 在一个循环中同时被更新了，那说明什么呢？简单来说，因为每 k 数会被更新一次，因此，$(0 + k \\times a) \\mod n = 1$ ，进行化简后我们发现$k\\times a - n\\times b = 1$。对啦！这正是大名鼎鼎的拓展欧几里得公式，而等式右边的 1 说明了 k 和 n 是互质的两个数（如果有兴趣的话，你也可以证明 1 之后可以选 2，2 之后可以选 3……）。也就是说，在除了互质的情况下，如果我们的循环结束了，选择开始数字的下一个准没错。你问互质的情况怎么办？看看上面的推论，如果 k 和 n 互质的话，再回到 0 点的时候一圈数字就都更新完了。\n\n当我们证明了这一切之后，写代码就变得容易了起来：\n\n```python\nclass Solution(object):\n    def rotate(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        k = k % len(nums)\n        count = 0\n        for start in range(len(nums)):\n            if count == len(nums):\n                break\n            temp = nums[start]\n            curr = (start + k) % len(nums) \n            while curr != start:\n                nums[curr], temp = temp, nums[curr]\n                curr = (curr + k) % len(nums)\n                count += 1\n            nums[curr] = temp\n            count += 1    \n```\n\n#### 复杂度\n\n由于每个数字只被更新一次，时间复杂度为 O(n)；由于只用了常数个临时变量（count, start, curr, temp），空间复杂度为 O(1)\n\n\n\n## 结语\n\n时间换空间的算法深入人心，在结题报告中，我列举了两种算法，其中一种用时应当更短，但占用更多空间；而另一种用时稍长，但几乎不需要额外空间。除了记住这一题的解法，我觉得更重要的是掌握时间和空间的魔法吧╰( ͡° ͜ʖ ͡° )つ──☆*:・ﾟ","source":"_posts/leetcode-189.md","raw":"---\ntitle: '[LeetCode] 189. Rotate Array'\ndate: 2018-07-02\ncategory: 解题报告\ntags: \n- 解题报告\n- LeetCode\n- Python\n- 数组\n- 模拟\n- 数论\n---\n\n## 题目\n\n[LeetCode链接](https://leetcode.com/problems/rotate-array/description/)\n\nGiven an array, rotate the array to the right by *k* steps, where *k* is non-negative.\n\n**Example 1:**\n\n```\nInput: [1,2,3,4,5,6,7] and k = 3\nOutput: [5,6,7,1,2,3,4]\nExplanation:\nrotate 1 steps to the right: [7,1,2,3,4,5,6]\nrotate 2 steps to the right: [6,7,1,2,3,4,5]\nrotate 3 steps to the right: [5,6,7,1,2,3,4]\n```\n\n<!--more-->\n\n**Example 2:**\n\n```\nInput: [-1,-100,3,99] and k = 2\nOutput: [3,99,-1,-100]\nExplanation: \nrotate 1 steps to the right: [99,-1,-100,3]\nrotate 2 steps to the right: [3,99,-1,-100]\n```\n\n**Note:**\n\n- Try to come up as many solutions as you can, there are at least 3 different ways to solve this problem.\n- Could you do it in-place with O(1) extra space?\n\n \n\n\n\n## 解题报告\n\n### 思路\n\n这是一道原题相对简单的模拟题。要写出一个简单能够通过而不超时的方法并不难，只要利用至多k元素的空间，就可以完成数组的拆解和重新拼接。\n\n难点在思考题中的 **O(1) extra space** 部分。这说明我们只能使用常数个临时元素，而这个常数不能随数组长度或事 k 的大小而变化。因此，我们使用 k 个元素的临时数组完成交换的想法是无法实现的。因此解法涉及到一些想法和数论知识。\n\n\n\n### 方法一：暴力拆解\n\n暴力拆解的解法就不多说了，就是将数组拆为两个部分再拼接，只需要计算好拆解的位置即可：\n\n```python\nclass Solution(object):\n    def rotate(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        k = k % len(nums)\n        nums[:] = nums[len(nums)-k:] + nums[:len(nums)-k]\n        # 或是利用 Python 负数 index 的特性：nums[:] = nums[-k:] + nums[:-k] \n```\n\n需要提示的是，虽然不进行第一步的取模操作也仍然能通过，我还是建议对 k 取模以保证解法的严谨性，因为题目中从未保证 k 是一个小于 n 的数字。\n\n另外数组的更新需要使用 `nums[:]` 而非`nums`，原因是`nums`在函数中被重新赋值会被视作是本地变量，而非传入的参数（很复杂，需要研究 Python 原理了……）。\n\n#### 复杂度\n\n该算法的时间复杂度可以视作 O(1)，但数组的拆解利用了额外 O(n) 的空间。\n\n\n\n### 方法二：循环更新 \n\n循环更新的方法更多的思考，但是也是为数不多时间复杂度够好也仅用 O(1) 空间复杂度的方法。\n\n如果只给一个临时变量的话，很多人的第一想法一定是一位一位移、循环 k 次，就可以得到结果数组，但这种往往太过复杂；而第二想法就会是，把 0 位的数移到 k 位，再把 k 位的移到 2k 位，以此类推……\n\n但是我们如何保证这种做法遍历一次数组呢？不如想想跳跃多少个 k 次可以回到原点点吧。为了简化问题，我们就从 0 开始跳跃，跳回到 0 点的条件便是所在位置是 n 的倍数。我们把 k 和 n = len(nums) 的关系简单分成三种：\n\n1. n 是 k 的倍数时：一共需要 $\\frac{n}{k}$ 次到达越界的 n 次，从而重新回到 0 点。\n2. n 和 k 互质时：由于互质，在 $k \\times n$ 前，k 的倍数无法成为 n 的倍数，因此一共需要 $n$ 次才能达到 n 的倍数，从而重新回到 0 点。\n3. 当 n 和 k 既不互素也不是倍数的时候：一共需要$\\frac{最小公倍数}{k}$次跳跃，就能回到 0 点了。\n\n当这样理下来之后，我们就会发现三种情况完全就是一模一样的：不论 k 和 n 是什么关系，循环一次所需的跳跃步数一共是 k 和 n 的**最小公倍数除以 k **次。由于每一个数字在交换一次时就会处于自己应该在的地方，所以总共需要的交换的次数是 n 次，因此一共需要 $\\frac{n\\times k}{最小公倍数}=最大公约数$次循环。\n\n那么这最大公约数次的循环如果从 0 开始，第二个数字要怎么选呢？反过来想，如果我们选的下一个数字就是 1 会怎样呢？我们看看 0 的下一个数字 1 有什么看法。假如说 0 和 1 在一个循环中同时被更新了，那说明什么呢？简单来说，因为每 k 数会被更新一次，因此，$(0 + k \\times a) \\mod n = 1$ ，进行化简后我们发现$k\\times a - n\\times b = 1$。对啦！这正是大名鼎鼎的拓展欧几里得公式，而等式右边的 1 说明了 k 和 n 是互质的两个数（如果有兴趣的话，你也可以证明 1 之后可以选 2，2 之后可以选 3……）。也就是说，在除了互质的情况下，如果我们的循环结束了，选择开始数字的下一个准没错。你问互质的情况怎么办？看看上面的推论，如果 k 和 n 互质的话，再回到 0 点的时候一圈数字就都更新完了。\n\n当我们证明了这一切之后，写代码就变得容易了起来：\n\n```python\nclass Solution(object):\n    def rotate(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        k = k % len(nums)\n        count = 0\n        for start in range(len(nums)):\n            if count == len(nums):\n                break\n            temp = nums[start]\n            curr = (start + k) % len(nums) \n            while curr != start:\n                nums[curr], temp = temp, nums[curr]\n                curr = (curr + k) % len(nums)\n                count += 1\n            nums[curr] = temp\n            count += 1    \n```\n\n#### 复杂度\n\n由于每个数字只被更新一次，时间复杂度为 O(n)；由于只用了常数个临时变量（count, start, curr, temp），空间复杂度为 O(1)\n\n\n\n## 结语\n\n时间换空间的算法深入人心，在结题报告中，我列举了两种算法，其中一种用时应当更短，但占用更多空间；而另一种用时稍长，但几乎不需要额外空间。除了记住这一题的解法，我觉得更重要的是掌握时间和空间的魔法吧╰( ͡° ͜ʖ ͡° )つ──☆*:・ﾟ","slug":"leetcode-189","published":1,"updated":"2018-07-03T14:06:04.600Z","_id":"cjj5risf40000bhd3si6mxrj2","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p><a href=\"https://leetcode.com/problems/rotate-array/description/\" target=\"_blank\" rel=\"noopener\">LeetCode链接</a></p>\n<p>Given an array, rotate the array to the right by <em>k</em> steps, where <em>k</em> is non-negative.</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: [1,2,3,4,5,6,7] and k = 3</span><br><span class=\"line\">Output: [5,6,7,1,2,3,4]</span><br><span class=\"line\">Explanation:</span><br><span class=\"line\">rotate 1 steps to the right: [7,1,2,3,4,5,6]</span><br><span class=\"line\">rotate 2 steps to the right: [6,7,1,2,3,4,5]</span><br><span class=\"line\">rotate 3 steps to the right: [5,6,7,1,2,3,4]</span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: [-1,-100,3,99] and k = 2</span><br><span class=\"line\">Output: [3,99,-1,-100]</span><br><span class=\"line\">Explanation: </span><br><span class=\"line\">rotate 1 steps to the right: [99,-1,-100,3]</span><br><span class=\"line\">rotate 2 steps to the right: [3,99,-1,-100]</span><br></pre></td></tr></table></figure>\n<p><strong>Note:</strong></p>\n<ul>\n<li>Try to come up as many solutions as you can, there are at least 3 different ways to solve this problem.</li>\n<li>Could you do it in-place with O(1) extra space?</li>\n</ul>\n<h2 id=\"解题报告\"><a href=\"#解题报告\" class=\"headerlink\" title=\"解题报告\"></a>解题报告</h2><h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>这是一道原题相对简单的模拟题。要写出一个简单能够通过而不超时的方法并不难，只要利用至多k元素的空间，就可以完成数组的拆解和重新拼接。</p>\n<p>难点在思考题中的 <strong>O(1) extra space</strong> 部分。这说明我们只能使用常数个临时元素，而这个常数不能随数组长度或事 k 的大小而变化。因此，我们使用 k 个元素的临时数组完成交换的想法是无法实现的。因此解法涉及到一些想法和数论知识。</p>\n<h3 id=\"方法一：暴力拆解\"><a href=\"#方法一：暴力拆解\" class=\"headerlink\" title=\"方法一：暴力拆解\"></a>方法一：暴力拆解</h3><p>暴力拆解的解法就不多说了，就是将数组拆为两个部分再拼接，只需要计算好拆解的位置即可：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">rotate</span><span class=\"params\">(self, nums, k)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type nums: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :type k: int</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: void Do not return anything, modify nums in-place instead.</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        k = k % len(nums)</span><br><span class=\"line\">        nums[:] = nums[len(nums)-k:] + nums[:len(nums)-k]</span><br><span class=\"line\">        <span class=\"comment\"># 或是利用 Python 负数 index 的特性：nums[:] = nums[-k:] + nums[:-k]</span></span><br></pre></td></tr></table></figure>\n<p>需要提示的是，虽然不进行第一步的取模操作也仍然能通过，我还是建议对 k 取模以保证解法的严谨性，因为题目中从未保证 k 是一个小于 n 的数字。</p>\n<p>另外数组的更新需要使用 <code>nums[:]</code> 而非<code>nums</code>，原因是<code>nums</code>在函数中被重新赋值会被视作是本地变量，而非传入的参数（很复杂，需要研究 Python 原理了……）。</p>\n<h4 id=\"复杂度\"><a href=\"#复杂度\" class=\"headerlink\" title=\"复杂度\"></a>复杂度</h4><p>该算法的时间复杂度可以视作 O(1)，但数组的拆解利用了额外 O(n) 的空间。</p>\n<h3 id=\"方法二：循环更新\"><a href=\"#方法二：循环更新\" class=\"headerlink\" title=\"方法二：循环更新\"></a>方法二：循环更新</h3><p>循环更新的方法更多的思考，但是也是为数不多时间复杂度够好也仅用 O(1) 空间复杂度的方法。</p>\n<p>如果只给一个临时变量的话，很多人的第一想法一定是一位一位移、循环 k 次，就可以得到结果数组，但这种往往太过复杂；而第二想法就会是，把 0 位的数移到 k 位，再把 k 位的移到 2k 位，以此类推……</p>\n<p>但是我们如何保证这种做法遍历一次数组呢？不如想想跳跃多少个 k 次可以回到原点点吧。为了简化问题，我们就从 0 开始跳跃，跳回到 0 点的条件便是所在位置是 n 的倍数。我们把 k 和 n = len(nums) 的关系简单分成三种：</p>\n<ol>\n<li>n 是 k 的倍数时：一共需要 $\\frac{n}{k}$ 次到达越界的 n 次，从而重新回到 0 点。</li>\n<li>n 和 k 互质时：由于互质，在 $k \\times n$ 前，k 的倍数无法成为 n 的倍数，因此一共需要 $n$ 次才能达到 n 的倍数，从而重新回到 0 点。</li>\n<li>当 n 和 k 既不互素也不是倍数的时候：一共需要$\\frac{最小公倍数}{k}$次跳跃，就能回到 0 点了。</li>\n</ol>\n<p>当这样理下来之后，我们就会发现三种情况完全就是一模一样的：不论 k 和 n 是什么关系，循环一次所需的跳跃步数一共是 k 和 n 的<strong>最小公倍数除以 k </strong>次。由于每一个数字在交换一次时就会处于自己应该在的地方，所以总共需要的交换的次数是 n 次，因此一共需要 $\\frac{n\\times k}{最小公倍数}=最大公约数$次循环。</p>\n<p>那么这最大公约数次的循环如果从 0 开始，第二个数字要怎么选呢？反过来想，如果我们选的下一个数字就是 1 会怎样呢？我们看看 0 的下一个数字 1 有什么看法。假如说 0 和 1 在一个循环中同时被更新了，那说明什么呢？简单来说，因为每 k 数会被更新一次，因此，$(0 + k \\times a) \\mod n = 1$ ，进行化简后我们发现$k\\times a - n\\times b = 1$。对啦！这正是大名鼎鼎的拓展欧几里得公式，而等式右边的 1 说明了 k 和 n 是互质的两个数（如果有兴趣的话，你也可以证明 1 之后可以选 2，2 之后可以选 3……）。也就是说，在除了互质的情况下，如果我们的循环结束了，选择开始数字的下一个准没错。你问互质的情况怎么办？看看上面的推论，如果 k 和 n 互质的话，再回到 0 点的时候一圈数字就都更新完了。</p>\n<p>当我们证明了这一切之后，写代码就变得容易了起来：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">rotate</span><span class=\"params\">(self, nums, k)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type nums: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :type k: int</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: void Do not return anything, modify nums in-place instead.</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        k = k % len(nums)</span><br><span class=\"line\">        count = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> start <span class=\"keyword\">in</span> range(len(nums)):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> count == len(nums):</span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\">            temp = nums[start]</span><br><span class=\"line\">            curr = (start + k) % len(nums) </span><br><span class=\"line\">            <span class=\"keyword\">while</span> curr != start:</span><br><span class=\"line\">                nums[curr], temp = temp, nums[curr]</span><br><span class=\"line\">                curr = (curr + k) % len(nums)</span><br><span class=\"line\">                count += <span class=\"number\">1</span></span><br><span class=\"line\">            nums[curr] = temp</span><br><span class=\"line\">            count += <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"复杂度-1\"><a href=\"#复杂度-1\" class=\"headerlink\" title=\"复杂度\"></a>复杂度</h4><p>由于每个数字只被更新一次，时间复杂度为 O(n)；由于只用了常数个临时变量（count, start, curr, temp），空间复杂度为 O(1)</p>\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h2><p>时间换空间的算法深入人心，在结题报告中，我列举了两种算法，其中一种用时应当更短，但占用更多空间；而另一种用时稍长，但几乎不需要额外空间。除了记住这一题的解法，我觉得更重要的是掌握时间和空间的魔法吧╰( ͡° ͜ʖ ͡° )つ──☆*:・ﾟ</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p><a href=\"https://leetcode.com/problems/rotate-array/description/\" target=\"_blank\" rel=\"noopener\">LeetCode链接</a></p>\n<p>Given an array, rotate the array to the right by <em>k</em> steps, where <em>k</em> is non-negative.</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: [1,2,3,4,5,6,7] and k = 3</span><br><span class=\"line\">Output: [5,6,7,1,2,3,4]</span><br><span class=\"line\">Explanation:</span><br><span class=\"line\">rotate 1 steps to the right: [7,1,2,3,4,5,6]</span><br><span class=\"line\">rotate 2 steps to the right: [6,7,1,2,3,4,5]</span><br><span class=\"line\">rotate 3 steps to the right: [5,6,7,1,2,3,4]</span><br></pre></td></tr></table></figure>","more":"<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: [-1,-100,3,99] and k = 2</span><br><span class=\"line\">Output: [3,99,-1,-100]</span><br><span class=\"line\">Explanation: </span><br><span class=\"line\">rotate 1 steps to the right: [99,-1,-100,3]</span><br><span class=\"line\">rotate 2 steps to the right: [3,99,-1,-100]</span><br></pre></td></tr></table></figure>\n<p><strong>Note:</strong></p>\n<ul>\n<li>Try to come up as many solutions as you can, there are at least 3 different ways to solve this problem.</li>\n<li>Could you do it in-place with O(1) extra space?</li>\n</ul>\n<h2 id=\"解题报告\"><a href=\"#解题报告\" class=\"headerlink\" title=\"解题报告\"></a>解题报告</h2><h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>这是一道原题相对简单的模拟题。要写出一个简单能够通过而不超时的方法并不难，只要利用至多k元素的空间，就可以完成数组的拆解和重新拼接。</p>\n<p>难点在思考题中的 <strong>O(1) extra space</strong> 部分。这说明我们只能使用常数个临时元素，而这个常数不能随数组长度或事 k 的大小而变化。因此，我们使用 k 个元素的临时数组完成交换的想法是无法实现的。因此解法涉及到一些想法和数论知识。</p>\n<h3 id=\"方法一：暴力拆解\"><a href=\"#方法一：暴力拆解\" class=\"headerlink\" title=\"方法一：暴力拆解\"></a>方法一：暴力拆解</h3><p>暴力拆解的解法就不多说了，就是将数组拆为两个部分再拼接，只需要计算好拆解的位置即可：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">rotate</span><span class=\"params\">(self, nums, k)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type nums: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :type k: int</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: void Do not return anything, modify nums in-place instead.</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        k = k % len(nums)</span><br><span class=\"line\">        nums[:] = nums[len(nums)-k:] + nums[:len(nums)-k]</span><br><span class=\"line\">        <span class=\"comment\"># 或是利用 Python 负数 index 的特性：nums[:] = nums[-k:] + nums[:-k]</span></span><br></pre></td></tr></table></figure>\n<p>需要提示的是，虽然不进行第一步的取模操作也仍然能通过，我还是建议对 k 取模以保证解法的严谨性，因为题目中从未保证 k 是一个小于 n 的数字。</p>\n<p>另外数组的更新需要使用 <code>nums[:]</code> 而非<code>nums</code>，原因是<code>nums</code>在函数中被重新赋值会被视作是本地变量，而非传入的参数（很复杂，需要研究 Python 原理了……）。</p>\n<h4 id=\"复杂度\"><a href=\"#复杂度\" class=\"headerlink\" title=\"复杂度\"></a>复杂度</h4><p>该算法的时间复杂度可以视作 O(1)，但数组的拆解利用了额外 O(n) 的空间。</p>\n<h3 id=\"方法二：循环更新\"><a href=\"#方法二：循环更新\" class=\"headerlink\" title=\"方法二：循环更新\"></a>方法二：循环更新</h3><p>循环更新的方法更多的思考，但是也是为数不多时间复杂度够好也仅用 O(1) 空间复杂度的方法。</p>\n<p>如果只给一个临时变量的话，很多人的第一想法一定是一位一位移、循环 k 次，就可以得到结果数组，但这种往往太过复杂；而第二想法就会是，把 0 位的数移到 k 位，再把 k 位的移到 2k 位，以此类推……</p>\n<p>但是我们如何保证这种做法遍历一次数组呢？不如想想跳跃多少个 k 次可以回到原点点吧。为了简化问题，我们就从 0 开始跳跃，跳回到 0 点的条件便是所在位置是 n 的倍数。我们把 k 和 n = len(nums) 的关系简单分成三种：</p>\n<ol>\n<li>n 是 k 的倍数时：一共需要 $\\frac{n}{k}$ 次到达越界的 n 次，从而重新回到 0 点。</li>\n<li>n 和 k 互质时：由于互质，在 $k \\times n$ 前，k 的倍数无法成为 n 的倍数，因此一共需要 $n$ 次才能达到 n 的倍数，从而重新回到 0 点。</li>\n<li>当 n 和 k 既不互素也不是倍数的时候：一共需要$\\frac{最小公倍数}{k}$次跳跃，就能回到 0 点了。</li>\n</ol>\n<p>当这样理下来之后，我们就会发现三种情况完全就是一模一样的：不论 k 和 n 是什么关系，循环一次所需的跳跃步数一共是 k 和 n 的<strong>最小公倍数除以 k </strong>次。由于每一个数字在交换一次时就会处于自己应该在的地方，所以总共需要的交换的次数是 n 次，因此一共需要 $\\frac{n\\times k}{最小公倍数}=最大公约数$次循环。</p>\n<p>那么这最大公约数次的循环如果从 0 开始，第二个数字要怎么选呢？反过来想，如果我们选的下一个数字就是 1 会怎样呢？我们看看 0 的下一个数字 1 有什么看法。假如说 0 和 1 在一个循环中同时被更新了，那说明什么呢？简单来说，因为每 k 数会被更新一次，因此，$(0 + k \\times a) \\mod n = 1$ ，进行化简后我们发现$k\\times a - n\\times b = 1$。对啦！这正是大名鼎鼎的拓展欧几里得公式，而等式右边的 1 说明了 k 和 n 是互质的两个数（如果有兴趣的话，你也可以证明 1 之后可以选 2，2 之后可以选 3……）。也就是说，在除了互质的情况下，如果我们的循环结束了，选择开始数字的下一个准没错。你问互质的情况怎么办？看看上面的推论，如果 k 和 n 互质的话，再回到 0 点的时候一圈数字就都更新完了。</p>\n<p>当我们证明了这一切之后，写代码就变得容易了起来：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">rotate</span><span class=\"params\">(self, nums, k)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type nums: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :type k: int</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: void Do not return anything, modify nums in-place instead.</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        k = k % len(nums)</span><br><span class=\"line\">        count = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> start <span class=\"keyword\">in</span> range(len(nums)):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> count == len(nums):</span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\">            temp = nums[start]</span><br><span class=\"line\">            curr = (start + k) % len(nums) </span><br><span class=\"line\">            <span class=\"keyword\">while</span> curr != start:</span><br><span class=\"line\">                nums[curr], temp = temp, nums[curr]</span><br><span class=\"line\">                curr = (curr + k) % len(nums)</span><br><span class=\"line\">                count += <span class=\"number\">1</span></span><br><span class=\"line\">            nums[curr] = temp</span><br><span class=\"line\">            count += <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"复杂度-1\"><a href=\"#复杂度-1\" class=\"headerlink\" title=\"复杂度\"></a>复杂度</h4><p>由于每个数字只被更新一次，时间复杂度为 O(n)；由于只用了常数个临时变量（count, start, curr, temp），空间复杂度为 O(1)</p>\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h2><p>时间换空间的算法深入人心，在结题报告中，我列举了两种算法，其中一种用时应当更短，但占用更多空间；而另一种用时稍长，但几乎不需要额外空间。除了记住这一题的解法，我觉得更重要的是掌握时间和空间的魔法吧╰( ͡° ͜ʖ ͡° )つ──☆*:・ﾟ</p>"},{"title":"[LeetCode] 2. Add Two Numbers","date":"2018-07-02T16:00:00.000Z","_content":"\n## 题目\n\n[LeetCode链接](https://leetcode.com/problems/add-two-numbers/description/)\n\nYou are given two **non-empty** linked lists representing two non-negative integers. The digits are stored in **reverse order** and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.\n\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\n\n**Example**\n\n```\nInput: (2 -> 4 -> 3) + (5 -> 6 -> 4)\nOutput: 7 -> 0 -> 8\nExplanation: 342 + 465 = 807.\n```\n\n<!--more-->\n\n\n\n## 解题报告\n\n### 思路\n\n这题算是一个高精度加法的简化版本。简单来说，这个加法其实和列竖式的想法是一致的：先把两边的数字加起来，如果进位了就把进位写上。\n\n\n\n### 方法一：暴力相加\n\n暴力相加使用了小学时候学习的竖式方法。把两个数字加起来看作这位，如果有进位就加上进位，要是又进位了的话就再记上进位；如果一边加完了，就对另一边的数字做同样的事情，把数字加上进位；最后如果还剩下进位就再写一位。\n\n但是这种方法很不幸 TLE 了。虽然从复杂度角度看可能和第二种方法没有太大的差距（量级相同，但是比较次数会多很多次，也就是常数上的不同），说明这题还是严谨地卡了常数……（也可能是 Python 的时间比较吃紧）\n\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def addTwoNumbers(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        root = ListNode((l1.val + l2.val) % 10) \n        s = (l1.val + l2.val) // 10\n        node = root\n        \n        while l1.next and l2.next :\n            l1 = l1.next\n            l2 = l2.next\n            node.next = ListNode((l1.val + l2.val + s) % 10) \n            s = (l1.val + l2.val + s) // 10\n            node = node.next\n            \n        while l1.next:\n            node.next = ListNode((l1.val + s) % 10) \n            s = (l1.val + s) // 10\n            node = node.next\n            \n        while l2.next:\n            node.next = ListNode((l2.val + s) % 10) \n            s = (l2.val + s) // 10\n            node = node.next\n        \n        if s:\n            node.next = ListNode(s)\n            \n        return root\n```\n\n\n\n### 方法二：合并循环\n\n仔细观察第一种解法会发现这四个循环是可以合并到同一个循环中的，也就是说只要两边的数字任意一个还有，或是进位还有的情况下，这个循环都需要继续。这种做法因为循环节中使用了` or` 而非上一种解法中的`and`性能有所提高（起码不 TLE 了）。\n\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def addTwoNumbers(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        root = ListNode(0) \n        node = root\n        c = 0\n        while l1 or l2 or c:\n            if l1:\n                c = c + l1.val\n                l1 = l1.next\n            if l2:\n                c = c + l2.val\n                l2 = l2.next\n            node.next = ListNode(c % 10)\n            c = c // 10\n            node = node.next\n                \n        return root.next\n```\n\n\n\n## 结语\n\n了解如何使程序更快更简洁不仅是 Python 的禅，更是面试的禅呀！","source":"_posts/leetcode-2.md","raw":"---\ntitle: '[LeetCode] 2. Add Two Numbers'\ndate: 2018-07-03\ncategory: 解题报告\ntags: \n- 解题报告\n- LeetCode\n- Python\n- 数组\n- 模拟\n\n---\n\n## 题目\n\n[LeetCode链接](https://leetcode.com/problems/add-two-numbers/description/)\n\nYou are given two **non-empty** linked lists representing two non-negative integers. The digits are stored in **reverse order** and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.\n\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\n\n**Example**\n\n```\nInput: (2 -> 4 -> 3) + (5 -> 6 -> 4)\nOutput: 7 -> 0 -> 8\nExplanation: 342 + 465 = 807.\n```\n\n<!--more-->\n\n\n\n## 解题报告\n\n### 思路\n\n这题算是一个高精度加法的简化版本。简单来说，这个加法其实和列竖式的想法是一致的：先把两边的数字加起来，如果进位了就把进位写上。\n\n\n\n### 方法一：暴力相加\n\n暴力相加使用了小学时候学习的竖式方法。把两个数字加起来看作这位，如果有进位就加上进位，要是又进位了的话就再记上进位；如果一边加完了，就对另一边的数字做同样的事情，把数字加上进位；最后如果还剩下进位就再写一位。\n\n但是这种方法很不幸 TLE 了。虽然从复杂度角度看可能和第二种方法没有太大的差距（量级相同，但是比较次数会多很多次，也就是常数上的不同），说明这题还是严谨地卡了常数……（也可能是 Python 的时间比较吃紧）\n\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def addTwoNumbers(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        root = ListNode((l1.val + l2.val) % 10) \n        s = (l1.val + l2.val) // 10\n        node = root\n        \n        while l1.next and l2.next :\n            l1 = l1.next\n            l2 = l2.next\n            node.next = ListNode((l1.val + l2.val + s) % 10) \n            s = (l1.val + l2.val + s) // 10\n            node = node.next\n            \n        while l1.next:\n            node.next = ListNode((l1.val + s) % 10) \n            s = (l1.val + s) // 10\n            node = node.next\n            \n        while l2.next:\n            node.next = ListNode((l2.val + s) % 10) \n            s = (l2.val + s) // 10\n            node = node.next\n        \n        if s:\n            node.next = ListNode(s)\n            \n        return root\n```\n\n\n\n### 方法二：合并循环\n\n仔细观察第一种解法会发现这四个循环是可以合并到同一个循环中的，也就是说只要两边的数字任意一个还有，或是进位还有的情况下，这个循环都需要继续。这种做法因为循环节中使用了` or` 而非上一种解法中的`and`性能有所提高（起码不 TLE 了）。\n\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def addTwoNumbers(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        root = ListNode(0) \n        node = root\n        c = 0\n        while l1 or l2 or c:\n            if l1:\n                c = c + l1.val\n                l1 = l1.next\n            if l2:\n                c = c + l2.val\n                l2 = l2.next\n            node.next = ListNode(c % 10)\n            c = c // 10\n            node = node.next\n                \n        return root.next\n```\n\n\n\n## 结语\n\n了解如何使程序更快更简洁不仅是 Python 的禅，更是面试的禅呀！","slug":"leetcode-2","published":1,"updated":"2018-07-03T14:05:59.394Z","_id":"cjj5rj23t0000bwd3hlxy46o2","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p><a href=\"https://leetcode.com/problems/add-two-numbers/description/\" target=\"_blank\" rel=\"noopener\">LeetCode链接</a></p>\n<p>You are given two <strong>non-empty</strong> linked lists representing two non-negative integers. The digits are stored in <strong>reverse order</strong> and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</p>\n<p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p>\n<p><strong>Example</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class=\"line\">Output: 7 -&gt; 0 -&gt; 8</span><br><span class=\"line\">Explanation: 342 + 465 = 807.</span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<h2 id=\"解题报告\"><a href=\"#解题报告\" class=\"headerlink\" title=\"解题报告\"></a>解题报告</h2><h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>这题算是一个高精度加法的简化版本。简单来说，这个加法其实和列竖式的想法是一致的：先把两边的数字加起来，如果进位了就把进位写上。</p>\n<h3 id=\"方法一：暴力相加\"><a href=\"#方法一：暴力相加\" class=\"headerlink\" title=\"方法一：暴力相加\"></a>方法一：暴力相加</h3><p>暴力相加使用了小学时候学习的竖式方法。把两个数字加起来看作这位，如果有进位就加上进位，要是又进位了的话就再记上进位；如果一边加完了，就对另一边的数字做同样的事情，把数字加上进位；最后如果还剩下进位就再写一位。</p>\n<p>但是这种方法很不幸 TLE 了。虽然从复杂度角度看可能和第二种方法没有太大的差距（量级相同，但是比较次数会多很多次，也就是常数上的不同），说明这题还是严谨地卡了常数……（也可能是 Python 的时间比较吃紧）</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"># class ListNode:</span></span><br><span class=\"line\"><span class=\"comment\">#     def __init__(self, x):</span></span><br><span class=\"line\"><span class=\"comment\">#         self.val = x</span></span><br><span class=\"line\"><span class=\"comment\">#         self.next = None</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">addTwoNumbers</span><span class=\"params\">(self, l1, l2)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type l1: ListNode</span></span><br><span class=\"line\"><span class=\"string\">        :type l2: ListNode</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: ListNode</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        root = ListNode((l1.val + l2.val) % <span class=\"number\">10</span>) </span><br><span class=\"line\">        s = (l1.val + l2.val) // <span class=\"number\">10</span></span><br><span class=\"line\">        node = root</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">while</span> l1.next <span class=\"keyword\">and</span> l2.next :</span><br><span class=\"line\">            l1 = l1.next</span><br><span class=\"line\">            l2 = l2.next</span><br><span class=\"line\">            node.next = ListNode((l1.val + l2.val + s) % <span class=\"number\">10</span>) </span><br><span class=\"line\">            s = (l1.val + l2.val + s) // <span class=\"number\">10</span></span><br><span class=\"line\">            node = node.next</span><br><span class=\"line\">            </span><br><span class=\"line\">        <span class=\"keyword\">while</span> l1.next:</span><br><span class=\"line\">            node.next = ListNode((l1.val + s) % <span class=\"number\">10</span>) </span><br><span class=\"line\">            s = (l1.val + s) // <span class=\"number\">10</span></span><br><span class=\"line\">            node = node.next</span><br><span class=\"line\">            </span><br><span class=\"line\">        <span class=\"keyword\">while</span> l2.next:</span><br><span class=\"line\">            node.next = ListNode((l2.val + s) % <span class=\"number\">10</span>) </span><br><span class=\"line\">            s = (l2.val + s) // <span class=\"number\">10</span></span><br><span class=\"line\">            node = node.next</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> s:</span><br><span class=\"line\">            node.next = ListNode(s)</span><br><span class=\"line\">            </span><br><span class=\"line\">        <span class=\"keyword\">return</span> root</span><br></pre></td></tr></table></figure>\n<h3 id=\"方法二：合并循环\"><a href=\"#方法二：合并循环\" class=\"headerlink\" title=\"方法二：合并循环\"></a>方法二：合并循环</h3><p>仔细观察第一种解法会发现这四个循环是可以合并到同一个循环中的，也就是说只要两边的数字任意一个还有，或是进位还有的情况下，这个循环都需要继续。这种做法因为循环节中使用了<code>or</code> 而非上一种解法中的<code>and</code>性能有所提高（起码不 TLE 了）。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"># class ListNode:</span></span><br><span class=\"line\"><span class=\"comment\">#     def __init__(self, x):</span></span><br><span class=\"line\"><span class=\"comment\">#         self.val = x</span></span><br><span class=\"line\"><span class=\"comment\">#         self.next = None</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">addTwoNumbers</span><span class=\"params\">(self, l1, l2)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type l1: ListNode</span></span><br><span class=\"line\"><span class=\"string\">        :type l2: ListNode</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: ListNode</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        root = ListNode(<span class=\"number\">0</span>) </span><br><span class=\"line\">        node = root</span><br><span class=\"line\">        c = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> l1 <span class=\"keyword\">or</span> l2 <span class=\"keyword\">or</span> c:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> l1:</span><br><span class=\"line\">                c = c + l1.val</span><br><span class=\"line\">                l1 = l1.next</span><br><span class=\"line\">            <span class=\"keyword\">if</span> l2:</span><br><span class=\"line\">                c = c + l2.val</span><br><span class=\"line\">                l2 = l2.next</span><br><span class=\"line\">            node.next = ListNode(c % <span class=\"number\">10</span>)</span><br><span class=\"line\">            c = c // <span class=\"number\">10</span></span><br><span class=\"line\">            node = node.next</span><br><span class=\"line\">                </span><br><span class=\"line\">        <span class=\"keyword\">return</span> root.next</span><br></pre></td></tr></table></figure>\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h2><p>了解如何使程序更快更简洁不仅是 Python 的禅，更是面试的禅呀！</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p><a href=\"https://leetcode.com/problems/add-two-numbers/description/\" target=\"_blank\" rel=\"noopener\">LeetCode链接</a></p>\n<p>You are given two <strong>non-empty</strong> linked lists representing two non-negative integers. The digits are stored in <strong>reverse order</strong> and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</p>\n<p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p>\n<p><strong>Example</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class=\"line\">Output: 7 -&gt; 0 -&gt; 8</span><br><span class=\"line\">Explanation: 342 + 465 = 807.</span><br></pre></td></tr></table></figure>","more":"<h2 id=\"解题报告\"><a href=\"#解题报告\" class=\"headerlink\" title=\"解题报告\"></a>解题报告</h2><h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>这题算是一个高精度加法的简化版本。简单来说，这个加法其实和列竖式的想法是一致的：先把两边的数字加起来，如果进位了就把进位写上。</p>\n<h3 id=\"方法一：暴力相加\"><a href=\"#方法一：暴力相加\" class=\"headerlink\" title=\"方法一：暴力相加\"></a>方法一：暴力相加</h3><p>暴力相加使用了小学时候学习的竖式方法。把两个数字加起来看作这位，如果有进位就加上进位，要是又进位了的话就再记上进位；如果一边加完了，就对另一边的数字做同样的事情，把数字加上进位；最后如果还剩下进位就再写一位。</p>\n<p>但是这种方法很不幸 TLE 了。虽然从复杂度角度看可能和第二种方法没有太大的差距（量级相同，但是比较次数会多很多次，也就是常数上的不同），说明这题还是严谨地卡了常数……（也可能是 Python 的时间比较吃紧）</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"># class ListNode:</span></span><br><span class=\"line\"><span class=\"comment\">#     def __init__(self, x):</span></span><br><span class=\"line\"><span class=\"comment\">#         self.val = x</span></span><br><span class=\"line\"><span class=\"comment\">#         self.next = None</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">addTwoNumbers</span><span class=\"params\">(self, l1, l2)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type l1: ListNode</span></span><br><span class=\"line\"><span class=\"string\">        :type l2: ListNode</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: ListNode</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        root = ListNode((l1.val + l2.val) % <span class=\"number\">10</span>) </span><br><span class=\"line\">        s = (l1.val + l2.val) // <span class=\"number\">10</span></span><br><span class=\"line\">        node = root</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">while</span> l1.next <span class=\"keyword\">and</span> l2.next :</span><br><span class=\"line\">            l1 = l1.next</span><br><span class=\"line\">            l2 = l2.next</span><br><span class=\"line\">            node.next = ListNode((l1.val + l2.val + s) % <span class=\"number\">10</span>) </span><br><span class=\"line\">            s = (l1.val + l2.val + s) // <span class=\"number\">10</span></span><br><span class=\"line\">            node = node.next</span><br><span class=\"line\">            </span><br><span class=\"line\">        <span class=\"keyword\">while</span> l1.next:</span><br><span class=\"line\">            node.next = ListNode((l1.val + s) % <span class=\"number\">10</span>) </span><br><span class=\"line\">            s = (l1.val + s) // <span class=\"number\">10</span></span><br><span class=\"line\">            node = node.next</span><br><span class=\"line\">            </span><br><span class=\"line\">        <span class=\"keyword\">while</span> l2.next:</span><br><span class=\"line\">            node.next = ListNode((l2.val + s) % <span class=\"number\">10</span>) </span><br><span class=\"line\">            s = (l2.val + s) // <span class=\"number\">10</span></span><br><span class=\"line\">            node = node.next</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> s:</span><br><span class=\"line\">            node.next = ListNode(s)</span><br><span class=\"line\">            </span><br><span class=\"line\">        <span class=\"keyword\">return</span> root</span><br></pre></td></tr></table></figure>\n<h3 id=\"方法二：合并循环\"><a href=\"#方法二：合并循环\" class=\"headerlink\" title=\"方法二：合并循环\"></a>方法二：合并循环</h3><p>仔细观察第一种解法会发现这四个循环是可以合并到同一个循环中的，也就是说只要两边的数字任意一个还有，或是进位还有的情况下，这个循环都需要继续。这种做法因为循环节中使用了<code>or</code> 而非上一种解法中的<code>and</code>性能有所提高（起码不 TLE 了）。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"># class ListNode:</span></span><br><span class=\"line\"><span class=\"comment\">#     def __init__(self, x):</span></span><br><span class=\"line\"><span class=\"comment\">#         self.val = x</span></span><br><span class=\"line\"><span class=\"comment\">#         self.next = None</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">addTwoNumbers</span><span class=\"params\">(self, l1, l2)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type l1: ListNode</span></span><br><span class=\"line\"><span class=\"string\">        :type l2: ListNode</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: ListNode</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        root = ListNode(<span class=\"number\">0</span>) </span><br><span class=\"line\">        node = root</span><br><span class=\"line\">        c = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> l1 <span class=\"keyword\">or</span> l2 <span class=\"keyword\">or</span> c:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> l1:</span><br><span class=\"line\">                c = c + l1.val</span><br><span class=\"line\">                l1 = l1.next</span><br><span class=\"line\">            <span class=\"keyword\">if</span> l2:</span><br><span class=\"line\">                c = c + l2.val</span><br><span class=\"line\">                l2 = l2.next</span><br><span class=\"line\">            node.next = ListNode(c % <span class=\"number\">10</span>)</span><br><span class=\"line\">            c = c // <span class=\"number\">10</span></span><br><span class=\"line\">            node = node.next</span><br><span class=\"line\">                </span><br><span class=\"line\">        <span class=\"keyword\">return</span> root.next</span><br></pre></td></tr></table></figure>\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h2><p>了解如何使程序更快更简洁不仅是 Python 的禅，更是面试的禅呀！</p>"}],"PostAsset":[],"PostCategory":[{"post_id":"cjj5repua00059pd39956zrtd","category_id":"cjj5repu600029pd3fs7ibv6p","_id":"cjj5repuk000b9pd352urv0zj"},{"post_id":"cjj5reptx00009pd3w2srrft4","category_id":"cjj5repu600029pd3fs7ibv6p","_id":"cjj5repuo000f9pd3t2peekft"},{"post_id":"cjj5repub00069pd3b3kq67j4","category_id":"cjj5repu600029pd3fs7ibv6p","_id":"cjj5repur000i9pd3acfwor8j"},{"post_id":"cjj5repu400019pd3vfxedkeb","category_id":"cjj5repu600029pd3fs7ibv6p","_id":"cjj5repus000m9pd3p2bgcb1z"},{"post_id":"cjj5repuj000a9pd31zj1bem2","category_id":"cjj5repu600029pd3fs7ibv6p","_id":"cjj5repus000n9pd39ze83edd"},{"post_id":"cjj5repu800049pd38zvtapq8","category_id":"cjj5repu600029pd3fs7ibv6p","_id":"cjj5reput000q9pd3tzxpv2kp"},{"post_id":"cjj5repup000h9pd3tvwa6ows","category_id":"cjj5repu600029pd3fs7ibv6p","_id":"cjj5repuu000s9pd3xxhzyoeb"},{"post_id":"cjj5repuf00099pd3h9zm5pcb","category_id":"cjj5repur000j9pd3l1cq63pm","_id":"cjj5repuv000v9pd3ui17yyah"},{"post_id":"cjj5repum000e9pd3ywmjtr5r","category_id":"cjj5repur000j9pd3l1cq63pm","_id":"cjj5repuy000w9pd3snljut3i"},{"post_id":"cjj5risf40000bhd3si6mxrj2","category_id":"cjj5risfd0001bhd3i4d546k7","_id":"cjj5risfr0004bhd3uls3gc3h"},{"post_id":"cjj5rj23t0000bwd3hlxy46o2","category_id":"cjj5risfd0001bhd3i4d546k7","_id":"cjj5rj2410003bwd3py44dkb2"}],"PostTag":[{"post_id":"cjj5reptx00009pd3w2srrft4","tag_id":"cjj5repu800039pd3f1434lzo","_id":"cjj5repup000g9pd387unffyt"},{"post_id":"cjj5reptx00009pd3w2srrft4","tag_id":"cjj5repuc00089pd31m428iyh","_id":"cjj5repur000k9pd3u43alwue"},{"post_id":"cjj5repu400019pd3vfxedkeb","tag_id":"cjj5repum000d9pd3utaum4l3","_id":"cjj5repuu000r9pd306hx6vxx"},{"post_id":"cjj5repu400019pd3vfxedkeb","tag_id":"cjj5repus000l9pd35yig2wlh","_id":"cjj5repuv000t9pd3g4909a4q"},{"post_id":"cjj5repu800049pd38zvtapq8","tag_id":"cjj5repu800039pd3f1434lzo","_id":"cjj5repuz000y9pd37m9us9j3"},{"post_id":"cjj5repu800049pd38zvtapq8","tag_id":"cjj5repuc00089pd31m428iyh","_id":"cjj5repv0000z9pd3ya2bff5c"},{"post_id":"cjj5repua00059pd39956zrtd","tag_id":"cjj5repu800039pd3f1434lzo","_id":"cjj5repv100119pd3pm1auf1m"},{"post_id":"cjj5repua00059pd39956zrtd","tag_id":"cjj5repuc00089pd31m428iyh","_id":"cjj5repv100129pd32hj82cie"},{"post_id":"cjj5repub00069pd3b3kq67j4","tag_id":"cjj5repu800039pd3f1434lzo","_id":"cjj5repv100149pd333ffq2zn"},{"post_id":"cjj5repub00069pd3b3kq67j4","tag_id":"cjj5repuc00089pd31m428iyh","_id":"cjj5repv200159pd3dt61i3yu"},{"post_id":"cjj5repuf00099pd3h9zm5pcb","tag_id":"cjj5repv100139pd34jmmjd5t","_id":"cjj5repv300189pd38r3hvmye"},{"post_id":"cjj5repuf00099pd3h9zm5pcb","tag_id":"cjj5repv200169pd3kvuy0138","_id":"cjj5repv300199pd3bry1re3x"},{"post_id":"cjj5repuj000a9pd31zj1bem2","tag_id":"cjj5repu800039pd3f1434lzo","_id":"cjj5repv3001b9pd3l0vv5rdm"},{"post_id":"cjj5repuj000a9pd31zj1bem2","tag_id":"cjj5repv200179pd3uz727b1o","_id":"cjj5repv3001c9pd3ywq0f8uu"},{"post_id":"cjj5repum000e9pd3ywmjtr5r","tag_id":"cjj5repv100139pd34jmmjd5t","_id":"cjj5repv4001f9pd3xnlo1cl2"},{"post_id":"cjj5repum000e9pd3ywmjtr5r","tag_id":"cjj5repv200169pd3kvuy0138","_id":"cjj5repv4001g9pd3qq7gyq9q"},{"post_id":"cjj5repup000h9pd3tvwa6ows","tag_id":"cjj5repv4001e9pd3jouwgo17","_id":"cjj5repv5001h9pd3qv35ab5z"},{"post_id":"cjj5risf40000bhd3si6mxrj2","tag_id":"cjj5risfm0002bhd3sdccedt4","_id":"cjj5risfu0008bhd3idf3ov4z"},{"post_id":"cjj5risf40000bhd3si6mxrj2","tag_id":"cjj5risfp0003bhd3jchvmgay","_id":"cjj5risfu0009bhd39ofulps9"},{"post_id":"cjj5risf40000bhd3si6mxrj2","tag_id":"cjj5repu800039pd3f1434lzo","_id":"cjj5risfu000abhd3xulghl5h"},{"post_id":"cjj5risf40000bhd3si6mxrj2","tag_id":"cjj5risfr0005bhd3lqlrj8tq","_id":"cjj5risfv000bbhd36q9o9rr3"},{"post_id":"cjj5risf40000bhd3si6mxrj2","tag_id":"cjj5risfs0006bhd39orqj99z","_id":"cjj5risfv000cbhd3ip3lyark"},{"post_id":"cjj5risf40000bhd3si6mxrj2","tag_id":"cjj5risft0007bhd30myoxc65","_id":"cjj5risfv000dbhd3sanzvonf"},{"post_id":"cjj5rj23t0000bwd3hlxy46o2","tag_id":"cjj5risfm0002bhd3sdccedt4","_id":"cjj5rj2410001bwd3320vpygw"},{"post_id":"cjj5rj23t0000bwd3hlxy46o2","tag_id":"cjj5risfp0003bhd3jchvmgay","_id":"cjj5rj2410002bwd3c9n9lzkq"},{"post_id":"cjj5rj23t0000bwd3hlxy46o2","tag_id":"cjj5repu800039pd3f1434lzo","_id":"cjj5rj2420004bwd3ecomy750"},{"post_id":"cjj5rj23t0000bwd3hlxy46o2","tag_id":"cjj5risfr0005bhd3lqlrj8tq","_id":"cjj5rj2420005bwd33df4x4j4"},{"post_id":"cjj5rj23t0000bwd3hlxy46o2","tag_id":"cjj5risfs0006bhd39orqj99z","_id":"cjj5rj2420006bwd3alvq26za"}],"Tag":[{"name":"Python","_id":"cjj5repu800039pd3f1434lzo"},{"name":"聊天机器人","_id":"cjj5repuc00089pd31m428iyh"},{"name":"概率论","_id":"cjj5repum000d9pd3utaum4l3"},{"name":"统计学","_id":"cjj5repus000l9pd35yig2wlh"},{"name":"软件","_id":"cjj5repv100139pd34jmmjd5t"},{"name":"命令行","_id":"cjj5repv200169pd3kvuy0138"},{"name":"爬虫","_id":"cjj5repv200179pd3uz727b1o"},{"name":"机器学习","_id":"cjj5repv4001e9pd3jouwgo17"},{"name":"解题报告","_id":"cjj5risfm0002bhd3sdccedt4"},{"name":"LeetCode","_id":"cjj5risfp0003bhd3jchvmgay"},{"name":"数组","_id":"cjj5risfr0005bhd3lqlrj8tq"},{"name":"模拟","_id":"cjj5risfs0006bhd39orqj99z"},{"name":"数论","_id":"cjj5risft0007bhd30myoxc65"}]}}