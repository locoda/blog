{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/yilia/source/main.266c1c.css","path":"main.266c1c.css","modified":1,"renderable":1},{"_id":"themes/yilia/source/slider.096dc6.js","path":"slider.096dc6.js","modified":1,"renderable":1},{"_id":"themes/yilia/source/main.266c1c.js","path":"main.266c1c.js","modified":1,"renderable":1},{"_id":"themes/yilia/source/mobile.906508.js","path":"mobile.906508.js","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/default-skin.b257fa.svg","path":"fonts/default-skin.b257fa.svg","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.45d7ee.svg","path":"fonts/iconfont.45d7ee.svg","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.16acc2.ttf","path":"fonts/iconfont.16acc2.ttf","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.8c627f.woff","path":"fonts/iconfont.8c627f.woff","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.b322fa.eot","path":"fonts/iconfont.b322fa.eot","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/tooltip.4004ff.svg","path":"fonts/tooltip.4004ff.svg","modified":1,"renderable":1},{"_id":"themes/yilia/source/img/default-skin.png","path":"img/default-skin.png","modified":1,"renderable":1},{"_id":"themes/yilia/source/img/preloader.gif","path":"img/preloader.gif","modified":1,"renderable":1},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","path":"img/scrollbar_arrow.png","modified":1,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"a709efb04b1706df5a345c6c85071e00674a4298","modified":1500378836000},{"_id":"themes/yilia/.babelrc","hash":"b1b76475ac17dc9e2fa50af96c9e31eea2d0f2b4","modified":1500376158000},{"_id":"themes/yilia/.editorconfig","hash":"da6d022b8f4d9c961e2f8f80677e92af8de0db4d","modified":1500376158000},{"_id":"themes/yilia/.eslintrc.js","hash":"5696ae049de010ed3786768b0c359f14c05b5ec6","modified":1500376158000},{"_id":"themes/yilia/.eslintignore","hash":"df0a50b13cc00acb749226fee3cee6e0351fb1d9","modified":1500376158000},{"_id":"themes/yilia/.gitattributes","hash":"e0f24dceeb1e6878a1dd9b01a2b9df1bc037a867","modified":1500376158000},{"_id":"themes/yilia/.gitignore","hash":"9c4b7d27a1e3e5efa0c8ed143a032a85d586b03b","modified":1500376158000},{"_id":"themes/yilia/README.md","hash":"86757b00d393bd4956a252d92a469f11f2ae8914","modified":1500376158000},{"_id":"themes/yilia/_config.yml","hash":"3450b53d49b01b75bf3aff70a7db33888c802f95","modified":1500379255000},{"_id":"themes/yilia/package.json","hash":"367cb9579d35968a942c243ab248a5f5ebfaf462","modified":1500376158000},{"_id":"themes/yilia/webpack.config.js","hash":"05ba46a4ae744272f5312e684928910dccad3755","modified":1500376158000},{"_id":"source/_posts/.DS_Store","hash":"24f03956b716602d740d0ee54b54e9d7c2032e9a","modified":1500378299000},{"_id":"source/_posts/机器人2.md","hash":"4c3b8ab7e818fe0c1afbb7533a0fbe7613267f60","modified":1500378720000},{"_id":"source/_posts/机器人1.md","hash":"29975ed03d22b74da864900ca8b89ad33ac11e99","modified":1500378638000},{"_id":"source/_posts/机器人3.md","hash":"ae1d364ed810e96743146e8fe5cd74b12bf2f532","modified":1500378691000},{"_id":"source/_posts/机器人4.md","hash":"1f46340ffbd5b264abed95698edab3061adf7534","modified":1500378716000},{"_id":"source/_posts/猴子都能学会的用20行代码登录微博.md","hash":"b35bd5890bc5ebd0189bddf308b01c03edc90b29","modified":1500429255000},{"_id":"themes/yilia/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1500376158000},{"_id":"themes/yilia/.git/config","hash":"256e47c5a4386e6881318e44d2a716fdc3197863","modified":1500376158000},{"_id":"themes/yilia/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1500376152000},{"_id":"themes/yilia/.git/index","hash":"f189080ab181f3a7cb706ab87d5e108b797badc5","modified":1500376158000},{"_id":"themes/yilia/.git/packed-refs","hash":"4dc64835d90ebd62d3df9c760251d3ee4fe50711","modified":1500376158000},{"_id":"themes/yilia/languages/fr.yml","hash":"84ab164b37c6abf625473e9a0c18f6f815dd5fd9","modified":1500376158000},{"_id":"themes/yilia/languages/default.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1500376158000},{"_id":"themes/yilia/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1500376158000},{"_id":"themes/yilia/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1500376158000},{"_id":"themes/yilia/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1500376158000},{"_id":"themes/yilia/languages/zh-CN.yml","hash":"ca40697097ab0b3672a80b455d3f4081292d1eed","modified":1500376158000},{"_id":"themes/yilia/languages/zh-tw.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1500376158000},{"_id":"themes/yilia/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1500376158000},{"_id":"themes/yilia/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1500376158000},{"_id":"themes/yilia/layout/index.ejs","hash":"a35dc900203f9d8dd863ea4c1722198d6d457ec8","modified":1500376158000},{"_id":"themes/yilia/layout/layout.ejs","hash":"0a332bdbd3b86c231d690614687f5b97186b85d5","modified":1500376158000},{"_id":"themes/yilia/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1500376158000},{"_id":"themes/yilia/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1500376158000},{"_id":"themes/yilia/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1500376158000},{"_id":"themes/yilia/source/main.266c1c.css","hash":"6b9cfabb81f021081a93da5a069674e9be910194","modified":1500376158000},{"_id":"themes/yilia/source/slider.096dc6.js","hash":"a8b66ef85d96616086ea6256e7288d0b5a2df56d","modified":1500376158000},{"_id":"themes/yilia/source-src/css.ejs","hash":"94dbdb02ca11849e415d54fb28546a598f2cffb1","modified":1500376158000},{"_id":"themes/yilia/source-src/script.ejs","hash":"c21381e1317db7bb157f1d182b8c088cb7cba411","modified":1500376158000},{"_id":"themes/yilia/layout/_partial/toc.ejs","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1500376158000},{"_id":"themes/yilia/source/main.266c1c.js","hash":"59ccafbd45d28c397a8a901152ef5e196077e4f4","modified":1500376158000},{"_id":"themes/yilia/source/mobile.906508.js","hash":"86e50eecba93644d6cf4f78fd4f9ff54a0ea82d5","modified":1500376158000},{"_id":"themes/yilia/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1500376152000},{"_id":"themes/yilia/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1500376152000},{"_id":"themes/yilia/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1500376152000},{"_id":"themes/yilia/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1500376152000},{"_id":"themes/yilia/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1500376152000},{"_id":"themes/yilia/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1500376152000},{"_id":"themes/yilia/.git/hooks/pre-rebase.sample","hash":"5885a56ab4fca8075a05a562d005e922cde9853b","modified":1500376152000},{"_id":"themes/yilia/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1500376152000},{"_id":"themes/yilia/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1500376152000},{"_id":"themes/yilia/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1500376152000},{"_id":"themes/yilia/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1500376152000},{"_id":"themes/yilia/.git/logs/HEAD","hash":"c3ef18e9d0e12805e0f75048d53a3a1081c51dfb","modified":1500376158000},{"_id":"themes/yilia/layout/_partial/after-footer.ejs","hash":"b86b248720ad415ec1b5fee53fb583776c776f83","modified":1500376158000},{"_id":"themes/yilia/layout/_partial/archive-post.ejs","hash":"1f7d4819b7f67602c4a1b99871808d2160b60978","modified":1500376158000},{"_id":"themes/yilia/layout/_partial/archive.ejs","hash":"a6e94061ac55b9eb55275f87b608d62f6ea35659","modified":1500376158000},{"_id":"themes/yilia/layout/_partial/aside.ejs","hash":"8edbd7993b9b061611a193533a664e2e85eae748","modified":1500376158000},{"_id":"themes/yilia/layout/_partial/article.ejs","hash":"b75e8fff732292fa26b5a0b47cd253d4281e321a","modified":1500376158000},{"_id":"themes/yilia/layout/_partial/baidu-analytics.ejs","hash":"f0e6e88f9f7eb08b8fe51449a8a3016273507924","modified":1500376158000},{"_id":"themes/yilia/layout/_partial/css.ejs","hash":"9bfcbd9e71401b6da6b2bbbe61e97625ca247b7a","modified":1500376158000},{"_id":"themes/yilia/layout/_partial/head.ejs","hash":"64f092186b5a744aa1603ce22bb1d44a34446add","modified":1500376158000},{"_id":"themes/yilia/layout/_partial/footer.ejs","hash":"f2994e0acd1d606ebf4680afc4fa652e148ccf4e","modified":1500376158000},{"_id":"themes/yilia/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1500376158000},{"_id":"themes/yilia/layout/_partial/header.ejs","hash":"6387a93dad7c3d778eb91e3821852fbf6813880c","modified":1500376158000},{"_id":"themes/yilia/layout/_partial/left-col.ejs","hash":"2387d91cf94b0b36e8a36841992a5fce63ebd069","modified":1500376158000},{"_id":"themes/yilia/layout/_partial/mathjax.ejs","hash":"151a1ef2173ba7b6789d349f0f8da89616cc1394","modified":1500376158000},{"_id":"themes/yilia/layout/_partial/mobile-nav.ejs","hash":"7fbbfabf5e29525b24ada14613c21a26789132b4","modified":1500376158000},{"_id":"themes/yilia/layout/_partial/viewer.ejs","hash":"e495790b2abe2290875817e42bd505bc611d3e26","modified":1500376158000},{"_id":"themes/yilia/layout/_partial/tools.ejs","hash":"c41341b9618e591538e1136a2d1637587c1bbd90","modified":1500376158000},{"_id":"themes/yilia/source/fonts/default-skin.b257fa.svg","hash":"2ac727c9e092331d35cce95af209ccfac6d4c7c7","modified":1500376158000},{"_id":"themes/yilia/source/fonts/iconfont.45d7ee.svg","hash":"f9304e5714d20861be7d8f4d36687e88e86b9e1b","modified":1500376158000},{"_id":"themes/yilia/source/fonts/iconfont.16acc2.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1500376158000},{"_id":"themes/yilia/source/fonts/iconfont.8c627f.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1500376158000},{"_id":"themes/yilia/source/fonts/iconfont.b322fa.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1500376158000},{"_id":"themes/yilia/source/fonts/tooltip.4004ff.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1500376158000},{"_id":"themes/yilia/source/img/default-skin.png","hash":"ed95a8e40a2c3478c5915376acb8e5f33677f24d","modified":1500376158000},{"_id":"themes/yilia/source/img/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1500376158000},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1500376158000},{"_id":"themes/yilia/source-src/css/_core.scss","hash":"24f347a2412abbf58318369152504da9538f8d3b","modified":1500376158000},{"_id":"themes/yilia/source-src/css/_function.scss","hash":"93a50dd19a93485712da1f8d0a1672482dd1eabc","modified":1500376158000},{"_id":"themes/yilia/source-src/css/archive.scss","hash":"7d27e22ac898e8fafec14549e940c73cbea1fba8","modified":1500376158000},{"_id":"themes/yilia/source-src/css/article-inner.scss","hash":"d79f2d35a06de83a2a226ca790b7a0a34789c115","modified":1500376158000},{"_id":"themes/yilia/source-src/css/article-main.scss","hash":"3fad68bd74260326f83090b0974dd80707e7bac7","modified":1500376158000},{"_id":"themes/yilia/source-src/css/article-nav.scss","hash":"43e507f2a48504079afd9471353337e23ca47470","modified":1500376158000},{"_id":"themes/yilia/source-src/css/article.scss","hash":"0f6d61af99ed4db87f8589db1feaea7747b55963","modified":1500376158000},{"_id":"themes/yilia/source-src/css/aside.scss","hash":"578a67464dd0f542197f7fcee158c991db058563","modified":1500376158000},{"_id":"themes/yilia/source-src/css/comment.scss","hash":"e6e83d4863afcc589d4dd2f327e9f396f7d7b343","modified":1500376158000},{"_id":"themes/yilia/source-src/css/fonts.scss","hash":"97b8fba41c914145710b90091f400b845879577f","modified":1500376158000},{"_id":"themes/yilia/source-src/css/footer.scss","hash":"7c995410b25baaf61dfc5e148e22ca60330abcd3","modified":1500376158000},{"_id":"themes/yilia/source-src/css/global.scss","hash":"b4cb4f45a55d4250cd9056f76dab2a3c0dabcec4","modified":1500376158000},{"_id":"themes/yilia/source-src/css/grid.scss","hash":"849a29fcd7150214fcf7b9715fa5dc71d1f9b896","modified":1500376158000},{"_id":"themes/yilia/source-src/css/highlight.scss","hash":"3719994c2c9393813cc1d42b657205c368a329cb","modified":1500376158000},{"_id":"themes/yilia/source-src/css/left.scss","hash":"0d30c0e7cdb831c3881a017006c782f2214ac195","modified":1500376158000},{"_id":"themes/yilia/source-src/css/main.scss","hash":"2f86a014af93583caba78a563d9549826bf28294","modified":1500376158000},{"_id":"themes/yilia/source-src/css/mobile-slider.scss","hash":"f053c609d84df0dd9eee1d11ddf0c19163a456be","modified":1500376158000},{"_id":"themes/yilia/source-src/css/mobile.scss","hash":"ace041d72f95b419f6a5e443191703c2b62007f4","modified":1500376158000},{"_id":"themes/yilia/source-src/css/page.scss","hash":"bf206bb7f7d0967bc8b7fdf01b7ffc99aff9ba88","modified":1500376158000},{"_id":"themes/yilia/source-src/css/reward.scss","hash":"80a4fcf9171d4a33235da96ac8a2b7dcabc45dfb","modified":1500376158000},{"_id":"themes/yilia/source-src/css/social.scss","hash":"724162ccf3977e70a45d189abfaa20b6e2fba87b","modified":1500376158000},{"_id":"themes/yilia/source-src/css/scroll.scss","hash":"9c8dfd1c76854ef063494ca76fac6360b391ed6d","modified":1500376158000},{"_id":"themes/yilia/source-src/css/share.scss","hash":"150c6425f6582e7ec78a873256ce49c9930e8805","modified":1500376158000},{"_id":"themes/yilia/source-src/css/tags-cloud.scss","hash":"c8aa84fca93862d3caae77c552873b8610f33327","modified":1500376158000},{"_id":"themes/yilia/source-src/css/tags.scss","hash":"ac67a3c7097849206244db9b0ba91daaba017ef5","modified":1500376158000},{"_id":"themes/yilia/source-src/css/tooltip.scss","hash":"53d5a554bc2f38e9bb3d26400a47767013c05216","modified":1500376158000},{"_id":"themes/yilia/source-src/css/tools.scss","hash":"17a97f7c38f5dfacc3eadf354b5826d77f1c2bdb","modified":1500376158000},{"_id":"themes/yilia/source-src/js/anm.js","hash":"4a4c5d82b09a3063f91a434388e6aa064fd7fd98","modified":1500376158000},{"_id":"themes/yilia/source-src/js/Q.js","hash":"d011af172064b6c6e0c7051d8f9879373ddac113","modified":1500376158000},{"_id":"themes/yilia/source-src/js/aside.js","hash":"754f771264548a6c5a8ad842908e59ae4e7ed099","modified":1500376158000},{"_id":"themes/yilia/source-src/js/browser.js","hash":"04095b38cfd4316a23f8eb14b1ffaf95f78a4260","modified":1500376158000},{"_id":"themes/yilia/source-src/js/main.js","hash":"3894e60827c817319e43c9ff3ed045fc3d7336ce","modified":1500376158000},{"_id":"themes/yilia/source-src/js/fix.js","hash":"9bb1a4918c1b1ee62ce0a71381990a1978c51b2a","modified":1500376158000},{"_id":"themes/yilia/source-src/js/mobile.js","hash":"4d823b039fd296d24a454eae5a798b93c44560cb","modified":1500376158000},{"_id":"themes/yilia/source-src/js/report.js","hash":"4f1d9a18a936ce40b037f636a39127dd19175b6e","modified":1500376158000},{"_id":"themes/yilia/source-src/js/util.js","hash":"8456e9d6b19532742582c99b2fb9d09e146e1c58","modified":1500376158000},{"_id":"themes/yilia/source-src/js/share.js","hash":"b090f82cf80cba7da764753906d9e2cc2acdf30d","modified":1500376158000},{"_id":"themes/yilia/source-src/js/viewer.js","hash":"808a2e1ed407984cfdc929b827d3638f70ec9a2a","modified":1500376158000},{"_id":"themes/yilia/source-src/js/slider.js","hash":"3bf0d70ae171404a0dc73c33ec48927fc2521a54","modified":1500376158000},{"_id":"themes/yilia/layout/_partial/script.ejs","hash":"171b130d25c36f496e4b43e3808707a8f1897729","modified":1500376158000},{"_id":"themes/yilia/.git/objects/pack/pack-2a17f2eb11c0cabdac77304d511b48ab62c289b1.idx","hash":"7fda91f4c4e817085e6fa5a773dcbf4b32feaf4d","modified":1500376158000},{"_id":"themes/yilia/.git/refs/heads/master","hash":"4d8071322662d313a09ff7b2e716002870d8c94c","modified":1500376158000},{"_id":"themes/yilia/layout/_partial/post/category.ejs","hash":"c2dccf1a95ec09ceeee5004293ac7edb7e1c9a66","modified":1500376158000},{"_id":"themes/yilia/layout/_partial/post/changyan.ejs","hash":"9f9fa4f8b0de5f87a9494fd0cb5064502a5d5ef5","modified":1500376158000},{"_id":"themes/yilia/layout/_partial/post/date.ejs","hash":"ef71c4081e866a494367575c59610e7e6339ece0","modified":1500376158000},{"_id":"themes/yilia/layout/_partial/post/duoshuo.ejs","hash":"e8399025ed3b980aedb821c92855889f5f12fd5b","modified":1500376158000},{"_id":"themes/yilia/layout/_partial/post/nav.ejs","hash":"1036c8e4e1a7bc935ba173744da735a0d6ed09cd","modified":1500376158000},{"_id":"themes/yilia/layout/_partial/post/share.ejs","hash":"341103df70d0b476e3acd0afbc507a4a120d8f5f","modified":1500376158000},{"_id":"themes/yilia/layout/_partial/post/tag.ejs","hash":"2e783e68755abb852760eb0e627a3fbb50a05a55","modified":1500376158000},{"_id":"themes/yilia/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1500376158000},{"_id":"themes/yilia/layout/_partial/post/wangyiyun.ejs","hash":"ea41c462168d9697caef9485862e9cac718a12c1","modified":1500376158000},{"_id":"themes/yilia/source-src/css/core/_animation.scss","hash":"63a37f26276f9207405afe0f2d65339ce295bbaf","modified":1500376158000},{"_id":"themes/yilia/source-src/css/core/_media-queries.scss","hash":"491ab3378d5c11005ba65c607608bb36b368a9d5","modified":1500376158000},{"_id":"themes/yilia/source-src/css/core/_mixin.scss","hash":"3bba5c77bad5981eac859fe05c9561d580ba7fa9","modified":1500376158000},{"_id":"themes/yilia/source-src/css/core/_reset.scss","hash":"fab871fa93bd542e76a71a56428f2994a4aaf443","modified":1500376158000},{"_id":"themes/yilia/source-src/css/core/_variables.scss","hash":"fb511c505d1309249f21dc577d4ad2bad99a764f","modified":1500376158000},{"_id":"themes/yilia/source-src/css/fonts/iconfont.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1500376158000},{"_id":"themes/yilia/source-src/css/fonts/iconfont.svg","hash":"f9304e5714d20861be7d8f4d36687e88e86b9e1b","modified":1500376158000},{"_id":"themes/yilia/source-src/css/fonts/iconfont.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1500376158000},{"_id":"themes/yilia/source-src/css/fonts/iconfont.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1500376158000},{"_id":"themes/yilia/source-src/css/img/checkered-pattern.png","hash":"049262fa0886989d750637b264bed34ab51c23c8","modified":1500376158000},{"_id":"themes/yilia/source-src/css/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1500376158000},{"_id":"themes/yilia/source-src/css/img/tooltip.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1500376158000},{"_id":"themes/yilia/.git/logs/refs/heads/master","hash":"c3ef18e9d0e12805e0f75048d53a3a1081c51dfb","modified":1500376158000},{"_id":"themes/yilia/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1500376158000},{"_id":"themes/yilia/.git/logs/refs/remotes/origin/HEAD","hash":"c3ef18e9d0e12805e0f75048d53a3a1081c51dfb","modified":1500376158000},{"_id":"themes/yilia/.git/objects/pack/pack-2a17f2eb11c0cabdac77304d511b48ab62c289b1.pack","hash":"ff6c45a3fe7b42d67f4c1a44d0728b15775817f0","modified":1500376158000},{"_id":"public/2017/07/14/猴子都能学会的用20行代码登录微博/index.html","hash":"c5932fe11897978762b4c68bb707e2b6d05fac3a","modified":1500431225154},{"_id":"public/2017/06/26/机器人4/index.html","hash":"83d698517ca6edb3a271e8ce337781d3f8db45f8","modified":1500431225154},{"_id":"public/2017/06/25/机器人2/index.html","hash":"ec5d6d7e27388f371188b6e9b5224cc71056f77a","modified":1500431225155},{"_id":"public/2017/06/24/机器人3/index.html","hash":"dfb9d2627f84c3642efb6aa9e7091f2a0db32fd2","modified":1500431225155},{"_id":"public/2017/06/23/机器人1/index.html","hash":"0a28e0ae77075a58a467c526575dcfdc2f2214e9","modified":1500431225155},{"_id":"public/archives/index.html","hash":"c45ceade344eb980c9751c7e05f4d039d297a99c","modified":1500431225155},{"_id":"public/archives/2017/index.html","hash":"f8b5ba9ca05702ef0cea2817bd63592beea5a159","modified":1500431225155},{"_id":"public/archives/2017/06/index.html","hash":"2e546ba66edac7b7d6a6dc2173f6e8e5c1ff16a0","modified":1500431225156},{"_id":"public/archives/2017/07/index.html","hash":"af5a29eae7983a4e027c7fe5bd9596ca482148e8","modified":1500431225156},{"_id":"public/categories/计算机课堂/index.html","hash":"f3fc6b6d06a15adab587f39356b3bf33b727d67f","modified":1500431225156},{"_id":"public/index.html","hash":"275d3f62a622044a5c2683c541c716ad24c0a161","modified":1500431225156},{"_id":"public/tags/Python/index.html","hash":"c6882fa625bda5fc602467f5003f54f460c40ced","modified":1500431225156},{"_id":"public/tags/聊天机器人/index.html","hash":"ea6403de3caca09b7a728d5a0935eca381666dd7","modified":1500431225156},{"_id":"public/tags/爬虫/index.html","hash":"27e3bfac7c7df9e99730ceedef22601076c668e9","modified":1500431225156},{"_id":"public/fonts/default-skin.b257fa.svg","hash":"2ac727c9e092331d35cce95af209ccfac6d4c7c7","modified":1500431225159},{"_id":"public/fonts/iconfont.45d7ee.svg","hash":"f9304e5714d20861be7d8f4d36687e88e86b9e1b","modified":1500431225159},{"_id":"public/fonts/iconfont.16acc2.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1500431225159},{"_id":"public/fonts/iconfont.8c627f.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1500431225159},{"_id":"public/fonts/iconfont.b322fa.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1500431225159},{"_id":"public/fonts/tooltip.4004ff.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1500431225159},{"_id":"public/img/default-skin.png","hash":"ed95a8e40a2c3478c5915376acb8e5f33677f24d","modified":1500431225159},{"_id":"public/img/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1500431225159},{"_id":"public/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1500431225159},{"_id":"public/slider.096dc6.js","hash":"a8b66ef85d96616086ea6256e7288d0b5a2df56d","modified":1500431225165},{"_id":"public/main.266c1c.js","hash":"59ccafbd45d28c397a8a901152ef5e196077e4f4","modified":1500431225165},{"_id":"public/main.266c1c.css","hash":"6b9cfabb81f021081a93da5a069674e9be910194","modified":1500431225165},{"_id":"public/mobile.906508.js","hash":"86e50eecba93644d6cf4f78fd4f9ff54a0ea82d5","modified":1500431225165}],"Category":[{"name":"计算机课堂","_id":"cj5ae0edc00022wzkh10bik1e"}],"Data":[],"Page":[],"Post":[{"title":"从零开始微信机器人（二）：使用图灵机器人和api.ai相关接口","date":"2017-06-24T16:00:00.000Z","_content":"\n\n\n# 图灵机器人相关接口\n\n图灵机器人是一个中文语境下的对话机器人，免费的机器人每天有5000次调用的，如果放在群聊中是完全够用的（如果只有@的消息才使用机器人回复的）。图灵机器人也包括一些简单的能力，比如讲笑话、故事大全、成语接龙、新闻资讯等，我们将介绍如何简单调用图灵机器人接口。\n\n\n\n## 前期准备\n\n1. 前往注册[图灵机器人](http://www.tuling123.com/)，增加一个机器人，并记录机器人的APIKey。具体注册方法可以前往[图灵API](http://www.tuling123.com/help/h_cent_webapi.jhtml?nav=doc)查看。（如果你觉得很麻烦， 也可以暂时使用itchat提供的几个[key](http://itchat.readthedocs.io/zh/latest/tutorial/tutorial0/#3_1)）\n\n2. 安装[Requests: HTTP for Humans](http://docs.python-requests.org/)\n\n   ```shell\n   # 从 pip 安装 ()\n   pip install requests\n   ```\n\n   并在机器人中导入Requests包（写在程序最初）：\n\n   ```python\n   import requests\n   ```\n\n\n\n## 调用接口\n\nwxpy提供了图灵的接口，使用方法：\n\n```python\ntuling = Tuling(api_key='Your API Key') # 刚才申请的key\n\n@bot.register(my_friend) # 注册消息\ndef reply_my_friend(msg):\n    tuling.do_reply(msg)\n```\n\n为了让大家了解HTTP协议在python中的使用方式，我接下来会介绍如何使用请求获取信息。\n\n本节中内容如果没有特殊提示，都应写在你希望处理的某种注册了的消息方法中以保证它的正常运作。\n\n首先，将图灵API写入程序中：\n\n```python\nTULING_TOKEN = 'Your API Key'\n```\n\n然后，定义接口链接和需要传输的数据：\n\n```python\nurl_api = 'http://www.tuling123.com/openapi/api'\ndata = {\n    'key'    : TULING_TOKEN,\n    'info'   : msg.text, # 收到消息的文字内容\n}\n```\n根据文档，通过HTTP请求，我们将会得到一个json格式的文件。使用Requests包，我们可以简单的获得调用接口所返回的信息：\n\n```python\ns = requests.post(url_api, data=data).json()\nprint s # 打印所获得的json查看如何使用\n# {u'text': u'回复的内容', u'code': 100000}\n```\n\n我们发现经过请求，我们一般会得到一个字典内容，其中包括text和code两项：text是图灵机器人回复的文本，而code是返回的编号。详细的返回数据格式也可以在[图灵API](http://www.tuling123.com/help/h_cent_webapi.jhtml?nav=doc)中看到，除了文字类还有新闻类、图片类、链接类等返回类型。在这里我们以文字类为例，介绍如何处理：\n\n```python\nif s['code'] == 100000:\n\t\tprint s['text'] # 查看回复消息的内容，可省略\n\t\tmsg.reply(s['text']) # 回复消息\n```\n\n如果需要回复其他类型的消息，也完全可以通过判断code确定消息类型，再决定如何回复。这里给出我的回复方法供大家参考（也可以选择不处理这一类内容）：\n\n```python\nif s['code'] == 200000: # 链接类：回复文字和链接\n    msg.reply(s['text'] + s['url'])\n```\n\n至此，我们已经成功调用了图灵机器人的API接口进行回复，完整程序如下：\n\n```python\n# -*- coding: utf-8 -*-\n\nfrom wxpy import *\nimport requests\n\nTULING_TOKEN = 'Your API Key'\nbot = Bot()\n\n@bot.register(Group, TEXT) # 这里注册了群聊中的文字消息，测试时可以设置为自己(上篇中提到过)\ndef group_msg(msg):\n\tif msg.is_at:\n\t\turl_api = 'http://www.tuling123.com/openapi/api'\n\t\tdata = {\n\t\t    'key'    : TULING_TOKEN,\n\t\t    'info'   : msg.text, # 收到消息的文字内容\n\t\t}\n\n\t\ts = requests.post(url_api, data=data).json()\n\t\tprint s # 打印所获得的json查看如何使用\n\n\t\tif s['code'] == 100000:\n\t\t\tprint s['text'] # 查看回复消息的内容，可省略\n\t\t\tmsg.reply(s['text']) # 回复消息\n        \nembed()\n```\n以下内容更加进阶，而文末有一些简单问题的解答。如果遇到其他问题，我也会在之后更新。\n\n\n\n## 番外：使用上下文\n\nwxpy给每个用户定义了一个相对稳定的对象/用户id，为puid，可以始终被获取到并有唯一的稳定性（根据文档），我们可以使用这个id来作为userid传给图灵机器人，以方便识别机器人或航班/列成信息的上下文。\n\n```python\nbot.enable_puid() # puid 需要手动开启，请将这句话写在登陆登录之后\n```\n\n这样传送给接口的数据也要同时修改为：\n\n```python\ndata = {\n    'key'    : TULING_TOKEN,\n    'info'   : msg.text, # 收到消息的文字内容\n    'userid' : msg.member.puid, # 使用群聊中发送者的 puid 作为 userid 传送给图灵接口， 如果是私聊可以使用 msg.sender.puid\n}\n```\n这样做的好处是，图灵机器人可以根据得userid来获取上下文信息。例如你询问『天气』，它会回复『亲爱的，悄悄地告诉我你在哪个城市？』。在这种情况下，如果你不使用userid参数，你再次回复城市，图灵机器人也无法正确找到天气；如果你使用了这一参数，且两次回复使用的userid相同，图灵机器人会为你回复你回复的城市的天气情况，完成这一对话。\n\n\n\n# 使用api.ai\n\napi.ai是一家被谷歌收购的人机交互系统，主要着重于对话机器人的开发。图灵机器人虽然包括一个知识库，但其语义识别的能力较差。我所需要的机器人主要用于新生群，很多问题人与人之间会有相当多不同的表达，图灵机器人无法满足我对于群聊机器人的要求。因此，我尝试使用api.ai进行回复有针对性的一些问题。\n\n如果你的英语相对糟糕，我不建议使用api.ai。api.ai的配置大多需要使用英语，虽然接口简单，但是后台设置相对复杂，如果没有英文背景不推荐使用。\n\n这一部分内容相对进阶，如果没有特殊需要，完全可以跳过不看。这里只作一个对api.ai使用方式上大体的介绍，希望能帮助大家了解这一网站。\n\n\n\n## 前期准备\n\n1. 前往[api.ai](https://api.ai/)注册，创建机器人，并获得APIkey。虽然被谷歌收购，但是这个网站是不需要翻墙的哦！\n\n2. 安装api.ai官方提供的Python SDK\n\n   ```shell\n   pip install apiai\n   ```\n\n3. 在文件头部加入（处理返回的消息时使用）\n\n   ```python\n   import json\n   ```\n\n\n\n## 调用接口\n\n首先，我们需要设置api.ai的Token，\n\n```python\nAPIAI_TOKEN = 'Your API Key'\n```\n\n而后我们发起一个最简单的请求，一下内容都可以通过[例子](https://github.com/api-ai/apiai-python-client/tree/master/examples)找到：\n\n```python\nai = apiai.ApiAI(APIAI_TOKEN)\nrequest = ai.text_request()\nrequest.lang = 'zh-CN' # 使用中文\nrequest.session_id = msg.member.puid # api.ai 中用 session id 来区分对话对象，必须\nrequest.query = msg.text # 消息文字内容\n```\n\n然后通过接口得到传回的json：\n\n```python\nresponse = request.getresponse()\ns = json.loads(response.read(), encoding='UTF-8') # 讲传回的json转换为python字典\nprint s\n# {u'lang': u'zh-cn', u'status': {u'errorType': u'success', u'code': 200}, u'timestamp': u'20}\n```\n\n我们发现，api.ai传回的json相对于图灵机器人更加复杂。参考[api.ai的query文档](https://docs.api.ai/docs/query)，我对对这部分回复进行了如下处理：\n\n```python\nif s['result']['action'] == 'input.unknown': # \n    raise Exception('api.ai cannot reply this message') # 抛出异常：使用 try 语句捕捉后使用图灵机器人回复\nif s['status']['code'] == 200:\n    msg.reply(s['result']['fulfillment']['speech']) # 回复 api.ai 返回的内容\n```\n\n\n\n## api.ai的设置和调试\n\n在进入api.ai的机器人后，你将会看到左边的多个菜单。\n\n如果你只是简单的需要特定语句回复的功能，只需要创建并设置[Intents](https://docs.api.ai/docs/concept-intents)就可以实现。在User Says一栏中填写消息可能是什么，在下方Response处填写可能回复的内容，然后保存即可。\n\napi.ai自带机器学习功能，它的参数可以在机器人设置中的ML settings里找到。可以通过调整参数和方式让你的机器人回复更加准确。\n\n在进入机器人后，api.ai的右侧会出现一个对话框。你可以使用它进行一些基础调试。在上方输入你的消息后，下方会给出机器人的回复，你可以通过这个对话框来了解是否正确设置了机器人。（需要翻墙）\n\n# 你可能会遇到的一些问题\n\n## 报错：No handlers could be found for logger \"wxpy.api.bot\"\n\n有报错但是无法显示，可以选择在代码头部加入：\n\n```python\nimport logging\nlogging.basicConfig()\n```\n\n\n\n## 消息处理：删除@内容\n\n如果不删除消息中@部分的内容，图灵机器人的回复可能会受到昵称内容的影响，导致回复不准确，或是识别不出一些应当识别出的内容。我们可以用一段简单的代码删除@到空格之间的内容并去除首尾多余的空格。\n\n```python\nmsg_content = re.sub('@[^\\s]*', '', unicodedata.normalize('NFKC', msg.text)).strip()\n```\n\n这里使用了正则表达式，匹配@以及它之后所有不为空的字符。如果你的微信昵称中没有空白字符，这条代码是可行的。（需要在代码开头添加`import re`）","source":"_posts/机器人2.md","raw":"---\ntitle: 从零开始微信机器人（二）：使用图灵机器人和api.ai相关接口\ndate: 2017-06-25\ncategory: 计算机课堂\ntags: \n- Python\n- 聊天机器人\n---\n\n\n\n# 图灵机器人相关接口\n\n图灵机器人是一个中文语境下的对话机器人，免费的机器人每天有5000次调用的，如果放在群聊中是完全够用的（如果只有@的消息才使用机器人回复的）。图灵机器人也包括一些简单的能力，比如讲笑话、故事大全、成语接龙、新闻资讯等，我们将介绍如何简单调用图灵机器人接口。\n\n\n\n## 前期准备\n\n1. 前往注册[图灵机器人](http://www.tuling123.com/)，增加一个机器人，并记录机器人的APIKey。具体注册方法可以前往[图灵API](http://www.tuling123.com/help/h_cent_webapi.jhtml?nav=doc)查看。（如果你觉得很麻烦， 也可以暂时使用itchat提供的几个[key](http://itchat.readthedocs.io/zh/latest/tutorial/tutorial0/#3_1)）\n\n2. 安装[Requests: HTTP for Humans](http://docs.python-requests.org/)\n\n   ```shell\n   # 从 pip 安装 ()\n   pip install requests\n   ```\n\n   并在机器人中导入Requests包（写在程序最初）：\n\n   ```python\n   import requests\n   ```\n\n\n\n## 调用接口\n\nwxpy提供了图灵的接口，使用方法：\n\n```python\ntuling = Tuling(api_key='Your API Key') # 刚才申请的key\n\n@bot.register(my_friend) # 注册消息\ndef reply_my_friend(msg):\n    tuling.do_reply(msg)\n```\n\n为了让大家了解HTTP协议在python中的使用方式，我接下来会介绍如何使用请求获取信息。\n\n本节中内容如果没有特殊提示，都应写在你希望处理的某种注册了的消息方法中以保证它的正常运作。\n\n首先，将图灵API写入程序中：\n\n```python\nTULING_TOKEN = 'Your API Key'\n```\n\n然后，定义接口链接和需要传输的数据：\n\n```python\nurl_api = 'http://www.tuling123.com/openapi/api'\ndata = {\n    'key'    : TULING_TOKEN,\n    'info'   : msg.text, # 收到消息的文字内容\n}\n```\n根据文档，通过HTTP请求，我们将会得到一个json格式的文件。使用Requests包，我们可以简单的获得调用接口所返回的信息：\n\n```python\ns = requests.post(url_api, data=data).json()\nprint s # 打印所获得的json查看如何使用\n# {u'text': u'回复的内容', u'code': 100000}\n```\n\n我们发现经过请求，我们一般会得到一个字典内容，其中包括text和code两项：text是图灵机器人回复的文本，而code是返回的编号。详细的返回数据格式也可以在[图灵API](http://www.tuling123.com/help/h_cent_webapi.jhtml?nav=doc)中看到，除了文字类还有新闻类、图片类、链接类等返回类型。在这里我们以文字类为例，介绍如何处理：\n\n```python\nif s['code'] == 100000:\n\t\tprint s['text'] # 查看回复消息的内容，可省略\n\t\tmsg.reply(s['text']) # 回复消息\n```\n\n如果需要回复其他类型的消息，也完全可以通过判断code确定消息类型，再决定如何回复。这里给出我的回复方法供大家参考（也可以选择不处理这一类内容）：\n\n```python\nif s['code'] == 200000: # 链接类：回复文字和链接\n    msg.reply(s['text'] + s['url'])\n```\n\n至此，我们已经成功调用了图灵机器人的API接口进行回复，完整程序如下：\n\n```python\n# -*- coding: utf-8 -*-\n\nfrom wxpy import *\nimport requests\n\nTULING_TOKEN = 'Your API Key'\nbot = Bot()\n\n@bot.register(Group, TEXT) # 这里注册了群聊中的文字消息，测试时可以设置为自己(上篇中提到过)\ndef group_msg(msg):\n\tif msg.is_at:\n\t\turl_api = 'http://www.tuling123.com/openapi/api'\n\t\tdata = {\n\t\t    'key'    : TULING_TOKEN,\n\t\t    'info'   : msg.text, # 收到消息的文字内容\n\t\t}\n\n\t\ts = requests.post(url_api, data=data).json()\n\t\tprint s # 打印所获得的json查看如何使用\n\n\t\tif s['code'] == 100000:\n\t\t\tprint s['text'] # 查看回复消息的内容，可省略\n\t\t\tmsg.reply(s['text']) # 回复消息\n        \nembed()\n```\n以下内容更加进阶，而文末有一些简单问题的解答。如果遇到其他问题，我也会在之后更新。\n\n\n\n## 番外：使用上下文\n\nwxpy给每个用户定义了一个相对稳定的对象/用户id，为puid，可以始终被获取到并有唯一的稳定性（根据文档），我们可以使用这个id来作为userid传给图灵机器人，以方便识别机器人或航班/列成信息的上下文。\n\n```python\nbot.enable_puid() # puid 需要手动开启，请将这句话写在登陆登录之后\n```\n\n这样传送给接口的数据也要同时修改为：\n\n```python\ndata = {\n    'key'    : TULING_TOKEN,\n    'info'   : msg.text, # 收到消息的文字内容\n    'userid' : msg.member.puid, # 使用群聊中发送者的 puid 作为 userid 传送给图灵接口， 如果是私聊可以使用 msg.sender.puid\n}\n```\n这样做的好处是，图灵机器人可以根据得userid来获取上下文信息。例如你询问『天气』，它会回复『亲爱的，悄悄地告诉我你在哪个城市？』。在这种情况下，如果你不使用userid参数，你再次回复城市，图灵机器人也无法正确找到天气；如果你使用了这一参数，且两次回复使用的userid相同，图灵机器人会为你回复你回复的城市的天气情况，完成这一对话。\n\n\n\n# 使用api.ai\n\napi.ai是一家被谷歌收购的人机交互系统，主要着重于对话机器人的开发。图灵机器人虽然包括一个知识库，但其语义识别的能力较差。我所需要的机器人主要用于新生群，很多问题人与人之间会有相当多不同的表达，图灵机器人无法满足我对于群聊机器人的要求。因此，我尝试使用api.ai进行回复有针对性的一些问题。\n\n如果你的英语相对糟糕，我不建议使用api.ai。api.ai的配置大多需要使用英语，虽然接口简单，但是后台设置相对复杂，如果没有英文背景不推荐使用。\n\n这一部分内容相对进阶，如果没有特殊需要，完全可以跳过不看。这里只作一个对api.ai使用方式上大体的介绍，希望能帮助大家了解这一网站。\n\n\n\n## 前期准备\n\n1. 前往[api.ai](https://api.ai/)注册，创建机器人，并获得APIkey。虽然被谷歌收购，但是这个网站是不需要翻墙的哦！\n\n2. 安装api.ai官方提供的Python SDK\n\n   ```shell\n   pip install apiai\n   ```\n\n3. 在文件头部加入（处理返回的消息时使用）\n\n   ```python\n   import json\n   ```\n\n\n\n## 调用接口\n\n首先，我们需要设置api.ai的Token，\n\n```python\nAPIAI_TOKEN = 'Your API Key'\n```\n\n而后我们发起一个最简单的请求，一下内容都可以通过[例子](https://github.com/api-ai/apiai-python-client/tree/master/examples)找到：\n\n```python\nai = apiai.ApiAI(APIAI_TOKEN)\nrequest = ai.text_request()\nrequest.lang = 'zh-CN' # 使用中文\nrequest.session_id = msg.member.puid # api.ai 中用 session id 来区分对话对象，必须\nrequest.query = msg.text # 消息文字内容\n```\n\n然后通过接口得到传回的json：\n\n```python\nresponse = request.getresponse()\ns = json.loads(response.read(), encoding='UTF-8') # 讲传回的json转换为python字典\nprint s\n# {u'lang': u'zh-cn', u'status': {u'errorType': u'success', u'code': 200}, u'timestamp': u'20}\n```\n\n我们发现，api.ai传回的json相对于图灵机器人更加复杂。参考[api.ai的query文档](https://docs.api.ai/docs/query)，我对对这部分回复进行了如下处理：\n\n```python\nif s['result']['action'] == 'input.unknown': # \n    raise Exception('api.ai cannot reply this message') # 抛出异常：使用 try 语句捕捉后使用图灵机器人回复\nif s['status']['code'] == 200:\n    msg.reply(s['result']['fulfillment']['speech']) # 回复 api.ai 返回的内容\n```\n\n\n\n## api.ai的设置和调试\n\n在进入api.ai的机器人后，你将会看到左边的多个菜单。\n\n如果你只是简单的需要特定语句回复的功能，只需要创建并设置[Intents](https://docs.api.ai/docs/concept-intents)就可以实现。在User Says一栏中填写消息可能是什么，在下方Response处填写可能回复的内容，然后保存即可。\n\napi.ai自带机器学习功能，它的参数可以在机器人设置中的ML settings里找到。可以通过调整参数和方式让你的机器人回复更加准确。\n\n在进入机器人后，api.ai的右侧会出现一个对话框。你可以使用它进行一些基础调试。在上方输入你的消息后，下方会给出机器人的回复，你可以通过这个对话框来了解是否正确设置了机器人。（需要翻墙）\n\n# 你可能会遇到的一些问题\n\n## 报错：No handlers could be found for logger \"wxpy.api.bot\"\n\n有报错但是无法显示，可以选择在代码头部加入：\n\n```python\nimport logging\nlogging.basicConfig()\n```\n\n\n\n## 消息处理：删除@内容\n\n如果不删除消息中@部分的内容，图灵机器人的回复可能会受到昵称内容的影响，导致回复不准确，或是识别不出一些应当识别出的内容。我们可以用一段简单的代码删除@到空格之间的内容并去除首尾多余的空格。\n\n```python\nmsg_content = re.sub('@[^\\s]*', '', unicodedata.normalize('NFKC', msg.text)).strip()\n```\n\n这里使用了正则表达式，匹配@以及它之后所有不为空的字符。如果你的微信昵称中没有空白字符，这条代码是可行的。（需要在代码开头添加`import re`）","slug":"机器人2","published":1,"updated":"2017-07-18T11:52:00.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj5ae0ed300002wzkjyqvvp3u","content":"<h1 id=\"图灵机器人相关接口\"><a href=\"#图灵机器人相关接口\" class=\"headerlink\" title=\"图灵机器人相关接口\"></a>图灵机器人相关接口</h1><p>图灵机器人是一个中文语境下的对话机器人，免费的机器人每天有5000次调用的，如果放在群聊中是完全够用的（如果只有@的消息才使用机器人回复的）。图灵机器人也包括一些简单的能力，比如讲笑话、故事大全、成语接龙、新闻资讯等，我们将介绍如何简单调用图灵机器人接口。</p>\n<h2 id=\"前期准备\"><a href=\"#前期准备\" class=\"headerlink\" title=\"前期准备\"></a>前期准备</h2><ol>\n<li><p>前往注册<a href=\"http://www.tuling123.com/\" target=\"_blank\" rel=\"external\">图灵机器人</a>，增加一个机器人，并记录机器人的APIKey。具体注册方法可以前往<a href=\"http://www.tuling123.com/help/h_cent_webapi.jhtml?nav=doc\" target=\"_blank\" rel=\"external\">图灵API</a>查看。（如果你觉得很麻烦， 也可以暂时使用itchat提供的几个<a href=\"http://itchat.readthedocs.io/zh/latest/tutorial/tutorial0/#3_1\" target=\"_blank\" rel=\"external\">key</a>）</p>\n</li>\n<li><p>安装<a href=\"http://docs.python-requests.org/\" target=\"_blank\" rel=\"external\">Requests: HTTP for Humans</a></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#</span> 从 pip 安装 ()</div><div class=\"line\">pip install requests</div></pre></td></tr></table></figure>\n<p>并在机器人中导入Requests包（写在程序最初）：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> requests</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"调用接口\"><a href=\"#调用接口\" class=\"headerlink\" title=\"调用接口\"></a>调用接口</h2><p>wxpy提供了图灵的接口，使用方法：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">tuling = Tuling(api_key=<span class=\"string\">'Your API Key'</span>) <span class=\"comment\"># 刚才申请的key</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">@bot.register(my_friend) # 注册消息</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">reply_my_friend</span><span class=\"params\">(msg)</span>:</span></div><div class=\"line\">    tuling.do_reply(msg)</div></pre></td></tr></table></figure>\n<p>为了让大家了解HTTP协议在python中的使用方式，我接下来会介绍如何使用请求获取信息。</p>\n<p>本节中内容如果没有特殊提示，都应写在你希望处理的某种注册了的消息方法中以保证它的正常运作。</p>\n<p>首先，将图灵API写入程序中：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">TULING_TOKEN = <span class=\"string\">'Your API Key'</span></div></pre></td></tr></table></figure>\n<p>然后，定义接口链接和需要传输的数据：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">url_api = <span class=\"string\">'http://www.tuling123.com/openapi/api'</span></div><div class=\"line\">data = &#123;</div><div class=\"line\">    <span class=\"string\">'key'</span>    : TULING_TOKEN,</div><div class=\"line\">    <span class=\"string\">'info'</span>   : msg.text, <span class=\"comment\"># 收到消息的文字内容</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>根据文档，通过HTTP请求，我们将会得到一个json格式的文件。使用Requests包，我们可以简单的获得调用接口所返回的信息：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">s = requests.post(url_api, data=data).json()</div><div class=\"line\"><span class=\"keyword\">print</span> s <span class=\"comment\"># 打印所获得的json查看如何使用</span></div><div class=\"line\"><span class=\"comment\"># &#123;u'text': u'回复的内容', u'code': 100000&#125;</span></div></pre></td></tr></table></figure>\n<p>我们发现经过请求，我们一般会得到一个字典内容，其中包括text和code两项：text是图灵机器人回复的文本，而code是返回的编号。详细的返回数据格式也可以在<a href=\"http://www.tuling123.com/help/h_cent_webapi.jhtml?nav=doc\" target=\"_blank\" rel=\"external\">图灵API</a>中看到，除了文字类还有新闻类、图片类、链接类等返回类型。在这里我们以文字类为例，介绍如何处理：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> s[<span class=\"string\">'code'</span>] == <span class=\"number\">100000</span>:</div><div class=\"line\">\t\t<span class=\"keyword\">print</span> s[<span class=\"string\">'text'</span>] <span class=\"comment\"># 查看回复消息的内容，可省略</span></div><div class=\"line\">\t\tmsg.reply(s[<span class=\"string\">'text'</span>]) <span class=\"comment\"># 回复消息</span></div></pre></td></tr></table></figure>\n<p>如果需要回复其他类型的消息，也完全可以通过判断code确定消息类型，再决定如何回复。这里给出我的回复方法供大家参考（也可以选择不处理这一类内容）：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> s[<span class=\"string\">'code'</span>] == <span class=\"number\">200000</span>: <span class=\"comment\"># 链接类：回复文字和链接</span></div><div class=\"line\">    msg.reply(s[<span class=\"string\">'text'</span>] + s[<span class=\"string\">'url'</span>])</div></pre></td></tr></table></figure>\n<p>至此，我们已经成功调用了图灵机器人的API接口进行回复，完整程序如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># -*- coding: utf-8 -*-</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">from</span> wxpy <span class=\"keyword\">import</span> *</div><div class=\"line\"><span class=\"keyword\">import</span> requests</div><div class=\"line\"></div><div class=\"line\">TULING_TOKEN = <span class=\"string\">'Your API Key'</span></div><div class=\"line\">bot = Bot()</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">@bot.register(Group, TEXT) # 这里注册了群聊中的文字消息，测试时可以设置为自己(上篇中提到过)</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">group_msg</span><span class=\"params\">(msg)</span>:</span></div><div class=\"line\">\t<span class=\"keyword\">if</span> msg.is_at:</div><div class=\"line\">\t\turl_api = <span class=\"string\">'http://www.tuling123.com/openapi/api'</span></div><div class=\"line\">\t\tdata = &#123;</div><div class=\"line\">\t\t    <span class=\"string\">'key'</span>    : TULING_TOKEN,</div><div class=\"line\">\t\t    <span class=\"string\">'info'</span>   : msg.text, <span class=\"comment\"># 收到消息的文字内容</span></div><div class=\"line\">\t\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t\ts = requests.post(url_api, data=data).json()</div><div class=\"line\">\t\t<span class=\"keyword\">print</span> s <span class=\"comment\"># 打印所获得的json查看如何使用</span></div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"keyword\">if</span> s[<span class=\"string\">'code'</span>] == <span class=\"number\">100000</span>:</div><div class=\"line\">\t\t\t<span class=\"keyword\">print</span> s[<span class=\"string\">'text'</span>] <span class=\"comment\"># 查看回复消息的内容，可省略</span></div><div class=\"line\">\t\t\tmsg.reply(s[<span class=\"string\">'text'</span>]) <span class=\"comment\"># 回复消息</span></div><div class=\"line\">        </div><div class=\"line\">embed()</div></pre></td></tr></table></figure>\n<p>以下内容更加进阶，而文末有一些简单问题的解答。如果遇到其他问题，我也会在之后更新。</p>\n<h2 id=\"番外：使用上下文\"><a href=\"#番外：使用上下文\" class=\"headerlink\" title=\"番外：使用上下文\"></a>番外：使用上下文</h2><p>wxpy给每个用户定义了一个相对稳定的对象/用户id，为puid，可以始终被获取到并有唯一的稳定性（根据文档），我们可以使用这个id来作为userid传给图灵机器人，以方便识别机器人或航班/列成信息的上下文。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">bot.enable_puid() <span class=\"comment\"># puid 需要手动开启，请将这句话写在登陆登录之后</span></div></pre></td></tr></table></figure>\n<p>这样传送给接口的数据也要同时修改为：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">data = &#123;</div><div class=\"line\">    <span class=\"string\">'key'</span>    : TULING_TOKEN,</div><div class=\"line\">    <span class=\"string\">'info'</span>   : msg.text, <span class=\"comment\"># 收到消息的文字内容</span></div><div class=\"line\">    <span class=\"string\">'userid'</span> : msg.member.puid, <span class=\"comment\"># 使用群聊中发送者的 puid 作为 userid 传送给图灵接口， 如果是私聊可以使用 msg.sender.puid</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这样做的好处是，图灵机器人可以根据得userid来获取上下文信息。例如你询问『天气』，它会回复『亲爱的，悄悄地告诉我你在哪个城市？』。在这种情况下，如果你不使用userid参数，你再次回复城市，图灵机器人也无法正确找到天气；如果你使用了这一参数，且两次回复使用的userid相同，图灵机器人会为你回复你回复的城市的天气情况，完成这一对话。</p>\n<h1 id=\"使用api-ai\"><a href=\"#使用api-ai\" class=\"headerlink\" title=\"使用api.ai\"></a>使用api.ai</h1><p>api.ai是一家被谷歌收购的人机交互系统，主要着重于对话机器人的开发。图灵机器人虽然包括一个知识库，但其语义识别的能力较差。我所需要的机器人主要用于新生群，很多问题人与人之间会有相当多不同的表达，图灵机器人无法满足我对于群聊机器人的要求。因此，我尝试使用api.ai进行回复有针对性的一些问题。</p>\n<p>如果你的英语相对糟糕，我不建议使用api.ai。api.ai的配置大多需要使用英语，虽然接口简单，但是后台设置相对复杂，如果没有英文背景不推荐使用。</p>\n<p>这一部分内容相对进阶，如果没有特殊需要，完全可以跳过不看。这里只作一个对api.ai使用方式上大体的介绍，希望能帮助大家了解这一网站。</p>\n<h2 id=\"前期准备-1\"><a href=\"#前期准备-1\" class=\"headerlink\" title=\"前期准备\"></a>前期准备</h2><ol>\n<li><p>前往<a href=\"https://api.ai/\" target=\"_blank\" rel=\"external\">api.ai</a>注册，创建机器人，并获得APIkey。虽然被谷歌收购，但是这个网站是不需要翻墙的哦！</p>\n</li>\n<li><p>安装api.ai官方提供的Python SDK</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">pip install apiai</div></pre></td></tr></table></figure>\n</li>\n<li><p>在文件头部加入（处理返回的消息时使用）</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> json</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"调用接口-1\"><a href=\"#调用接口-1\" class=\"headerlink\" title=\"调用接口\"></a>调用接口</h2><p>首先，我们需要设置api.ai的Token，</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">APIAI_TOKEN = <span class=\"string\">'Your API Key'</span></div></pre></td></tr></table></figure>\n<p>而后我们发起一个最简单的请求，一下内容都可以通过<a href=\"https://github.com/api-ai/apiai-python-client/tree/master/examples\" target=\"_blank\" rel=\"external\">例子</a>找到：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">ai = apiai.ApiAI(APIAI_TOKEN)</div><div class=\"line\">request = ai.text_request()</div><div class=\"line\">request.lang = <span class=\"string\">'zh-CN'</span> <span class=\"comment\"># 使用中文</span></div><div class=\"line\">request.session_id = msg.member.puid <span class=\"comment\"># api.ai 中用 session id 来区分对话对象，必须</span></div><div class=\"line\">request.query = msg.text <span class=\"comment\"># 消息文字内容</span></div></pre></td></tr></table></figure>\n<p>然后通过接口得到传回的json：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">response = request.getresponse()</div><div class=\"line\">s = json.loads(response.read(), encoding=<span class=\"string\">'UTF-8'</span>) <span class=\"comment\"># 讲传回的json转换为python字典</span></div><div class=\"line\"><span class=\"keyword\">print</span> s</div><div class=\"line\"><span class=\"comment\"># &#123;u'lang': u'zh-cn', u'status': &#123;u'errorType': u'success', u'code': 200&#125;, u'timestamp': u'20&#125;</span></div></pre></td></tr></table></figure>\n<p>我们发现，api.ai传回的json相对于图灵机器人更加复杂。参考<a href=\"https://docs.api.ai/docs/query\" target=\"_blank\" rel=\"external\">api.ai的query文档</a>，我对对这部分回复进行了如下处理：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> s[<span class=\"string\">'result'</span>][<span class=\"string\">'action'</span>] == <span class=\"string\">'input.unknown'</span>: <span class=\"comment\"># </span></div><div class=\"line\">    <span class=\"keyword\">raise</span> Exception(<span class=\"string\">'api.ai cannot reply this message'</span>) <span class=\"comment\"># 抛出异常：使用 try 语句捕捉后使用图灵机器人回复</span></div><div class=\"line\"><span class=\"keyword\">if</span> s[<span class=\"string\">'status'</span>][<span class=\"string\">'code'</span>] == <span class=\"number\">200</span>:</div><div class=\"line\">    msg.reply(s[<span class=\"string\">'result'</span>][<span class=\"string\">'fulfillment'</span>][<span class=\"string\">'speech'</span>]) <span class=\"comment\"># 回复 api.ai 返回的内容</span></div></pre></td></tr></table></figure>\n<h2 id=\"api-ai的设置和调试\"><a href=\"#api-ai的设置和调试\" class=\"headerlink\" title=\"api.ai的设置和调试\"></a>api.ai的设置和调试</h2><p>在进入api.ai的机器人后，你将会看到左边的多个菜单。</p>\n<p>如果你只是简单的需要特定语句回复的功能，只需要创建并设置<a href=\"https://docs.api.ai/docs/concept-intents\" target=\"_blank\" rel=\"external\">Intents</a>就可以实现。在User Says一栏中填写消息可能是什么，在下方Response处填写可能回复的内容，然后保存即可。</p>\n<p>api.ai自带机器学习功能，它的参数可以在机器人设置中的ML settings里找到。可以通过调整参数和方式让你的机器人回复更加准确。</p>\n<p>在进入机器人后，api.ai的右侧会出现一个对话框。你可以使用它进行一些基础调试。在上方输入你的消息后，下方会给出机器人的回复，你可以通过这个对话框来了解是否正确设置了机器人。（需要翻墙）</p>\n<h1 id=\"你可能会遇到的一些问题\"><a href=\"#你可能会遇到的一些问题\" class=\"headerlink\" title=\"你可能会遇到的一些问题\"></a>你可能会遇到的一些问题</h1><h2 id=\"报错：No-handlers-could-be-found-for-logger-“wxpy-api-bot”\"><a href=\"#报错：No-handlers-could-be-found-for-logger-“wxpy-api-bot”\" class=\"headerlink\" title=\"报错：No handlers could be found for logger “wxpy.api.bot”\"></a>报错：No handlers could be found for logger “wxpy.api.bot”</h2><p>有报错但是无法显示，可以选择在代码头部加入：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> logging</div><div class=\"line\">logging.basicConfig()</div></pre></td></tr></table></figure>\n<h2 id=\"消息处理：删除-内容\"><a href=\"#消息处理：删除-内容\" class=\"headerlink\" title=\"消息处理：删除@内容\"></a>消息处理：删除@内容</h2><p>如果不删除消息中@部分的内容，图灵机器人的回复可能会受到昵称内容的影响，导致回复不准确，或是识别不出一些应当识别出的内容。我们可以用一段简单的代码删除@到空格之间的内容并去除首尾多余的空格。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">msg_content = re.sub(<span class=\"string\">'@[^\\s]*'</span>, <span class=\"string\">''</span>, unicodedata.normalize(<span class=\"string\">'NFKC'</span>, msg.text)).strip()</div></pre></td></tr></table></figure>\n<p>这里使用了正则表达式，匹配@以及它之后所有不为空的字符。如果你的微信昵称中没有空白字符，这条代码是可行的。（需要在代码开头添加<code>import re</code>）</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"图灵机器人相关接口\"><a href=\"#图灵机器人相关接口\" class=\"headerlink\" title=\"图灵机器人相关接口\"></a>图灵机器人相关接口</h1><p>图灵机器人是一个中文语境下的对话机器人，免费的机器人每天有5000次调用的，如果放在群聊中是完全够用的（如果只有@的消息才使用机器人回复的）。图灵机器人也包括一些简单的能力，比如讲笑话、故事大全、成语接龙、新闻资讯等，我们将介绍如何简单调用图灵机器人接口。</p>\n<h2 id=\"前期准备\"><a href=\"#前期准备\" class=\"headerlink\" title=\"前期准备\"></a>前期准备</h2><ol>\n<li><p>前往注册<a href=\"http://www.tuling123.com/\" target=\"_blank\" rel=\"external\">图灵机器人</a>，增加一个机器人，并记录机器人的APIKey。具体注册方法可以前往<a href=\"http://www.tuling123.com/help/h_cent_webapi.jhtml?nav=doc\" target=\"_blank\" rel=\"external\">图灵API</a>查看。（如果你觉得很麻烦， 也可以暂时使用itchat提供的几个<a href=\"http://itchat.readthedocs.io/zh/latest/tutorial/tutorial0/#3_1\" target=\"_blank\" rel=\"external\">key</a>）</p>\n</li>\n<li><p>安装<a href=\"http://docs.python-requests.org/\" target=\"_blank\" rel=\"external\">Requests: HTTP for Humans</a></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#</span> 从 pip 安装 ()</div><div class=\"line\">pip install requests</div></pre></td></tr></table></figure>\n<p>并在机器人中导入Requests包（写在程序最初）：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> requests</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"调用接口\"><a href=\"#调用接口\" class=\"headerlink\" title=\"调用接口\"></a>调用接口</h2><p>wxpy提供了图灵的接口，使用方法：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">tuling = Tuling(api_key=<span class=\"string\">'Your API Key'</span>) <span class=\"comment\"># 刚才申请的key</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">@bot.register(my_friend) # 注册消息</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">reply_my_friend</span><span class=\"params\">(msg)</span>:</span></div><div class=\"line\">    tuling.do_reply(msg)</div></pre></td></tr></table></figure>\n<p>为了让大家了解HTTP协议在python中的使用方式，我接下来会介绍如何使用请求获取信息。</p>\n<p>本节中内容如果没有特殊提示，都应写在你希望处理的某种注册了的消息方法中以保证它的正常运作。</p>\n<p>首先，将图灵API写入程序中：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">TULING_TOKEN = <span class=\"string\">'Your API Key'</span></div></pre></td></tr></table></figure>\n<p>然后，定义接口链接和需要传输的数据：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">url_api = <span class=\"string\">'http://www.tuling123.com/openapi/api'</span></div><div class=\"line\">data = &#123;</div><div class=\"line\">    <span class=\"string\">'key'</span>    : TULING_TOKEN,</div><div class=\"line\">    <span class=\"string\">'info'</span>   : msg.text, <span class=\"comment\"># 收到消息的文字内容</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>根据文档，通过HTTP请求，我们将会得到一个json格式的文件。使用Requests包，我们可以简单的获得调用接口所返回的信息：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">s = requests.post(url_api, data=data).json()</div><div class=\"line\"><span class=\"keyword\">print</span> s <span class=\"comment\"># 打印所获得的json查看如何使用</span></div><div class=\"line\"><span class=\"comment\"># &#123;u'text': u'回复的内容', u'code': 100000&#125;</span></div></pre></td></tr></table></figure>\n<p>我们发现经过请求，我们一般会得到一个字典内容，其中包括text和code两项：text是图灵机器人回复的文本，而code是返回的编号。详细的返回数据格式也可以在<a href=\"http://www.tuling123.com/help/h_cent_webapi.jhtml?nav=doc\" target=\"_blank\" rel=\"external\">图灵API</a>中看到，除了文字类还有新闻类、图片类、链接类等返回类型。在这里我们以文字类为例，介绍如何处理：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> s[<span class=\"string\">'code'</span>] == <span class=\"number\">100000</span>:</div><div class=\"line\">\t\t<span class=\"keyword\">print</span> s[<span class=\"string\">'text'</span>] <span class=\"comment\"># 查看回复消息的内容，可省略</span></div><div class=\"line\">\t\tmsg.reply(s[<span class=\"string\">'text'</span>]) <span class=\"comment\"># 回复消息</span></div></pre></td></tr></table></figure>\n<p>如果需要回复其他类型的消息，也完全可以通过判断code确定消息类型，再决定如何回复。这里给出我的回复方法供大家参考（也可以选择不处理这一类内容）：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> s[<span class=\"string\">'code'</span>] == <span class=\"number\">200000</span>: <span class=\"comment\"># 链接类：回复文字和链接</span></div><div class=\"line\">    msg.reply(s[<span class=\"string\">'text'</span>] + s[<span class=\"string\">'url'</span>])</div></pre></td></tr></table></figure>\n<p>至此，我们已经成功调用了图灵机器人的API接口进行回复，完整程序如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># -*- coding: utf-8 -*-</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">from</span> wxpy <span class=\"keyword\">import</span> *</div><div class=\"line\"><span class=\"keyword\">import</span> requests</div><div class=\"line\"></div><div class=\"line\">TULING_TOKEN = <span class=\"string\">'Your API Key'</span></div><div class=\"line\">bot = Bot()</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">@bot.register(Group, TEXT) # 这里注册了群聊中的文字消息，测试时可以设置为自己(上篇中提到过)</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">group_msg</span><span class=\"params\">(msg)</span>:</span></div><div class=\"line\">\t<span class=\"keyword\">if</span> msg.is_at:</div><div class=\"line\">\t\turl_api = <span class=\"string\">'http://www.tuling123.com/openapi/api'</span></div><div class=\"line\">\t\tdata = &#123;</div><div class=\"line\">\t\t    <span class=\"string\">'key'</span>    : TULING_TOKEN,</div><div class=\"line\">\t\t    <span class=\"string\">'info'</span>   : msg.text, <span class=\"comment\"># 收到消息的文字内容</span></div><div class=\"line\">\t\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t\ts = requests.post(url_api, data=data).json()</div><div class=\"line\">\t\t<span class=\"keyword\">print</span> s <span class=\"comment\"># 打印所获得的json查看如何使用</span></div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"keyword\">if</span> s[<span class=\"string\">'code'</span>] == <span class=\"number\">100000</span>:</div><div class=\"line\">\t\t\t<span class=\"keyword\">print</span> s[<span class=\"string\">'text'</span>] <span class=\"comment\"># 查看回复消息的内容，可省略</span></div><div class=\"line\">\t\t\tmsg.reply(s[<span class=\"string\">'text'</span>]) <span class=\"comment\"># 回复消息</span></div><div class=\"line\">        </div><div class=\"line\">embed()</div></pre></td></tr></table></figure>\n<p>以下内容更加进阶，而文末有一些简单问题的解答。如果遇到其他问题，我也会在之后更新。</p>\n<h2 id=\"番外：使用上下文\"><a href=\"#番外：使用上下文\" class=\"headerlink\" title=\"番外：使用上下文\"></a>番外：使用上下文</h2><p>wxpy给每个用户定义了一个相对稳定的对象/用户id，为puid，可以始终被获取到并有唯一的稳定性（根据文档），我们可以使用这个id来作为userid传给图灵机器人，以方便识别机器人或航班/列成信息的上下文。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">bot.enable_puid() <span class=\"comment\"># puid 需要手动开启，请将这句话写在登陆登录之后</span></div></pre></td></tr></table></figure>\n<p>这样传送给接口的数据也要同时修改为：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">data = &#123;</div><div class=\"line\">    <span class=\"string\">'key'</span>    : TULING_TOKEN,</div><div class=\"line\">    <span class=\"string\">'info'</span>   : msg.text, <span class=\"comment\"># 收到消息的文字内容</span></div><div class=\"line\">    <span class=\"string\">'userid'</span> : msg.member.puid, <span class=\"comment\"># 使用群聊中发送者的 puid 作为 userid 传送给图灵接口， 如果是私聊可以使用 msg.sender.puid</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这样做的好处是，图灵机器人可以根据得userid来获取上下文信息。例如你询问『天气』，它会回复『亲爱的，悄悄地告诉我你在哪个城市？』。在这种情况下，如果你不使用userid参数，你再次回复城市，图灵机器人也无法正确找到天气；如果你使用了这一参数，且两次回复使用的userid相同，图灵机器人会为你回复你回复的城市的天气情况，完成这一对话。</p>\n<h1 id=\"使用api-ai\"><a href=\"#使用api-ai\" class=\"headerlink\" title=\"使用api.ai\"></a>使用api.ai</h1><p>api.ai是一家被谷歌收购的人机交互系统，主要着重于对话机器人的开发。图灵机器人虽然包括一个知识库，但其语义识别的能力较差。我所需要的机器人主要用于新生群，很多问题人与人之间会有相当多不同的表达，图灵机器人无法满足我对于群聊机器人的要求。因此，我尝试使用api.ai进行回复有针对性的一些问题。</p>\n<p>如果你的英语相对糟糕，我不建议使用api.ai。api.ai的配置大多需要使用英语，虽然接口简单，但是后台设置相对复杂，如果没有英文背景不推荐使用。</p>\n<p>这一部分内容相对进阶，如果没有特殊需要，完全可以跳过不看。这里只作一个对api.ai使用方式上大体的介绍，希望能帮助大家了解这一网站。</p>\n<h2 id=\"前期准备-1\"><a href=\"#前期准备-1\" class=\"headerlink\" title=\"前期准备\"></a>前期准备</h2><ol>\n<li><p>前往<a href=\"https://api.ai/\" target=\"_blank\" rel=\"external\">api.ai</a>注册，创建机器人，并获得APIkey。虽然被谷歌收购，但是这个网站是不需要翻墙的哦！</p>\n</li>\n<li><p>安装api.ai官方提供的Python SDK</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">pip install apiai</div></pre></td></tr></table></figure>\n</li>\n<li><p>在文件头部加入（处理返回的消息时使用）</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> json</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"调用接口-1\"><a href=\"#调用接口-1\" class=\"headerlink\" title=\"调用接口\"></a>调用接口</h2><p>首先，我们需要设置api.ai的Token，</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">APIAI_TOKEN = <span class=\"string\">'Your API Key'</span></div></pre></td></tr></table></figure>\n<p>而后我们发起一个最简单的请求，一下内容都可以通过<a href=\"https://github.com/api-ai/apiai-python-client/tree/master/examples\" target=\"_blank\" rel=\"external\">例子</a>找到：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">ai = apiai.ApiAI(APIAI_TOKEN)</div><div class=\"line\">request = ai.text_request()</div><div class=\"line\">request.lang = <span class=\"string\">'zh-CN'</span> <span class=\"comment\"># 使用中文</span></div><div class=\"line\">request.session_id = msg.member.puid <span class=\"comment\"># api.ai 中用 session id 来区分对话对象，必须</span></div><div class=\"line\">request.query = msg.text <span class=\"comment\"># 消息文字内容</span></div></pre></td></tr></table></figure>\n<p>然后通过接口得到传回的json：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">response = request.getresponse()</div><div class=\"line\">s = json.loads(response.read(), encoding=<span class=\"string\">'UTF-8'</span>) <span class=\"comment\"># 讲传回的json转换为python字典</span></div><div class=\"line\"><span class=\"keyword\">print</span> s</div><div class=\"line\"><span class=\"comment\"># &#123;u'lang': u'zh-cn', u'status': &#123;u'errorType': u'success', u'code': 200&#125;, u'timestamp': u'20&#125;</span></div></pre></td></tr></table></figure>\n<p>我们发现，api.ai传回的json相对于图灵机器人更加复杂。参考<a href=\"https://docs.api.ai/docs/query\" target=\"_blank\" rel=\"external\">api.ai的query文档</a>，我对对这部分回复进行了如下处理：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> s[<span class=\"string\">'result'</span>][<span class=\"string\">'action'</span>] == <span class=\"string\">'input.unknown'</span>: <span class=\"comment\"># </span></div><div class=\"line\">    <span class=\"keyword\">raise</span> Exception(<span class=\"string\">'api.ai cannot reply this message'</span>) <span class=\"comment\"># 抛出异常：使用 try 语句捕捉后使用图灵机器人回复</span></div><div class=\"line\"><span class=\"keyword\">if</span> s[<span class=\"string\">'status'</span>][<span class=\"string\">'code'</span>] == <span class=\"number\">200</span>:</div><div class=\"line\">    msg.reply(s[<span class=\"string\">'result'</span>][<span class=\"string\">'fulfillment'</span>][<span class=\"string\">'speech'</span>]) <span class=\"comment\"># 回复 api.ai 返回的内容</span></div></pre></td></tr></table></figure>\n<h2 id=\"api-ai的设置和调试\"><a href=\"#api-ai的设置和调试\" class=\"headerlink\" title=\"api.ai的设置和调试\"></a>api.ai的设置和调试</h2><p>在进入api.ai的机器人后，你将会看到左边的多个菜单。</p>\n<p>如果你只是简单的需要特定语句回复的功能，只需要创建并设置<a href=\"https://docs.api.ai/docs/concept-intents\" target=\"_blank\" rel=\"external\">Intents</a>就可以实现。在User Says一栏中填写消息可能是什么，在下方Response处填写可能回复的内容，然后保存即可。</p>\n<p>api.ai自带机器学习功能，它的参数可以在机器人设置中的ML settings里找到。可以通过调整参数和方式让你的机器人回复更加准确。</p>\n<p>在进入机器人后，api.ai的右侧会出现一个对话框。你可以使用它进行一些基础调试。在上方输入你的消息后，下方会给出机器人的回复，你可以通过这个对话框来了解是否正确设置了机器人。（需要翻墙）</p>\n<h1 id=\"你可能会遇到的一些问题\"><a href=\"#你可能会遇到的一些问题\" class=\"headerlink\" title=\"你可能会遇到的一些问题\"></a>你可能会遇到的一些问题</h1><h2 id=\"报错：No-handlers-could-be-found-for-logger-“wxpy-api-bot”\"><a href=\"#报错：No-handlers-could-be-found-for-logger-“wxpy-api-bot”\" class=\"headerlink\" title=\"报错：No handlers could be found for logger “wxpy.api.bot”\"></a>报错：No handlers could be found for logger “wxpy.api.bot”</h2><p>有报错但是无法显示，可以选择在代码头部加入：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> logging</div><div class=\"line\">logging.basicConfig()</div></pre></td></tr></table></figure>\n<h2 id=\"消息处理：删除-内容\"><a href=\"#消息处理：删除-内容\" class=\"headerlink\" title=\"消息处理：删除@内容\"></a>消息处理：删除@内容</h2><p>如果不删除消息中@部分的内容，图灵机器人的回复可能会受到昵称内容的影响，导致回复不准确，或是识别不出一些应当识别出的内容。我们可以用一段简单的代码删除@到空格之间的内容并去除首尾多余的空格。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">msg_content = re.sub(<span class=\"string\">'@[^\\s]*'</span>, <span class=\"string\">''</span>, unicodedata.normalize(<span class=\"string\">'NFKC'</span>, msg.text)).strip()</div></pre></td></tr></table></figure>\n<p>这里使用了正则表达式，匹配@以及它之后所有不为空的字符。如果你的微信昵称中没有空白字符，这条代码是可行的。（需要在代码开头添加<code>import re</code>）</p>\n"},{"title":"从零开始微信机器人（三）：表情机器人的制作","date":"2017-06-23T16:00:00.000Z","_content":"\n\n\n本篇的诞生来自于一朋友制作的表情机器人。当时觉得十分有趣，也希望加入到群聊机器人中，因此就向他讨要了[源代码](https://github.com/qwIvan/microMsg-bot)并制作了表情功能。在此我也再次感谢[吴毅凡](https://github.com/qwIvan)同学的协助！\n\n\n\n## 准备工作\n\n由于需要读取网页内容，本文中由于我个人偏好使用xpath来选择网页中元素，使用了[lxml](http://lxml.de/)包，安装的话需要：\n\n```shell\npip install lxml\n```\n\n如果你想要使用[BeautifulSoup](https://www.crummy.com/software/BeautifulSoup/bs4/doc/)来处理网页，请安装：\n\n```shell\npip install beautifulsoup4\n```\n\n\n\n## 使用斗图啦搜索表情\n\n由于[斗图啦](https://www.doutula.com/)是明文传输数据搜索的，我们可以简单地通过\n\n```python\nres = requests.get('https://www.doutula.com/search', {'keyword': keyword})\n```\n\n来获取关键词keyword的搜索结果页面。\n\n本例中我使用xpath来选择元素，其具体教程你可以查看[这里](http://www.w3school.com.cn/xpath/index.asp)。如果你想使用`BeautifulSoup`，可以查看[这里](https://github.com/qwIvan/microMsg-bot/blob/master/meme.py#L7)。\n\n```python\nhtml = etree.HTML(res.text)\nurl = 'http:' + random.choice(html.xpath('//div[@class=\"image-container\"][1]//img[contains(@class, \"img-responsive\")]/@data-original'))\n```\n\n其中`//div[@class=\"image-container\"][1]`选择了页面中的第一个`image-container`元素，如果你观察斗图啦搜索界面，你会发现它分为上下两部分：上面是表情的搜索结果，下半部分则是文章的搜索结果，这样我们就仅挑选了上半部分的表情搜索结果。而`//img[contains(@class, \"img-responsive\")]/@data-original'`部分则选择了所有`class`里包含`img-responsive`的`img`元素，也就是我们要的图片本身，仔细观察元素本身你会发现图片链接就在其中的`data-original`属性下（但是需要加上http协议）。\n\nChrome的审查元素功能可以帮助你快速判断自己编写的xpath能否准确选出你想要的元素，也能够查看元素本身。\n\n\n\n## 储存图片\n\n因为wxpy自动将gif文件判断作为表情发送，我们可以利用这一点把表情作为表情（而非图片）发送到聊天中。\n\n首先我们使用了临时文件：\n\n```python\nfrom tempfile import NamedTemporaryFile\n```\n\n通过request获取图片信息，然后写入到一个临时文件中。\n\n```python\nres = requests.get(url, allow_redirects=False)\ntmp = NamedTemporaryFile()\ntmp.write(res.content)\ntmp.flush()\n```\n\n\n\n## 上传图片并作为表情发送\n\nwxpy提供了上传文件的通道，而上传后的文件就可以免去重新上传直接发送。\n\n```python\nmedia_id = bot.upload_file(tmp.name)\ntmp.close()\nmsg.reply_image('.gif', media_id=media_id)\n```\n\n在这里，用我们前文提到的方法，使用`.gif`来进行表情的发送。\n\n如果你想直接发送图片，可以简单地讲`.gif`参数去除：\n\n```python\nmsg.reply_image('', media_id=media_id)\n```\n\nwxpy的作者表示将在之后的版本中更新图片发送的接口以将图片发送和表情发送分开，我相信这一设计会是更加优秀的。","source":"_posts/机器人3.md","raw":"---\ntitle: 从零开始微信机器人（三）：表情机器人的制作\ndate: 2017-06-24\ncategory: 计算机课堂\ntags: \n- Python\n- 聊天机器人\n---\n\n\n\n本篇的诞生来自于一朋友制作的表情机器人。当时觉得十分有趣，也希望加入到群聊机器人中，因此就向他讨要了[源代码](https://github.com/qwIvan/microMsg-bot)并制作了表情功能。在此我也再次感谢[吴毅凡](https://github.com/qwIvan)同学的协助！\n\n\n\n## 准备工作\n\n由于需要读取网页内容，本文中由于我个人偏好使用xpath来选择网页中元素，使用了[lxml](http://lxml.de/)包，安装的话需要：\n\n```shell\npip install lxml\n```\n\n如果你想要使用[BeautifulSoup](https://www.crummy.com/software/BeautifulSoup/bs4/doc/)来处理网页，请安装：\n\n```shell\npip install beautifulsoup4\n```\n\n\n\n## 使用斗图啦搜索表情\n\n由于[斗图啦](https://www.doutula.com/)是明文传输数据搜索的，我们可以简单地通过\n\n```python\nres = requests.get('https://www.doutula.com/search', {'keyword': keyword})\n```\n\n来获取关键词keyword的搜索结果页面。\n\n本例中我使用xpath来选择元素，其具体教程你可以查看[这里](http://www.w3school.com.cn/xpath/index.asp)。如果你想使用`BeautifulSoup`，可以查看[这里](https://github.com/qwIvan/microMsg-bot/blob/master/meme.py#L7)。\n\n```python\nhtml = etree.HTML(res.text)\nurl = 'http:' + random.choice(html.xpath('//div[@class=\"image-container\"][1]//img[contains(@class, \"img-responsive\")]/@data-original'))\n```\n\n其中`//div[@class=\"image-container\"][1]`选择了页面中的第一个`image-container`元素，如果你观察斗图啦搜索界面，你会发现它分为上下两部分：上面是表情的搜索结果，下半部分则是文章的搜索结果，这样我们就仅挑选了上半部分的表情搜索结果。而`//img[contains(@class, \"img-responsive\")]/@data-original'`部分则选择了所有`class`里包含`img-responsive`的`img`元素，也就是我们要的图片本身，仔细观察元素本身你会发现图片链接就在其中的`data-original`属性下（但是需要加上http协议）。\n\nChrome的审查元素功能可以帮助你快速判断自己编写的xpath能否准确选出你想要的元素，也能够查看元素本身。\n\n\n\n## 储存图片\n\n因为wxpy自动将gif文件判断作为表情发送，我们可以利用这一点把表情作为表情（而非图片）发送到聊天中。\n\n首先我们使用了临时文件：\n\n```python\nfrom tempfile import NamedTemporaryFile\n```\n\n通过request获取图片信息，然后写入到一个临时文件中。\n\n```python\nres = requests.get(url, allow_redirects=False)\ntmp = NamedTemporaryFile()\ntmp.write(res.content)\ntmp.flush()\n```\n\n\n\n## 上传图片并作为表情发送\n\nwxpy提供了上传文件的通道，而上传后的文件就可以免去重新上传直接发送。\n\n```python\nmedia_id = bot.upload_file(tmp.name)\ntmp.close()\nmsg.reply_image('.gif', media_id=media_id)\n```\n\n在这里，用我们前文提到的方法，使用`.gif`来进行表情的发送。\n\n如果你想直接发送图片，可以简单地讲`.gif`参数去除：\n\n```python\nmsg.reply_image('', media_id=media_id)\n```\n\nwxpy的作者表示将在之后的版本中更新图片发送的接口以将图片发送和表情发送分开，我相信这一设计会是更加优秀的。","slug":"机器人3","published":1,"updated":"2017-07-18T11:51:31.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj5ae0ed900012wzkv24nfnzt","content":"<p>本篇的诞生来自于一朋友制作的表情机器人。当时觉得十分有趣，也希望加入到群聊机器人中，因此就向他讨要了<a href=\"https://github.com/qwIvan/microMsg-bot\" target=\"_blank\" rel=\"external\">源代码</a>并制作了表情功能。在此我也再次感谢<a href=\"https://github.com/qwIvan\" target=\"_blank\" rel=\"external\">吴毅凡</a>同学的协助！</p>\n<h2 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h2><p>由于需要读取网页内容，本文中由于我个人偏好使用xpath来选择网页中元素，使用了<a href=\"http://lxml.de/\" target=\"_blank\" rel=\"external\">lxml</a>包，安装的话需要：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">pip install lxml</div></pre></td></tr></table></figure>\n<p>如果你想要使用<a href=\"https://www.crummy.com/software/BeautifulSoup/bs4/doc/\" target=\"_blank\" rel=\"external\">BeautifulSoup</a>来处理网页，请安装：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">pip install beautifulsoup4</div></pre></td></tr></table></figure>\n<h2 id=\"使用斗图啦搜索表情\"><a href=\"#使用斗图啦搜索表情\" class=\"headerlink\" title=\"使用斗图啦搜索表情\"></a>使用斗图啦搜索表情</h2><p>由于<a href=\"https://www.doutula.com/\" target=\"_blank\" rel=\"external\">斗图啦</a>是明文传输数据搜索的，我们可以简单地通过</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">res = requests.get(<span class=\"string\">'https://www.doutula.com/search'</span>, &#123;<span class=\"string\">'keyword'</span>: keyword&#125;)</div></pre></td></tr></table></figure>\n<p>来获取关键词keyword的搜索结果页面。</p>\n<p>本例中我使用xpath来选择元素，其具体教程你可以查看<a href=\"http://www.w3school.com.cn/xpath/index.asp\" target=\"_blank\" rel=\"external\">这里</a>。如果你想使用<code>BeautifulSoup</code>，可以查看<a href=\"https://github.com/qwIvan/microMsg-bot/blob/master/meme.py#L7\" target=\"_blank\" rel=\"external\">这里</a>。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">html = etree.HTML(res.text)</div><div class=\"line\">url = <span class=\"string\">'http:'</span> + random.choice(html.xpath(<span class=\"string\">'//div[@class=\"image-container\"][1]//img[contains(@class, \"img-responsive\")]/@data-original'</span>))</div></pre></td></tr></table></figure>\n<p>其中<code>//div[@class=&quot;image-container&quot;][1]</code>选择了页面中的第一个<code>image-container</code>元素，如果你观察斗图啦搜索界面，你会发现它分为上下两部分：上面是表情的搜索结果，下半部分则是文章的搜索结果，这样我们就仅挑选了上半部分的表情搜索结果。而<code>//img[contains(@class, &quot;img-responsive&quot;)]/@data-original&#39;</code>部分则选择了所有<code>class</code>里包含<code>img-responsive</code>的<code>img</code>元素，也就是我们要的图片本身，仔细观察元素本身你会发现图片链接就在其中的<code>data-original</code>属性下（但是需要加上http协议）。</p>\n<p>Chrome的审查元素功能可以帮助你快速判断自己编写的xpath能否准确选出你想要的元素，也能够查看元素本身。</p>\n<h2 id=\"储存图片\"><a href=\"#储存图片\" class=\"headerlink\" title=\"储存图片\"></a>储存图片</h2><p>因为wxpy自动将gif文件判断作为表情发送，我们可以利用这一点把表情作为表情（而非图片）发送到聊天中。</p>\n<p>首先我们使用了临时文件：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> tempfile <span class=\"keyword\">import</span> NamedTemporaryFile</div></pre></td></tr></table></figure>\n<p>通过request获取图片信息，然后写入到一个临时文件中。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">res = requests.get(url, allow_redirects=<span class=\"keyword\">False</span>)</div><div class=\"line\">tmp = NamedTemporaryFile()</div><div class=\"line\">tmp.write(res.content)</div><div class=\"line\">tmp.flush()</div></pre></td></tr></table></figure>\n<h2 id=\"上传图片并作为表情发送\"><a href=\"#上传图片并作为表情发送\" class=\"headerlink\" title=\"上传图片并作为表情发送\"></a>上传图片并作为表情发送</h2><p>wxpy提供了上传文件的通道，而上传后的文件就可以免去重新上传直接发送。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">media_id = bot.upload_file(tmp.name)</div><div class=\"line\">tmp.close()</div><div class=\"line\">msg.reply_image(<span class=\"string\">'.gif'</span>, media_id=media_id)</div></pre></td></tr></table></figure>\n<p>在这里，用我们前文提到的方法，使用<code>.gif</code>来进行表情的发送。</p>\n<p>如果你想直接发送图片，可以简单地讲<code>.gif</code>参数去除：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">msg.reply_image(<span class=\"string\">''</span>, media_id=media_id)</div></pre></td></tr></table></figure>\n<p>wxpy的作者表示将在之后的版本中更新图片发送的接口以将图片发送和表情发送分开，我相信这一设计会是更加优秀的。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>本篇的诞生来自于一朋友制作的表情机器人。当时觉得十分有趣，也希望加入到群聊机器人中，因此就向他讨要了<a href=\"https://github.com/qwIvan/microMsg-bot\" target=\"_blank\" rel=\"external\">源代码</a>并制作了表情功能。在此我也再次感谢<a href=\"https://github.com/qwIvan\" target=\"_blank\" rel=\"external\">吴毅凡</a>同学的协助！</p>\n<h2 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h2><p>由于需要读取网页内容，本文中由于我个人偏好使用xpath来选择网页中元素，使用了<a href=\"http://lxml.de/\" target=\"_blank\" rel=\"external\">lxml</a>包，安装的话需要：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">pip install lxml</div></pre></td></tr></table></figure>\n<p>如果你想要使用<a href=\"https://www.crummy.com/software/BeautifulSoup/bs4/doc/\" target=\"_blank\" rel=\"external\">BeautifulSoup</a>来处理网页，请安装：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">pip install beautifulsoup4</div></pre></td></tr></table></figure>\n<h2 id=\"使用斗图啦搜索表情\"><a href=\"#使用斗图啦搜索表情\" class=\"headerlink\" title=\"使用斗图啦搜索表情\"></a>使用斗图啦搜索表情</h2><p>由于<a href=\"https://www.doutula.com/\" target=\"_blank\" rel=\"external\">斗图啦</a>是明文传输数据搜索的，我们可以简单地通过</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">res = requests.get(<span class=\"string\">'https://www.doutula.com/search'</span>, &#123;<span class=\"string\">'keyword'</span>: keyword&#125;)</div></pre></td></tr></table></figure>\n<p>来获取关键词keyword的搜索结果页面。</p>\n<p>本例中我使用xpath来选择元素，其具体教程你可以查看<a href=\"http://www.w3school.com.cn/xpath/index.asp\" target=\"_blank\" rel=\"external\">这里</a>。如果你想使用<code>BeautifulSoup</code>，可以查看<a href=\"https://github.com/qwIvan/microMsg-bot/blob/master/meme.py#L7\" target=\"_blank\" rel=\"external\">这里</a>。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">html = etree.HTML(res.text)</div><div class=\"line\">url = <span class=\"string\">'http:'</span> + random.choice(html.xpath(<span class=\"string\">'//div[@class=\"image-container\"][1]//img[contains(@class, \"img-responsive\")]/@data-original'</span>))</div></pre></td></tr></table></figure>\n<p>其中<code>//div[@class=&quot;image-container&quot;][1]</code>选择了页面中的第一个<code>image-container</code>元素，如果你观察斗图啦搜索界面，你会发现它分为上下两部分：上面是表情的搜索结果，下半部分则是文章的搜索结果，这样我们就仅挑选了上半部分的表情搜索结果。而<code>//img[contains(@class, &quot;img-responsive&quot;)]/@data-original&#39;</code>部分则选择了所有<code>class</code>里包含<code>img-responsive</code>的<code>img</code>元素，也就是我们要的图片本身，仔细观察元素本身你会发现图片链接就在其中的<code>data-original</code>属性下（但是需要加上http协议）。</p>\n<p>Chrome的审查元素功能可以帮助你快速判断自己编写的xpath能否准确选出你想要的元素，也能够查看元素本身。</p>\n<h2 id=\"储存图片\"><a href=\"#储存图片\" class=\"headerlink\" title=\"储存图片\"></a>储存图片</h2><p>因为wxpy自动将gif文件判断作为表情发送，我们可以利用这一点把表情作为表情（而非图片）发送到聊天中。</p>\n<p>首先我们使用了临时文件：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> tempfile <span class=\"keyword\">import</span> NamedTemporaryFile</div></pre></td></tr></table></figure>\n<p>通过request获取图片信息，然后写入到一个临时文件中。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">res = requests.get(url, allow_redirects=<span class=\"keyword\">False</span>)</div><div class=\"line\">tmp = NamedTemporaryFile()</div><div class=\"line\">tmp.write(res.content)</div><div class=\"line\">tmp.flush()</div></pre></td></tr></table></figure>\n<h2 id=\"上传图片并作为表情发送\"><a href=\"#上传图片并作为表情发送\" class=\"headerlink\" title=\"上传图片并作为表情发送\"></a>上传图片并作为表情发送</h2><p>wxpy提供了上传文件的通道，而上传后的文件就可以免去重新上传直接发送。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">media_id = bot.upload_file(tmp.name)</div><div class=\"line\">tmp.close()</div><div class=\"line\">msg.reply_image(<span class=\"string\">'.gif'</span>, media_id=media_id)</div></pre></td></tr></table></figure>\n<p>在这里，用我们前文提到的方法，使用<code>.gif</code>来进行表情的发送。</p>\n<p>如果你想直接发送图片，可以简单地讲<code>.gif</code>参数去除：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">msg.reply_image(<span class=\"string\">''</span>, media_id=media_id)</div></pre></td></tr></table></figure>\n<p>wxpy的作者表示将在之后的版本中更新图片发送的接口以将图片发送和表情发送分开，我相信这一设计会是更加优秀的。</p>\n"},{"title":"从零开始微信机器人（一）：wxpy简介","date":"2017-06-22T16:00:00.000Z","_content":"\n在过去的几个月中，由于在新生群中回答问题费时费力，同时又有许多重复而又有固定答案的回答，我受到一些知乎文章的启发，维护了一个基于itchat的群聊机器人。从刚开始接入图灵机器人时只会尬聊的机器人，之后又加入了api.ai的按照消息内容自动回复，而后再加入了回复表情功能，使得机器人变得越来越有趣。\n\n现在，由于itchat的更新和被wxpy一些更有趣的功能所吸引，我计划将这个机器人分步重写，并将完整的机器人构建步骤展现给大家。这是我第一次做这样的事，有诸多不足之处，也希望多多谅解和指正。\n\n\n\n本文很大程度上面向仅对python入门或是了解较少的开发者因此较为详细，希望最大程度上帮助大家从零开始构建一个属于自己的微信机器人，哪怕仅有很少的编程基础。每一篇会将长度控制在较短、能够快速阅读完的范围内。\n\n本文基于python 2.7，与python 3.5可能有语法上区别。\n\n\n\n## 安装wxpy\n\n安装wxpy非常简单，如果你拥有pip，请直接按照Github中的方法安装：\n\n> 从 PYPI 官方源下载安装 (在国内可能比较慢或不稳定):\n\n```shell\npip install -U wxpy\n```\n\n> 从豆瓣 PYPI 镜像源下载安装 (**推荐国内用户选用**):\n\n```shell\npip install -U wxpy -i \"https://pypi.doubanio.com/simple/\"\n```\n\n\n\n## 登录微信\n\n（这里吐槽一下wxpy文档中登录错写为登陆）\n\nGithub上和文档中给出了最简单的登录机器人的方式，在程序中写上这两行并运行，会通过图片扫描二维码并登录微信。\n\n```python\n# 导入模块\nfrom wxpy import *\n# 初始化机器人，扫码登陆\nbot = Bot()\n```\n\n有些情况下，可能不能通过终端打开图片（例如部署在服务器上时），我们可以通过参数选择在终端内显示二维码，这样代码会变为：\n\n```python\nfrom wxpy import *\nbot = Bot(console_qr=True)\n```\n\n如果你发现这样设置终端中的二维码变形了，可以尝试传入`console_qr=1`（或其他倍数）来进行调整字幅宽度。如果需要反色显示，可以使用负数来进行反色操作。\n\n如果你认为每次都需要扫描二维码很麻烦，可以启用缓存，来保存自己的登录状态：\n\n```python\nbot = Bot(console_qr=True, cache_path=True)\n```\n\n\n\n## 发送消息\n\n首先我们尝试给自己和文件传输助手发消息：\n\n```python\n# 给机器人自己发送消息\nbot.self.send('Hello World!')\n# 给文件传输助手发送消息\nbot.file_helper.send('Hello World!')\n```\n\n如果无法给机器人自身发送消息，请参考http://wxpy.readthedocs.io/zh/latest/bot.html#wxpy.Bot.self\n\n```python\n# 查找昵称为'乙醚。'的好友\nmy_friend = bot.friends().search(u'乙醚。')[0]\n# <Friend: 乙醚。>\n```\n\nwxpy同时也包括了发送不同类型消息的方法，通过这些方法我们可以发送各种不同类型的消息。以下是文档给出的样例使用方式：\n\n```python\n# 发送文本\nmy_friend.send('Hello, WeChat!')\n# 发送图片\nmy_friend.send_image('my_picture.png')\n# 发送视频\nmy_friend.send_video('my_video.mov')\n# 发送文件\nmy_friend.send_file('my_file.zip')\n# 以动态的方式发送图片\nmy_friend.send('@img@my_picture.png')\n```\n\n通过使用这些方法，我们就可以自定义一个在合适的时候做合适的事情的机器人了！\n\n由于群聊机器人设计暂时需要好友相关内容不多，此处不再作过过多赘述，如果有需要搜索好友的可以参考http://wxpy.readthedocs.io/zh/latest/chats.html#module-wxpy\n\n\n\n## 自动处理消息\n\nwxpy提供了注册消息的方法，可以简单将各种类型的消息注册并自定义处理方式。\n\n注册消息使用简单的`@bot.register()`方法，\n\n```python\n# 获取所有类型的消息（好友消息、群聊、公众号，不包括任何自己发送的消息）\n# 并将获得的消息打印到控制台\n@bot.register()\ndef print_others(msg):\n    print(msg)\n```\n\n同时wxpy也可以给注册消息的类型加上限制，\n\n```python\n# 回复 my_friend 发送的消息\n@bot.register(my_friend)\ndef reply_my_friend(msg):\n    return 'received: {} ({})'.format(msg.text, msg.type)\n\n# 回复发送给自己的消息，可以使用这个方法来进行测试机器人而不影响到他人\n@bot.register(bot.self, except_self=False)\ndef reply_self(msg):\n    return 'received: {} ({})'.format(msg.text, msg.type)\n\n# 打印出所有群聊中@自己的文本消息，并自动回复相同内容\n# 这条注册消息是我们构建群聊机器人的基础\n@bot.register(Group, TEXT)\ndef print_group_msg(msg):\n\tif msg.is_at:\n\t    print(msg)\n\t    msg.reply(meg.text)\n```\n\n当然仅仅写以上内容，会导致你的程序主程序运行结束自然退出。wxpy给出了`embed()`方法，在程序末尾（或其他你想要暂停调试的地方）加上`embed()`方法就可以让程序保持运行，同时进入Python命令行。\n\n```python\n# 进入 Python 命令行、让程序保持运行\n# 推荐使用\nembed()\n\n# 或者仅仅堵塞线程\n# bot.join()\n```\n\n关于消息注册的文档，更多内容可以参考http://wxpy.readthedocs.io/zh/latest/messages.html#id11\n\n现在，你已经可以用这个微信机器人和自动回复消息玩了！刺不刺激呢！\n\n下一篇中，我将就如何将API接入机器人进行阐述。\n\n\n\n# 你可能会遇到的一些问题\n\n## 报错[SSL: CERTIFICATE_VERIFY_FAILED]\n\n可能的**解决方案**一：\n\n```shell\npip install -U requests[security]\n```\n\n可能的**解决方案**二：\n\n进如python后运行：\n\n```python\nimport certifi \nprint(certifi.old_where())\n```\n\n把打印出的路径（例如我的是`/usr/local/lib/python2.7/site-packages/certifi/weak.pem`）放入环境变量`REQUESTS_CA_BUNDLE`中。具体而言是在*nix环境下运行：\n\n```shell\nexport REQUESTS_CA_BUNDLE='What you get'\n```\n\n或是在Windows中使用系统面板进行修改。","source":"_posts/机器人1.md","raw":"---\ntitle: 从零开始微信机器人（一）：wxpy简介\ndate: 2017-06-23\ncategory: 计算机课堂\ntags: \n- Python\n- 聊天机器人\n---\n\n在过去的几个月中，由于在新生群中回答问题费时费力，同时又有许多重复而又有固定答案的回答，我受到一些知乎文章的启发，维护了一个基于itchat的群聊机器人。从刚开始接入图灵机器人时只会尬聊的机器人，之后又加入了api.ai的按照消息内容自动回复，而后再加入了回复表情功能，使得机器人变得越来越有趣。\n\n现在，由于itchat的更新和被wxpy一些更有趣的功能所吸引，我计划将这个机器人分步重写，并将完整的机器人构建步骤展现给大家。这是我第一次做这样的事，有诸多不足之处，也希望多多谅解和指正。\n\n\n\n本文很大程度上面向仅对python入门或是了解较少的开发者因此较为详细，希望最大程度上帮助大家从零开始构建一个属于自己的微信机器人，哪怕仅有很少的编程基础。每一篇会将长度控制在较短、能够快速阅读完的范围内。\n\n本文基于python 2.7，与python 3.5可能有语法上区别。\n\n\n\n## 安装wxpy\n\n安装wxpy非常简单，如果你拥有pip，请直接按照Github中的方法安装：\n\n> 从 PYPI 官方源下载安装 (在国内可能比较慢或不稳定):\n\n```shell\npip install -U wxpy\n```\n\n> 从豆瓣 PYPI 镜像源下载安装 (**推荐国内用户选用**):\n\n```shell\npip install -U wxpy -i \"https://pypi.doubanio.com/simple/\"\n```\n\n\n\n## 登录微信\n\n（这里吐槽一下wxpy文档中登录错写为登陆）\n\nGithub上和文档中给出了最简单的登录机器人的方式，在程序中写上这两行并运行，会通过图片扫描二维码并登录微信。\n\n```python\n# 导入模块\nfrom wxpy import *\n# 初始化机器人，扫码登陆\nbot = Bot()\n```\n\n有些情况下，可能不能通过终端打开图片（例如部署在服务器上时），我们可以通过参数选择在终端内显示二维码，这样代码会变为：\n\n```python\nfrom wxpy import *\nbot = Bot(console_qr=True)\n```\n\n如果你发现这样设置终端中的二维码变形了，可以尝试传入`console_qr=1`（或其他倍数）来进行调整字幅宽度。如果需要反色显示，可以使用负数来进行反色操作。\n\n如果你认为每次都需要扫描二维码很麻烦，可以启用缓存，来保存自己的登录状态：\n\n```python\nbot = Bot(console_qr=True, cache_path=True)\n```\n\n\n\n## 发送消息\n\n首先我们尝试给自己和文件传输助手发消息：\n\n```python\n# 给机器人自己发送消息\nbot.self.send('Hello World!')\n# 给文件传输助手发送消息\nbot.file_helper.send('Hello World!')\n```\n\n如果无法给机器人自身发送消息，请参考http://wxpy.readthedocs.io/zh/latest/bot.html#wxpy.Bot.self\n\n```python\n# 查找昵称为'乙醚。'的好友\nmy_friend = bot.friends().search(u'乙醚。')[0]\n# <Friend: 乙醚。>\n```\n\nwxpy同时也包括了发送不同类型消息的方法，通过这些方法我们可以发送各种不同类型的消息。以下是文档给出的样例使用方式：\n\n```python\n# 发送文本\nmy_friend.send('Hello, WeChat!')\n# 发送图片\nmy_friend.send_image('my_picture.png')\n# 发送视频\nmy_friend.send_video('my_video.mov')\n# 发送文件\nmy_friend.send_file('my_file.zip')\n# 以动态的方式发送图片\nmy_friend.send('@img@my_picture.png')\n```\n\n通过使用这些方法，我们就可以自定义一个在合适的时候做合适的事情的机器人了！\n\n由于群聊机器人设计暂时需要好友相关内容不多，此处不再作过过多赘述，如果有需要搜索好友的可以参考http://wxpy.readthedocs.io/zh/latest/chats.html#module-wxpy\n\n\n\n## 自动处理消息\n\nwxpy提供了注册消息的方法，可以简单将各种类型的消息注册并自定义处理方式。\n\n注册消息使用简单的`@bot.register()`方法，\n\n```python\n# 获取所有类型的消息（好友消息、群聊、公众号，不包括任何自己发送的消息）\n# 并将获得的消息打印到控制台\n@bot.register()\ndef print_others(msg):\n    print(msg)\n```\n\n同时wxpy也可以给注册消息的类型加上限制，\n\n```python\n# 回复 my_friend 发送的消息\n@bot.register(my_friend)\ndef reply_my_friend(msg):\n    return 'received: {} ({})'.format(msg.text, msg.type)\n\n# 回复发送给自己的消息，可以使用这个方法来进行测试机器人而不影响到他人\n@bot.register(bot.self, except_self=False)\ndef reply_self(msg):\n    return 'received: {} ({})'.format(msg.text, msg.type)\n\n# 打印出所有群聊中@自己的文本消息，并自动回复相同内容\n# 这条注册消息是我们构建群聊机器人的基础\n@bot.register(Group, TEXT)\ndef print_group_msg(msg):\n\tif msg.is_at:\n\t    print(msg)\n\t    msg.reply(meg.text)\n```\n\n当然仅仅写以上内容，会导致你的程序主程序运行结束自然退出。wxpy给出了`embed()`方法，在程序末尾（或其他你想要暂停调试的地方）加上`embed()`方法就可以让程序保持运行，同时进入Python命令行。\n\n```python\n# 进入 Python 命令行、让程序保持运行\n# 推荐使用\nembed()\n\n# 或者仅仅堵塞线程\n# bot.join()\n```\n\n关于消息注册的文档，更多内容可以参考http://wxpy.readthedocs.io/zh/latest/messages.html#id11\n\n现在，你已经可以用这个微信机器人和自动回复消息玩了！刺不刺激呢！\n\n下一篇中，我将就如何将API接入机器人进行阐述。\n\n\n\n# 你可能会遇到的一些问题\n\n## 报错[SSL: CERTIFICATE_VERIFY_FAILED]\n\n可能的**解决方案**一：\n\n```shell\npip install -U requests[security]\n```\n\n可能的**解决方案**二：\n\n进如python后运行：\n\n```python\nimport certifi \nprint(certifi.old_where())\n```\n\n把打印出的路径（例如我的是`/usr/local/lib/python2.7/site-packages/certifi/weak.pem`）放入环境变量`REQUESTS_CA_BUNDLE`中。具体而言是在*nix环境下运行：\n\n```shell\nexport REQUESTS_CA_BUNDLE='What you get'\n```\n\n或是在Windows中使用系统面板进行修改。","slug":"机器人1","published":1,"updated":"2017-07-18T11:50:38.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj5ae0edf00042wzk7ytapitm","content":"<p>在过去的几个月中，由于在新生群中回答问题费时费力，同时又有许多重复而又有固定答案的回答，我受到一些知乎文章的启发，维护了一个基于itchat的群聊机器人。从刚开始接入图灵机器人时只会尬聊的机器人，之后又加入了api.ai的按照消息内容自动回复，而后再加入了回复表情功能，使得机器人变得越来越有趣。</p>\n<p>现在，由于itchat的更新和被wxpy一些更有趣的功能所吸引，我计划将这个机器人分步重写，并将完整的机器人构建步骤展现给大家。这是我第一次做这样的事，有诸多不足之处，也希望多多谅解和指正。</p>\n<p>本文很大程度上面向仅对python入门或是了解较少的开发者因此较为详细，希望最大程度上帮助大家从零开始构建一个属于自己的微信机器人，哪怕仅有很少的编程基础。每一篇会将长度控制在较短、能够快速阅读完的范围内。</p>\n<p>本文基于python 2.7，与python 3.5可能有语法上区别。</p>\n<h2 id=\"安装wxpy\"><a href=\"#安装wxpy\" class=\"headerlink\" title=\"安装wxpy\"></a>安装wxpy</h2><p>安装wxpy非常简单，如果你拥有pip，请直接按照Github中的方法安装：</p>\n<blockquote>\n<p>从 PYPI 官方源下载安装 (在国内可能比较慢或不稳定):</p>\n</blockquote>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">pip install -U wxpy</div></pre></td></tr></table></figure>\n<blockquote>\n<p>从豆瓣 PYPI 镜像源下载安装 (<strong>推荐国内用户选用</strong>):</p>\n</blockquote>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">pip install -U wxpy -i \"https://pypi.doubanio.com/simple/\"</div></pre></td></tr></table></figure>\n<h2 id=\"登录微信\"><a href=\"#登录微信\" class=\"headerlink\" title=\"登录微信\"></a>登录微信</h2><p>（这里吐槽一下wxpy文档中登录错写为登陆）</p>\n<p>Github上和文档中给出了最简单的登录机器人的方式，在程序中写上这两行并运行，会通过图片扫描二维码并登录微信。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 导入模块</span></div><div class=\"line\"><span class=\"keyword\">from</span> wxpy <span class=\"keyword\">import</span> *</div><div class=\"line\"><span class=\"comment\"># 初始化机器人，扫码登陆</span></div><div class=\"line\">bot = Bot()</div></pre></td></tr></table></figure>\n<p>有些情况下，可能不能通过终端打开图片（例如部署在服务器上时），我们可以通过参数选择在终端内显示二维码，这样代码会变为：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> wxpy <span class=\"keyword\">import</span> *</div><div class=\"line\">bot = Bot(console_qr=<span class=\"keyword\">True</span>)</div></pre></td></tr></table></figure>\n<p>如果你发现这样设置终端中的二维码变形了，可以尝试传入<code>console_qr=1</code>（或其他倍数）来进行调整字幅宽度。如果需要反色显示，可以使用负数来进行反色操作。</p>\n<p>如果你认为每次都需要扫描二维码很麻烦，可以启用缓存，来保存自己的登录状态：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">bot = Bot(console_qr=<span class=\"keyword\">True</span>, cache_path=<span class=\"keyword\">True</span>)</div></pre></td></tr></table></figure>\n<h2 id=\"发送消息\"><a href=\"#发送消息\" class=\"headerlink\" title=\"发送消息\"></a>发送消息</h2><p>首先我们尝试给自己和文件传输助手发消息：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 给机器人自己发送消息</span></div><div class=\"line\">bot.self.send(<span class=\"string\">'Hello World!'</span>)</div><div class=\"line\"><span class=\"comment\"># 给文件传输助手发送消息</span></div><div class=\"line\">bot.file_helper.send(<span class=\"string\">'Hello World!'</span>)</div></pre></td></tr></table></figure>\n<p>如果无法给机器人自身发送消息，请参考<a href=\"http://wxpy.readthedocs.io/zh/latest/bot.html#wxpy.Bot.self\" target=\"_blank\" rel=\"external\">http://wxpy.readthedocs.io/zh/latest/bot.html#wxpy.Bot.self</a></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 查找昵称为'乙醚。'的好友</span></div><div class=\"line\">my_friend = bot.friends().search(<span class=\"string\">u'乙醚。'</span>)[<span class=\"number\">0</span>]</div><div class=\"line\"><span class=\"comment\"># &lt;Friend: 乙醚。&gt;</span></div></pre></td></tr></table></figure>\n<p>wxpy同时也包括了发送不同类型消息的方法，通过这些方法我们可以发送各种不同类型的消息。以下是文档给出的样例使用方式：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 发送文本</span></div><div class=\"line\">my_friend.send(<span class=\"string\">'Hello, WeChat!'</span>)</div><div class=\"line\"><span class=\"comment\"># 发送图片</span></div><div class=\"line\">my_friend.send_image(<span class=\"string\">'my_picture.png'</span>)</div><div class=\"line\"><span class=\"comment\"># 发送视频</span></div><div class=\"line\">my_friend.send_video(<span class=\"string\">'my_video.mov'</span>)</div><div class=\"line\"><span class=\"comment\"># 发送文件</span></div><div class=\"line\">my_friend.send_file(<span class=\"string\">'my_file.zip'</span>)</div><div class=\"line\"><span class=\"comment\"># 以动态的方式发送图片</span></div><div class=\"line\">my_friend.send(<span class=\"string\">'@img@my_picture.png'</span>)</div></pre></td></tr></table></figure>\n<p>通过使用这些方法，我们就可以自定义一个在合适的时候做合适的事情的机器人了！</p>\n<p>由于群聊机器人设计暂时需要好友相关内容不多，此处不再作过过多赘述，如果有需要搜索好友的可以参考<a href=\"http://wxpy.readthedocs.io/zh/latest/chats.html#module-wxpy\" target=\"_blank\" rel=\"external\">http://wxpy.readthedocs.io/zh/latest/chats.html#module-wxpy</a></p>\n<h2 id=\"自动处理消息\"><a href=\"#自动处理消息\" class=\"headerlink\" title=\"自动处理消息\"></a>自动处理消息</h2><p>wxpy提供了注册消息的方法，可以简单将各种类型的消息注册并自定义处理方式。</p>\n<p>注册消息使用简单的<code>@bot.register()</code>方法，</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 获取所有类型的消息（好友消息、群聊、公众号，不包括任何自己发送的消息）</span></div><div class=\"line\"><span class=\"comment\"># 并将获得的消息打印到控制台</span></div><div class=\"line\"><span class=\"meta\">@bot.register()</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">print_others</span><span class=\"params\">(msg)</span>:</span></div><div class=\"line\">    print(msg)</div></pre></td></tr></table></figure>\n<p>同时wxpy也可以给注册消息的类型加上限制，</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 回复 my_friend 发送的消息</span></div><div class=\"line\"><span class=\"meta\">@bot.register(my_friend)</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">reply_my_friend</span><span class=\"params\">(msg)</span>:</span></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'received: &#123;&#125; (&#123;&#125;)'</span>.format(msg.text, msg.type)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 回复发送给自己的消息，可以使用这个方法来进行测试机器人而不影响到他人</span></div><div class=\"line\"><span class=\"meta\">@bot.register(bot.self, except_self=False)</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">reply_self</span><span class=\"params\">(msg)</span>:</span></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'received: &#123;&#125; (&#123;&#125;)'</span>.format(msg.text, msg.type)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 打印出所有群聊中@自己的文本消息，并自动回复相同内容</span></div><div class=\"line\"><span class=\"comment\"># 这条注册消息是我们构建群聊机器人的基础</span></div><div class=\"line\"><span class=\"meta\">@bot.register(Group, TEXT)</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">print_group_msg</span><span class=\"params\">(msg)</span>:</span></div><div class=\"line\">\t<span class=\"keyword\">if</span> msg.is_at:</div><div class=\"line\">\t    print(msg)</div><div class=\"line\">\t    msg.reply(meg.text)</div></pre></td></tr></table></figure>\n<p>当然仅仅写以上内容，会导致你的程序主程序运行结束自然退出。wxpy给出了<code>embed()</code>方法，在程序末尾（或其他你想要暂停调试的地方）加上<code>embed()</code>方法就可以让程序保持运行，同时进入Python命令行。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 进入 Python 命令行、让程序保持运行</span></div><div class=\"line\"><span class=\"comment\"># 推荐使用</span></div><div class=\"line\">embed()</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 或者仅仅堵塞线程</span></div><div class=\"line\"><span class=\"comment\"># bot.join()</span></div></pre></td></tr></table></figure>\n<p>关于消息注册的文档，更多内容可以参考<a href=\"http://wxpy.readthedocs.io/zh/latest/messages.html#id11\" target=\"_blank\" rel=\"external\">http://wxpy.readthedocs.io/zh/latest/messages.html#id11</a></p>\n<p>现在，你已经可以用这个微信机器人和自动回复消息玩了！刺不刺激呢！</p>\n<p>下一篇中，我将就如何将API接入机器人进行阐述。</p>\n<h1 id=\"你可能会遇到的一些问题\"><a href=\"#你可能会遇到的一些问题\" class=\"headerlink\" title=\"你可能会遇到的一些问题\"></a>你可能会遇到的一些问题</h1><h2 id=\"报错-SSL-CERTIFICATE-VERIFY-FAILED\"><a href=\"#报错-SSL-CERTIFICATE-VERIFY-FAILED\" class=\"headerlink\" title=\"报错[SSL: CERTIFICATE_VERIFY_FAILED]\"></a>报错[SSL: CERTIFICATE_VERIFY_FAILED]</h2><p>可能的<strong>解决方案</strong>一：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">pip install -U requests[security]</div></pre></td></tr></table></figure>\n<p>可能的<strong>解决方案</strong>二：</p>\n<p>进如python后运行：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> certifi </div><div class=\"line\">print(certifi.old_where())</div></pre></td></tr></table></figure>\n<p>把打印出的路径（例如我的是<code>/usr/local/lib/python2.7/site-packages/certifi/weak.pem</code>）放入环境变量<code>REQUESTS_CA_BUNDLE</code>中。具体而言是在*nix环境下运行：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">export REQUESTS_CA_BUNDLE='What you get'</div></pre></td></tr></table></figure>\n<p>或是在Windows中使用系统面板进行修改。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>在过去的几个月中，由于在新生群中回答问题费时费力，同时又有许多重复而又有固定答案的回答，我受到一些知乎文章的启发，维护了一个基于itchat的群聊机器人。从刚开始接入图灵机器人时只会尬聊的机器人，之后又加入了api.ai的按照消息内容自动回复，而后再加入了回复表情功能，使得机器人变得越来越有趣。</p>\n<p>现在，由于itchat的更新和被wxpy一些更有趣的功能所吸引，我计划将这个机器人分步重写，并将完整的机器人构建步骤展现给大家。这是我第一次做这样的事，有诸多不足之处，也希望多多谅解和指正。</p>\n<p>本文很大程度上面向仅对python入门或是了解较少的开发者因此较为详细，希望最大程度上帮助大家从零开始构建一个属于自己的微信机器人，哪怕仅有很少的编程基础。每一篇会将长度控制在较短、能够快速阅读完的范围内。</p>\n<p>本文基于python 2.7，与python 3.5可能有语法上区别。</p>\n<h2 id=\"安装wxpy\"><a href=\"#安装wxpy\" class=\"headerlink\" title=\"安装wxpy\"></a>安装wxpy</h2><p>安装wxpy非常简单，如果你拥有pip，请直接按照Github中的方法安装：</p>\n<blockquote>\n<p>从 PYPI 官方源下载安装 (在国内可能比较慢或不稳定):</p>\n</blockquote>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">pip install -U wxpy</div></pre></td></tr></table></figure>\n<blockquote>\n<p>从豆瓣 PYPI 镜像源下载安装 (<strong>推荐国内用户选用</strong>):</p>\n</blockquote>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">pip install -U wxpy -i \"https://pypi.doubanio.com/simple/\"</div></pre></td></tr></table></figure>\n<h2 id=\"登录微信\"><a href=\"#登录微信\" class=\"headerlink\" title=\"登录微信\"></a>登录微信</h2><p>（这里吐槽一下wxpy文档中登录错写为登陆）</p>\n<p>Github上和文档中给出了最简单的登录机器人的方式，在程序中写上这两行并运行，会通过图片扫描二维码并登录微信。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 导入模块</span></div><div class=\"line\"><span class=\"keyword\">from</span> wxpy <span class=\"keyword\">import</span> *</div><div class=\"line\"><span class=\"comment\"># 初始化机器人，扫码登陆</span></div><div class=\"line\">bot = Bot()</div></pre></td></tr></table></figure>\n<p>有些情况下，可能不能通过终端打开图片（例如部署在服务器上时），我们可以通过参数选择在终端内显示二维码，这样代码会变为：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> wxpy <span class=\"keyword\">import</span> *</div><div class=\"line\">bot = Bot(console_qr=<span class=\"keyword\">True</span>)</div></pre></td></tr></table></figure>\n<p>如果你发现这样设置终端中的二维码变形了，可以尝试传入<code>console_qr=1</code>（或其他倍数）来进行调整字幅宽度。如果需要反色显示，可以使用负数来进行反色操作。</p>\n<p>如果你认为每次都需要扫描二维码很麻烦，可以启用缓存，来保存自己的登录状态：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">bot = Bot(console_qr=<span class=\"keyword\">True</span>, cache_path=<span class=\"keyword\">True</span>)</div></pre></td></tr></table></figure>\n<h2 id=\"发送消息\"><a href=\"#发送消息\" class=\"headerlink\" title=\"发送消息\"></a>发送消息</h2><p>首先我们尝试给自己和文件传输助手发消息：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 给机器人自己发送消息</span></div><div class=\"line\">bot.self.send(<span class=\"string\">'Hello World!'</span>)</div><div class=\"line\"><span class=\"comment\"># 给文件传输助手发送消息</span></div><div class=\"line\">bot.file_helper.send(<span class=\"string\">'Hello World!'</span>)</div></pre></td></tr></table></figure>\n<p>如果无法给机器人自身发送消息，请参考<a href=\"http://wxpy.readthedocs.io/zh/latest/bot.html#wxpy.Bot.self\" target=\"_blank\" rel=\"external\">http://wxpy.readthedocs.io/zh/latest/bot.html#wxpy.Bot.self</a></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 查找昵称为'乙醚。'的好友</span></div><div class=\"line\">my_friend = bot.friends().search(<span class=\"string\">u'乙醚。'</span>)[<span class=\"number\">0</span>]</div><div class=\"line\"><span class=\"comment\"># &lt;Friend: 乙醚。&gt;</span></div></pre></td></tr></table></figure>\n<p>wxpy同时也包括了发送不同类型消息的方法，通过这些方法我们可以发送各种不同类型的消息。以下是文档给出的样例使用方式：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 发送文本</span></div><div class=\"line\">my_friend.send(<span class=\"string\">'Hello, WeChat!'</span>)</div><div class=\"line\"><span class=\"comment\"># 发送图片</span></div><div class=\"line\">my_friend.send_image(<span class=\"string\">'my_picture.png'</span>)</div><div class=\"line\"><span class=\"comment\"># 发送视频</span></div><div class=\"line\">my_friend.send_video(<span class=\"string\">'my_video.mov'</span>)</div><div class=\"line\"><span class=\"comment\"># 发送文件</span></div><div class=\"line\">my_friend.send_file(<span class=\"string\">'my_file.zip'</span>)</div><div class=\"line\"><span class=\"comment\"># 以动态的方式发送图片</span></div><div class=\"line\">my_friend.send(<span class=\"string\">'@img@my_picture.png'</span>)</div></pre></td></tr></table></figure>\n<p>通过使用这些方法，我们就可以自定义一个在合适的时候做合适的事情的机器人了！</p>\n<p>由于群聊机器人设计暂时需要好友相关内容不多，此处不再作过过多赘述，如果有需要搜索好友的可以参考<a href=\"http://wxpy.readthedocs.io/zh/latest/chats.html#module-wxpy\" target=\"_blank\" rel=\"external\">http://wxpy.readthedocs.io/zh/latest/chats.html#module-wxpy</a></p>\n<h2 id=\"自动处理消息\"><a href=\"#自动处理消息\" class=\"headerlink\" title=\"自动处理消息\"></a>自动处理消息</h2><p>wxpy提供了注册消息的方法，可以简单将各种类型的消息注册并自定义处理方式。</p>\n<p>注册消息使用简单的<code>@bot.register()</code>方法，</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 获取所有类型的消息（好友消息、群聊、公众号，不包括任何自己发送的消息）</span></div><div class=\"line\"><span class=\"comment\"># 并将获得的消息打印到控制台</span></div><div class=\"line\"><span class=\"meta\">@bot.register()</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">print_others</span><span class=\"params\">(msg)</span>:</span></div><div class=\"line\">    print(msg)</div></pre></td></tr></table></figure>\n<p>同时wxpy也可以给注册消息的类型加上限制，</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 回复 my_friend 发送的消息</span></div><div class=\"line\"><span class=\"meta\">@bot.register(my_friend)</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">reply_my_friend</span><span class=\"params\">(msg)</span>:</span></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'received: &#123;&#125; (&#123;&#125;)'</span>.format(msg.text, msg.type)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 回复发送给自己的消息，可以使用这个方法来进行测试机器人而不影响到他人</span></div><div class=\"line\"><span class=\"meta\">@bot.register(bot.self, except_self=False)</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">reply_self</span><span class=\"params\">(msg)</span>:</span></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'received: &#123;&#125; (&#123;&#125;)'</span>.format(msg.text, msg.type)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 打印出所有群聊中@自己的文本消息，并自动回复相同内容</span></div><div class=\"line\"><span class=\"comment\"># 这条注册消息是我们构建群聊机器人的基础</span></div><div class=\"line\"><span class=\"meta\">@bot.register(Group, TEXT)</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">print_group_msg</span><span class=\"params\">(msg)</span>:</span></div><div class=\"line\">\t<span class=\"keyword\">if</span> msg.is_at:</div><div class=\"line\">\t    print(msg)</div><div class=\"line\">\t    msg.reply(meg.text)</div></pre></td></tr></table></figure>\n<p>当然仅仅写以上内容，会导致你的程序主程序运行结束自然退出。wxpy给出了<code>embed()</code>方法，在程序末尾（或其他你想要暂停调试的地方）加上<code>embed()</code>方法就可以让程序保持运行，同时进入Python命令行。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 进入 Python 命令行、让程序保持运行</span></div><div class=\"line\"><span class=\"comment\"># 推荐使用</span></div><div class=\"line\">embed()</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 或者仅仅堵塞线程</span></div><div class=\"line\"><span class=\"comment\"># bot.join()</span></div></pre></td></tr></table></figure>\n<p>关于消息注册的文档，更多内容可以参考<a href=\"http://wxpy.readthedocs.io/zh/latest/messages.html#id11\" target=\"_blank\" rel=\"external\">http://wxpy.readthedocs.io/zh/latest/messages.html#id11</a></p>\n<p>现在，你已经可以用这个微信机器人和自动回复消息玩了！刺不刺激呢！</p>\n<p>下一篇中，我将就如何将API接入机器人进行阐述。</p>\n<h1 id=\"你可能会遇到的一些问题\"><a href=\"#你可能会遇到的一些问题\" class=\"headerlink\" title=\"你可能会遇到的一些问题\"></a>你可能会遇到的一些问题</h1><h2 id=\"报错-SSL-CERTIFICATE-VERIFY-FAILED\"><a href=\"#报错-SSL-CERTIFICATE-VERIFY-FAILED\" class=\"headerlink\" title=\"报错[SSL: CERTIFICATE_VERIFY_FAILED]\"></a>报错[SSL: CERTIFICATE_VERIFY_FAILED]</h2><p>可能的<strong>解决方案</strong>一：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">pip install -U requests[security]</div></pre></td></tr></table></figure>\n<p>可能的<strong>解决方案</strong>二：</p>\n<p>进如python后运行：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> certifi </div><div class=\"line\">print(certifi.old_where())</div></pre></td></tr></table></figure>\n<p>把打印出的路径（例如我的是<code>/usr/local/lib/python2.7/site-packages/certifi/weak.pem</code>）放入环境变量<code>REQUESTS_CA_BUNDLE</code>中。具体而言是在*nix环境下运行：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">export REQUESTS_CA_BUNDLE='What you get'</div></pre></td></tr></table></figure>\n<p>或是在Windows中使用系统面板进行修改。</p>\n"},{"title":"从零开始微信机器人（四）：监控机器人程序","date":"2017-06-25T16:00:00.000Z","_content":"\n\n\n由于使用网页版微信，机器人往往不能够永远地在线。如果无法一直在线，也就失去了自动回复程序的意义。在此，我们使用两种方式来监控机器人程序：\n\n1. 自动定时发送消息\n2. 使用supervisor进行监控\n\n\n\n# 自动发送消息\n\n## 准备\n\n如果需要定时发送消息，使用`sleep`方式来等待计时会阻塞线程，因此我们会使用`threading`来进行多线程的操作。把一个线程分配给自动给特定人发送微信消息。\n\n## 定义自动发送消息的方法\n\n在进行多线程操作之前，我们先定义一个自动发送消息的方法以备调用：\n\n```python\ndef send_online_notification(name):\n    my_friend = ensure_one(bot.search(name))\n    while True:\n        my_friend.send('Hello!') # 你想发送的消息\n        time.sleep(3600) # 一小时后在进行发送\n```\n\nwxpy的`ensure_one()`方法会确认返回的内容仅有一个值，如果返回的列表超过一个值（或是没有返回），它会进行报错。我们在这里寻找`name`相关的好友，并且保证只有一个这样的好友。如果你需要给多个好友发送消息，我建议再使用一个循环来遍历好友列表。\n\n我们写一个阻塞线程的死循环，在死循环中给需要寻找发送特定消息，并让线程停止一小时，由此来打成定时发送消息的方法。\n\n## 增加线程\n\n另一边，我们需要利用多线程调用这个方法。\n\n```python\npositiveSendingThread = threading.Thread(target=send_online_notification, args=(u'乙醚。',)) # 请在这里输入你想要寻找的好友昵称或备注\npositiveSendingThread.setDaemon(True)\npositiveSendingThread.start()\n```\n\n这样就成功启用了一个线程来进行自动发送消息了。\n\n\n\n# 利用Supervisor监控\n\n## 安装\n\nsupervisor是一个python写成的程序，因此可以简单地通过`pip`来进行安装：\n\n```shell\npip install supervisor\n```\n\n\n\n## 调整 wxpy设置\n\n如果想使用supervisor的重启功能，我们必须开启wxpy的缓存功能以储存登录状态，具体操作在登录时增加`cache_path`参数：\n\n```python\nbot = Bot(cache_path=True)\n```\n\n你也可以自由选择将缓存存在什么文件中，以免多个机器人冲突\n\n\n\n## 配置\n\n官方提供了一个默认的配置文件，你可以使用这条命令输出到你放置机器人的文件夹中：\n\n```shell\necho_supervisord_conf > supervisord.conf\n```\n\n在这个`supervisord.conf`后面，我们再追加对微信机器人程序的控制\n\n```shell\n[program:bot]  \ncommand=python ./wxbot.py              ;执行机器人文件，请修改文件名 \nprocess_name=%(program_name)s  \nautostart=true                   ; 程序是否随supervisor启动而启动  \nautorestart=true                 ;程序停止时，是否自动重启  \nstartsecs=10  \n```\n\n\n\n## 启动和控制\n\n从命令启动supervisor只需要一句：\n\n```\nsupervisord -c supervisord.conf\n```\n\n`-c`用以指定配置文件，也就是我们刚刚编写的文件。\n\n使用supervisor还可以方便的开始、重启和停止程序：\n\n```shell\nsupervisorctl start bot # 开始程序，bot 是刚刚填写的程序名\nsupervisorctl restart bot # 重启程序\nsupervisorctl stop bot # 停止程序\n```\n\n使用supervisor查看自己的程序运行状态\n\n```shell\nsupervisorctl status # 查看状态\n```\n\n因此，只要将wxpy的缓存打开，并且使用supervisor进行自动重启，我们就可以获得一个长时间保持登录的自动回复机器人啦！\n\n","source":"_posts/机器人4.md","raw":"---\ntitle: 从零开始微信机器人（四）：监控机器人程序\ndate: 2017-06-26\ncategory: 计算机课堂\ntags: \n- Python\n- 聊天机器人\n---\n\n\n\n由于使用网页版微信，机器人往往不能够永远地在线。如果无法一直在线，也就失去了自动回复程序的意义。在此，我们使用两种方式来监控机器人程序：\n\n1. 自动定时发送消息\n2. 使用supervisor进行监控\n\n\n\n# 自动发送消息\n\n## 准备\n\n如果需要定时发送消息，使用`sleep`方式来等待计时会阻塞线程，因此我们会使用`threading`来进行多线程的操作。把一个线程分配给自动给特定人发送微信消息。\n\n## 定义自动发送消息的方法\n\n在进行多线程操作之前，我们先定义一个自动发送消息的方法以备调用：\n\n```python\ndef send_online_notification(name):\n    my_friend = ensure_one(bot.search(name))\n    while True:\n        my_friend.send('Hello!') # 你想发送的消息\n        time.sleep(3600) # 一小时后在进行发送\n```\n\nwxpy的`ensure_one()`方法会确认返回的内容仅有一个值，如果返回的列表超过一个值（或是没有返回），它会进行报错。我们在这里寻找`name`相关的好友，并且保证只有一个这样的好友。如果你需要给多个好友发送消息，我建议再使用一个循环来遍历好友列表。\n\n我们写一个阻塞线程的死循环，在死循环中给需要寻找发送特定消息，并让线程停止一小时，由此来打成定时发送消息的方法。\n\n## 增加线程\n\n另一边，我们需要利用多线程调用这个方法。\n\n```python\npositiveSendingThread = threading.Thread(target=send_online_notification, args=(u'乙醚。',)) # 请在这里输入你想要寻找的好友昵称或备注\npositiveSendingThread.setDaemon(True)\npositiveSendingThread.start()\n```\n\n这样就成功启用了一个线程来进行自动发送消息了。\n\n\n\n# 利用Supervisor监控\n\n## 安装\n\nsupervisor是一个python写成的程序，因此可以简单地通过`pip`来进行安装：\n\n```shell\npip install supervisor\n```\n\n\n\n## 调整 wxpy设置\n\n如果想使用supervisor的重启功能，我们必须开启wxpy的缓存功能以储存登录状态，具体操作在登录时增加`cache_path`参数：\n\n```python\nbot = Bot(cache_path=True)\n```\n\n你也可以自由选择将缓存存在什么文件中，以免多个机器人冲突\n\n\n\n## 配置\n\n官方提供了一个默认的配置文件，你可以使用这条命令输出到你放置机器人的文件夹中：\n\n```shell\necho_supervisord_conf > supervisord.conf\n```\n\n在这个`supervisord.conf`后面，我们再追加对微信机器人程序的控制\n\n```shell\n[program:bot]  \ncommand=python ./wxbot.py              ;执行机器人文件，请修改文件名 \nprocess_name=%(program_name)s  \nautostart=true                   ; 程序是否随supervisor启动而启动  \nautorestart=true                 ;程序停止时，是否自动重启  \nstartsecs=10  \n```\n\n\n\n## 启动和控制\n\n从命令启动supervisor只需要一句：\n\n```\nsupervisord -c supervisord.conf\n```\n\n`-c`用以指定配置文件，也就是我们刚刚编写的文件。\n\n使用supervisor还可以方便的开始、重启和停止程序：\n\n```shell\nsupervisorctl start bot # 开始程序，bot 是刚刚填写的程序名\nsupervisorctl restart bot # 重启程序\nsupervisorctl stop bot # 停止程序\n```\n\n使用supervisor查看自己的程序运行状态\n\n```shell\nsupervisorctl status # 查看状态\n```\n\n因此，只要将wxpy的缓存打开，并且使用supervisor进行自动重启，我们就可以获得一个长时间保持登录的自动回复机器人啦！\n\n","slug":"机器人4","published":1,"updated":"2017-07-18T11:51:56.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj5ae0edi00052wzkn8iene48","content":"<p>由于使用网页版微信，机器人往往不能够永远地在线。如果无法一直在线，也就失去了自动回复程序的意义。在此，我们使用两种方式来监控机器人程序：</p>\n<ol>\n<li>自动定时发送消息</li>\n<li>使用supervisor进行监控</li>\n</ol>\n<h1 id=\"自动发送消息\"><a href=\"#自动发送消息\" class=\"headerlink\" title=\"自动发送消息\"></a>自动发送消息</h1><h2 id=\"准备\"><a href=\"#准备\" class=\"headerlink\" title=\"准备\"></a>准备</h2><p>如果需要定时发送消息，使用<code>sleep</code>方式来等待计时会阻塞线程，因此我们会使用<code>threading</code>来进行多线程的操作。把一个线程分配给自动给特定人发送微信消息。</p>\n<h2 id=\"定义自动发送消息的方法\"><a href=\"#定义自动发送消息的方法\" class=\"headerlink\" title=\"定义自动发送消息的方法\"></a>定义自动发送消息的方法</h2><p>在进行多线程操作之前，我们先定义一个自动发送消息的方法以备调用：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">send_online_notification</span><span class=\"params\">(name)</span>:</span></div><div class=\"line\">    my_friend = ensure_one(bot.search(name))</div><div class=\"line\">    <span class=\"keyword\">while</span> <span class=\"keyword\">True</span>:</div><div class=\"line\">        my_friend.send(<span class=\"string\">'Hello!'</span>) <span class=\"comment\"># 你想发送的消息</span></div><div class=\"line\">        time.sleep(<span class=\"number\">3600</span>) <span class=\"comment\"># 一小时后在进行发送</span></div></pre></td></tr></table></figure>\n<p>wxpy的<code>ensure_one()</code>方法会确认返回的内容仅有一个值，如果返回的列表超过一个值（或是没有返回），它会进行报错。我们在这里寻找<code>name</code>相关的好友，并且保证只有一个这样的好友。如果你需要给多个好友发送消息，我建议再使用一个循环来遍历好友列表。</p>\n<p>我们写一个阻塞线程的死循环，在死循环中给需要寻找发送特定消息，并让线程停止一小时，由此来打成定时发送消息的方法。</p>\n<h2 id=\"增加线程\"><a href=\"#增加线程\" class=\"headerlink\" title=\"增加线程\"></a>增加线程</h2><p>另一边，我们需要利用多线程调用这个方法。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">positiveSendingThread = threading.Thread(target=send_online_notification, args=(<span class=\"string\">u'乙醚。'</span>,)) <span class=\"comment\"># 请在这里输入你想要寻找的好友昵称或备注</span></div><div class=\"line\">positiveSendingThread.setDaemon(<span class=\"keyword\">True</span>)</div><div class=\"line\">positiveSendingThread.start()</div></pre></td></tr></table></figure>\n<p>这样就成功启用了一个线程来进行自动发送消息了。</p>\n<h1 id=\"利用Supervisor监控\"><a href=\"#利用Supervisor监控\" class=\"headerlink\" title=\"利用Supervisor监控\"></a>利用Supervisor监控</h1><h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p>supervisor是一个python写成的程序，因此可以简单地通过<code>pip</code>来进行安装：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">pip install supervisor</div></pre></td></tr></table></figure>\n<h2 id=\"调整-wxpy设置\"><a href=\"#调整-wxpy设置\" class=\"headerlink\" title=\"调整 wxpy设置\"></a>调整 wxpy设置</h2><p>如果想使用supervisor的重启功能，我们必须开启wxpy的缓存功能以储存登录状态，具体操作在登录时增加<code>cache_path</code>参数：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">bot = Bot(cache_path=<span class=\"keyword\">True</span>)</div></pre></td></tr></table></figure>\n<p>你也可以自由选择将缓存存在什么文件中，以免多个机器人冲突</p>\n<h2 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h2><p>官方提供了一个默认的配置文件，你可以使用这条命令输出到你放置机器人的文件夹中：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">echo_supervisord_conf &gt; supervisord.conf</div></pre></td></tr></table></figure>\n<p>在这个<code>supervisord.conf</code>后面，我们再追加对微信机器人程序的控制</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">[program:bot]  </div><div class=\"line\">command=python ./wxbot.py              ;执行机器人文件，请修改文件名 </div><div class=\"line\">process_name=%(program_name)s  </div><div class=\"line\">autostart=true                   ; 程序是否随supervisor启动而启动  </div><div class=\"line\">autorestart=true                 ;程序停止时，是否自动重启  </div><div class=\"line\">startsecs=10</div></pre></td></tr></table></figure>\n<h2 id=\"启动和控制\"><a href=\"#启动和控制\" class=\"headerlink\" title=\"启动和控制\"></a>启动和控制</h2><p>从命令启动supervisor只需要一句：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">supervisord -c supervisord.conf</div></pre></td></tr></table></figure>\n<p><code>-c</code>用以指定配置文件，也就是我们刚刚编写的文件。</p>\n<p>使用supervisor还可以方便的开始、重启和停止程序：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">supervisorctl start bot # 开始程序，bot 是刚刚填写的程序名</div><div class=\"line\">supervisorctl restart bot # 重启程序</div><div class=\"line\">supervisorctl stop bot # 停止程序</div></pre></td></tr></table></figure>\n<p>使用supervisor查看自己的程序运行状态</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">supervisorctl status # 查看状态</div></pre></td></tr></table></figure>\n<p>因此，只要将wxpy的缓存打开，并且使用supervisor进行自动重启，我们就可以获得一个长时间保持登录的自动回复机器人啦！</p>\n","site":{"data":{}},"excerpt":"","more":"<p>由于使用网页版微信，机器人往往不能够永远地在线。如果无法一直在线，也就失去了自动回复程序的意义。在此，我们使用两种方式来监控机器人程序：</p>\n<ol>\n<li>自动定时发送消息</li>\n<li>使用supervisor进行监控</li>\n</ol>\n<h1 id=\"自动发送消息\"><a href=\"#自动发送消息\" class=\"headerlink\" title=\"自动发送消息\"></a>自动发送消息</h1><h2 id=\"准备\"><a href=\"#准备\" class=\"headerlink\" title=\"准备\"></a>准备</h2><p>如果需要定时发送消息，使用<code>sleep</code>方式来等待计时会阻塞线程，因此我们会使用<code>threading</code>来进行多线程的操作。把一个线程分配给自动给特定人发送微信消息。</p>\n<h2 id=\"定义自动发送消息的方法\"><a href=\"#定义自动发送消息的方法\" class=\"headerlink\" title=\"定义自动发送消息的方法\"></a>定义自动发送消息的方法</h2><p>在进行多线程操作之前，我们先定义一个自动发送消息的方法以备调用：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">send_online_notification</span><span class=\"params\">(name)</span>:</span></div><div class=\"line\">    my_friend = ensure_one(bot.search(name))</div><div class=\"line\">    <span class=\"keyword\">while</span> <span class=\"keyword\">True</span>:</div><div class=\"line\">        my_friend.send(<span class=\"string\">'Hello!'</span>) <span class=\"comment\"># 你想发送的消息</span></div><div class=\"line\">        time.sleep(<span class=\"number\">3600</span>) <span class=\"comment\"># 一小时后在进行发送</span></div></pre></td></tr></table></figure>\n<p>wxpy的<code>ensure_one()</code>方法会确认返回的内容仅有一个值，如果返回的列表超过一个值（或是没有返回），它会进行报错。我们在这里寻找<code>name</code>相关的好友，并且保证只有一个这样的好友。如果你需要给多个好友发送消息，我建议再使用一个循环来遍历好友列表。</p>\n<p>我们写一个阻塞线程的死循环，在死循环中给需要寻找发送特定消息，并让线程停止一小时，由此来打成定时发送消息的方法。</p>\n<h2 id=\"增加线程\"><a href=\"#增加线程\" class=\"headerlink\" title=\"增加线程\"></a>增加线程</h2><p>另一边，我们需要利用多线程调用这个方法。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">positiveSendingThread = threading.Thread(target=send_online_notification, args=(<span class=\"string\">u'乙醚。'</span>,)) <span class=\"comment\"># 请在这里输入你想要寻找的好友昵称或备注</span></div><div class=\"line\">positiveSendingThread.setDaemon(<span class=\"keyword\">True</span>)</div><div class=\"line\">positiveSendingThread.start()</div></pre></td></tr></table></figure>\n<p>这样就成功启用了一个线程来进行自动发送消息了。</p>\n<h1 id=\"利用Supervisor监控\"><a href=\"#利用Supervisor监控\" class=\"headerlink\" title=\"利用Supervisor监控\"></a>利用Supervisor监控</h1><h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p>supervisor是一个python写成的程序，因此可以简单地通过<code>pip</code>来进行安装：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">pip install supervisor</div></pre></td></tr></table></figure>\n<h2 id=\"调整-wxpy设置\"><a href=\"#调整-wxpy设置\" class=\"headerlink\" title=\"调整 wxpy设置\"></a>调整 wxpy设置</h2><p>如果想使用supervisor的重启功能，我们必须开启wxpy的缓存功能以储存登录状态，具体操作在登录时增加<code>cache_path</code>参数：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">bot = Bot(cache_path=<span class=\"keyword\">True</span>)</div></pre></td></tr></table></figure>\n<p>你也可以自由选择将缓存存在什么文件中，以免多个机器人冲突</p>\n<h2 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h2><p>官方提供了一个默认的配置文件，你可以使用这条命令输出到你放置机器人的文件夹中：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">echo_supervisord_conf &gt; supervisord.conf</div></pre></td></tr></table></figure>\n<p>在这个<code>supervisord.conf</code>后面，我们再追加对微信机器人程序的控制</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">[program:bot]  </div><div class=\"line\">command=python ./wxbot.py              ;执行机器人文件，请修改文件名 </div><div class=\"line\">process_name=%(program_name)s  </div><div class=\"line\">autostart=true                   ; 程序是否随supervisor启动而启动  </div><div class=\"line\">autorestart=true                 ;程序停止时，是否自动重启  </div><div class=\"line\">startsecs=10</div></pre></td></tr></table></figure>\n<h2 id=\"启动和控制\"><a href=\"#启动和控制\" class=\"headerlink\" title=\"启动和控制\"></a>启动和控制</h2><p>从命令启动supervisor只需要一句：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">supervisord -c supervisord.conf</div></pre></td></tr></table></figure>\n<p><code>-c</code>用以指定配置文件，也就是我们刚刚编写的文件。</p>\n<p>使用supervisor还可以方便的开始、重启和停止程序：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">supervisorctl start bot # 开始程序，bot 是刚刚填写的程序名</div><div class=\"line\">supervisorctl restart bot # 重启程序</div><div class=\"line\">supervisorctl stop bot # 停止程序</div></pre></td></tr></table></figure>\n<p>使用supervisor查看自己的程序运行状态</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">supervisorctl status # 查看状态</div></pre></td></tr></table></figure>\n<p>因此，只要将wxpy的缓存打开，并且使用supervisor进行自动重启，我们就可以获得一个长时间保持登录的自动回复机器人啦！</p>\n"},{"title":"猴子都能学会的20行代码登录微博","date":"2017-07-13T16:00:00.000Z","_content":"\n如何登录新浪微博是令许多数据新手（包括我）头疼的大问题。由于新浪的反爬虫策略，网上的教程往往撑不过几个月，查阅到的资料在半年前或是一年前——而它们早就无法使用了，在你想开始爬虫的时候被活生生卡在了第一步。\n\n简单而言，我使用的方法是通过 Selenium 模拟浏览器的行为，直接在浏览器中输入用户名和密码并登录，然后直接从浏览器中获取 Cookies。虽然听起来十分简单（实际上也十分简单），但是确实是十分有效的方式。只要一个网站能通过浏览器登陆，我们就可以简单改造这个程序来登录并获得想要的资料。\n\n\n\n# 什么是Selenium？如何使用？\n\nSelenium 是一个项目的名称，都与浏览器和网页测试相关。主要的工具也就是今天我们所要使用的，是WebDriver，是一个浏览器自动化工具。它为很多不同的语言提供了库，包括 Python、Java、Ruby 等。本文中我选择使用 Python 来进行操作，当然你也可以使用你熟悉的语言来进行操作。\n\n在 Python中使用 Selenium 只需要通过`pip`安装 Selenium 提供的 Python 库。\n\n```shell\npip3 install selenium  # 如果你使用 Python 2 ，请使用 pip install selenium\n```\n\n仅仅安装 Selenium 本身是不够的，你同时还需要安装 Driver 。你可以将 Driver 理解为浏览器本身的『驱动』，在程序中使用 Driver 就相当于你打开了一个浏览器做了些什么事情。\n\n在这里我们推荐几个 Driver ：\n\n1. Firefox: https://github.com/mozilla/geckodriver/releases\n2. Chrome: https://sites.google.com/a/chromium.org/chromedriver/downloads\n3. PhantomJS: http://phantomjs.org/download.html\n\n（如果你是Windows用户，这部分内容也需要参考：http://selenium-python.readthedocs.io/installation.html#detailed-instructions-for-windows-users）\n\n下载后，我建议将可执行文件加入环境中，以备使用。\n\nFirefox 和 Chrome 相信大家都比较熟悉。PhantomJS 是一个可以让你无需浏览器就进行网页相关操作的[WebKit](https://zh.wikipedia.org/wiki/WebKit)，它也没有图形界面。个人比较推荐在调试程序期间使用 Firefox 或是 Chrome ，这样你可以通过观察发现自己哪里出了错。在调试完成后使用 PhantomJS ，来避免多余的可视化渲染。\n\n\n\n# 创建一个 WebDriver\n\n利用 Selenium 创建 WebDriver 十分简单粗暴：\n\n```python\nfrom selenium import webdriver\ndriver = webdriver.Firefox()  # 如果 Firefox 所时使用的 geckodriver 在环境中\n# driver = webdriver.PhantomJS()  # 如果你想使用 PhantomJS\n```\n\n如果你需要自定义路径，你可以通过传入参数 `executable_path`：\n\n```python\ndriver = webdriver.Firefox(executable_path=\"/path/to/geckodriver\")\n```\n\n如果你使用 Firefox 或 Chrome，你会看到这个操作打开一个浏览器。\n\n\n\n# 观察网页本身\n\n为了方便演示，我们使用新浪的移动版进行登录。如果想决定如何操作一个网页，首先我们要观察网页本身。\n\n右键登录的地方并审查元素，你会发现用户名和密码其实是简单的输入框，而登录按钮是一个链接而已。\n\n![](http://osvlzj5nm.bkt.clouddn.com/17-7-14/91396431.jpg)\n\n因此我们简单规划之后要做的事情：\n\n1. 输入用户名和密码\n2. 点击登录按钮（或摁回车）\n\n\n\n# 利用 Selenium 进行登录操作\n\n## 打开网页\n\nSelenium 提供了方法的`get`方法用以获取网页：\n\n```python\ndriver.get('https://passport.weibo.cn/signin/login')\n```\n\n如果你使用 Firefox 或 Chrome，你会看到这个操作打开微博手机版的登录页面。\n\n## 定位元素\n\n由网页本身的结构我们发现，这两个输入框和登录链接元素的`id`属性都是页面中独一无二的，我们便可以利用这一特点寻找到元素本身。\n\n```python\nname_field = driver.find_element_by_id('loginName')  # 用户名输入框\npassword_field = driver.find_element_by_id('loginPassword')  # 密码输入框\nsubmit_button = driver.find_element_by_id('loginAction')  # 登录键\n```\n\n## 输入内容\n\nSelenium 提供了为元素输入的方法 `send_keys()`，直接调用这一方法就可以把内容输入到网页中的输入框内：\n\n```python\nname_field.send_keys('你的用户名')\npassword_field.send_keys('你的密码')\n```\n\n如果你使用 Firefox 或 Chrome ，你会看到页面中的两个输入框被填入你在程序中输入的文字。\n\n点击按钮的方法也很简单，如果你已经获取了元素，只要使用`click()`方法：\n\n```python\nsubmit_button.click()  # 单击元素\n```\n\n如果你需要使用回车键，可以使用`send_keys()`来发送回车（`Keys.RETURN`），我在这里不展开描述。\n\n如果你担心两个输入框在你输入前就已经有了其他内容而影响操作，你可以使用`clear()`方法，并且我在这里也更加推荐这样的做法：\n\n```python\nname_field.clear()  # 清除用户名区域\nname_field.send_keys('你的用户名')\n\npassword_field.clear()  # 清除密码区域\npassword_field.send_keys('你的密码')\n```\n\n## 获取 Cookies\n\n从 WebDriver 获取 Cookies 只需要一个操作 `get_cookies()`：\n\n```python\ndriver.get_cookies()\n```\n\n它是一个字典文件的列表，每一个字典文件是一个 Cookie。如果你们要在其他 WebDriver 或浏览器中使用这组 Cookies ，使用一个循环来给 WebDriver 利用`add_cookie`方法添加是比较标准的方法：\n\n```python\nfor cookie in driver.get_cookies():\n    another_driver.add_cookie(cookie)\n```\n\n## 等待网页载入\n\n如果你仅仅执行上述代码，你会发现如果你的网速不够快，或是电脑不够好，就非常容易在元素出现前就进行操作，然后出现无法找到元素或是元素不可见等错误，我们可以通过等待一段时间来解决这个问题：\n\n```python\nimport time\n\n# 在获取网页后\ntime.sleep(2) # 等待2秒\n```\n\n这种做法比较简单，但也十分粗暴：因为你无法确定2秒时间足够让网页加载完成。每次打开网页的时间受限于许多因素，你可能很难用一个固定的时间来决定。而 Selenium 本身也提供了一些好用的方法：\n\n```python\nfrom selenium.webdriver.common.by import By\nfrom selenium.webdriver.support.ui import WebDriverWait\nfrom selenium.webdriver.support import expected_conditions as EC\n\n# 在获取网页后\nWebDriverWait(driver, 20).until(\n    EC.presence_of_element_located((By.ID, 'loginName'))) \n# 等待 id 为 loginName的元素出现，最多20秒\n```\n\n\n\n# 结语\n\n如何登录网站对于收集数据的人而言是个不大不小的问题。通过使用 Selenium，我们几乎可以通过各种方法模拟浏览器的操作，而且这种方法是只要浏览器存在就可以使用的。我相信如何观察网页的结构以及利用是非常有用的技能。\n\n## 完整代码\n\n```python\nimport time\nfrom selenium import webdriver\nfrom selenium.webdriver.common.by import By\nfrom selenium.webdriver.support.ui import WebDriverWait\nfrom selenium.webdriver.support import expected_conditions as EC\n\ndriver = webdriver.PhantomJS()\ndriver.get('https://passport.weibo.cn/signin/login')\nWebDriverWait(driver, 20).until(\n    EC.presence_of_element_located((By.ID, 'loginName')))\ntime.sleep(1)\n\nname_field = driver.find_element_by_id('loginName')\nname_field.clear()\nname_field.send_keys('你的用户名')\npassword_field = driver.find_element_by_id('loginPassword')\npassword_field.clear()\npassword_field.send_keys('你的密码')\nsubmit_button = driver.find_element_by_id('loginAction')\nsubmit_button.click()\n\nprint(driver.get_cookies())\n```\n\n","source":"_posts/猴子都能学会的用20行代码登录微博.md","raw":"---\ntitle: 猴子都能学会的20行代码登录微博\ndate: 2017-07-14\ncategory: 计算机课堂\ntags: \n- Python\n- 爬虫\n---\n\n如何登录新浪微博是令许多数据新手（包括我）头疼的大问题。由于新浪的反爬虫策略，网上的教程往往撑不过几个月，查阅到的资料在半年前或是一年前——而它们早就无法使用了，在你想开始爬虫的时候被活生生卡在了第一步。\n\n简单而言，我使用的方法是通过 Selenium 模拟浏览器的行为，直接在浏览器中输入用户名和密码并登录，然后直接从浏览器中获取 Cookies。虽然听起来十分简单（实际上也十分简单），但是确实是十分有效的方式。只要一个网站能通过浏览器登陆，我们就可以简单改造这个程序来登录并获得想要的资料。\n\n\n\n# 什么是Selenium？如何使用？\n\nSelenium 是一个项目的名称，都与浏览器和网页测试相关。主要的工具也就是今天我们所要使用的，是WebDriver，是一个浏览器自动化工具。它为很多不同的语言提供了库，包括 Python、Java、Ruby 等。本文中我选择使用 Python 来进行操作，当然你也可以使用你熟悉的语言来进行操作。\n\n在 Python中使用 Selenium 只需要通过`pip`安装 Selenium 提供的 Python 库。\n\n```shell\npip3 install selenium  # 如果你使用 Python 2 ，请使用 pip install selenium\n```\n\n仅仅安装 Selenium 本身是不够的，你同时还需要安装 Driver 。你可以将 Driver 理解为浏览器本身的『驱动』，在程序中使用 Driver 就相当于你打开了一个浏览器做了些什么事情。\n\n在这里我们推荐几个 Driver ：\n\n1. Firefox: https://github.com/mozilla/geckodriver/releases\n2. Chrome: https://sites.google.com/a/chromium.org/chromedriver/downloads\n3. PhantomJS: http://phantomjs.org/download.html\n\n（如果你是Windows用户，这部分内容也需要参考：http://selenium-python.readthedocs.io/installation.html#detailed-instructions-for-windows-users）\n\n下载后，我建议将可执行文件加入环境中，以备使用。\n\nFirefox 和 Chrome 相信大家都比较熟悉。PhantomJS 是一个可以让你无需浏览器就进行网页相关操作的[WebKit](https://zh.wikipedia.org/wiki/WebKit)，它也没有图形界面。个人比较推荐在调试程序期间使用 Firefox 或是 Chrome ，这样你可以通过观察发现自己哪里出了错。在调试完成后使用 PhantomJS ，来避免多余的可视化渲染。\n\n\n\n# 创建一个 WebDriver\n\n利用 Selenium 创建 WebDriver 十分简单粗暴：\n\n```python\nfrom selenium import webdriver\ndriver = webdriver.Firefox()  # 如果 Firefox 所时使用的 geckodriver 在环境中\n# driver = webdriver.PhantomJS()  # 如果你想使用 PhantomJS\n```\n\n如果你需要自定义路径，你可以通过传入参数 `executable_path`：\n\n```python\ndriver = webdriver.Firefox(executable_path=\"/path/to/geckodriver\")\n```\n\n如果你使用 Firefox 或 Chrome，你会看到这个操作打开一个浏览器。\n\n\n\n# 观察网页本身\n\n为了方便演示，我们使用新浪的移动版进行登录。如果想决定如何操作一个网页，首先我们要观察网页本身。\n\n右键登录的地方并审查元素，你会发现用户名和密码其实是简单的输入框，而登录按钮是一个链接而已。\n\n![](http://osvlzj5nm.bkt.clouddn.com/17-7-14/91396431.jpg)\n\n因此我们简单规划之后要做的事情：\n\n1. 输入用户名和密码\n2. 点击登录按钮（或摁回车）\n\n\n\n# 利用 Selenium 进行登录操作\n\n## 打开网页\n\nSelenium 提供了方法的`get`方法用以获取网页：\n\n```python\ndriver.get('https://passport.weibo.cn/signin/login')\n```\n\n如果你使用 Firefox 或 Chrome，你会看到这个操作打开微博手机版的登录页面。\n\n## 定位元素\n\n由网页本身的结构我们发现，这两个输入框和登录链接元素的`id`属性都是页面中独一无二的，我们便可以利用这一特点寻找到元素本身。\n\n```python\nname_field = driver.find_element_by_id('loginName')  # 用户名输入框\npassword_field = driver.find_element_by_id('loginPassword')  # 密码输入框\nsubmit_button = driver.find_element_by_id('loginAction')  # 登录键\n```\n\n## 输入内容\n\nSelenium 提供了为元素输入的方法 `send_keys()`，直接调用这一方法就可以把内容输入到网页中的输入框内：\n\n```python\nname_field.send_keys('你的用户名')\npassword_field.send_keys('你的密码')\n```\n\n如果你使用 Firefox 或 Chrome ，你会看到页面中的两个输入框被填入你在程序中输入的文字。\n\n点击按钮的方法也很简单，如果你已经获取了元素，只要使用`click()`方法：\n\n```python\nsubmit_button.click()  # 单击元素\n```\n\n如果你需要使用回车键，可以使用`send_keys()`来发送回车（`Keys.RETURN`），我在这里不展开描述。\n\n如果你担心两个输入框在你输入前就已经有了其他内容而影响操作，你可以使用`clear()`方法，并且我在这里也更加推荐这样的做法：\n\n```python\nname_field.clear()  # 清除用户名区域\nname_field.send_keys('你的用户名')\n\npassword_field.clear()  # 清除密码区域\npassword_field.send_keys('你的密码')\n```\n\n## 获取 Cookies\n\n从 WebDriver 获取 Cookies 只需要一个操作 `get_cookies()`：\n\n```python\ndriver.get_cookies()\n```\n\n它是一个字典文件的列表，每一个字典文件是一个 Cookie。如果你们要在其他 WebDriver 或浏览器中使用这组 Cookies ，使用一个循环来给 WebDriver 利用`add_cookie`方法添加是比较标准的方法：\n\n```python\nfor cookie in driver.get_cookies():\n    another_driver.add_cookie(cookie)\n```\n\n## 等待网页载入\n\n如果你仅仅执行上述代码，你会发现如果你的网速不够快，或是电脑不够好，就非常容易在元素出现前就进行操作，然后出现无法找到元素或是元素不可见等错误，我们可以通过等待一段时间来解决这个问题：\n\n```python\nimport time\n\n# 在获取网页后\ntime.sleep(2) # 等待2秒\n```\n\n这种做法比较简单，但也十分粗暴：因为你无法确定2秒时间足够让网页加载完成。每次打开网页的时间受限于许多因素，你可能很难用一个固定的时间来决定。而 Selenium 本身也提供了一些好用的方法：\n\n```python\nfrom selenium.webdriver.common.by import By\nfrom selenium.webdriver.support.ui import WebDriverWait\nfrom selenium.webdriver.support import expected_conditions as EC\n\n# 在获取网页后\nWebDriverWait(driver, 20).until(\n    EC.presence_of_element_located((By.ID, 'loginName'))) \n# 等待 id 为 loginName的元素出现，最多20秒\n```\n\n\n\n# 结语\n\n如何登录网站对于收集数据的人而言是个不大不小的问题。通过使用 Selenium，我们几乎可以通过各种方法模拟浏览器的操作，而且这种方法是只要浏览器存在就可以使用的。我相信如何观察网页的结构以及利用是非常有用的技能。\n\n## 完整代码\n\n```python\nimport time\nfrom selenium import webdriver\nfrom selenium.webdriver.common.by import By\nfrom selenium.webdriver.support.ui import WebDriverWait\nfrom selenium.webdriver.support import expected_conditions as EC\n\ndriver = webdriver.PhantomJS()\ndriver.get('https://passport.weibo.cn/signin/login')\nWebDriverWait(driver, 20).until(\n    EC.presence_of_element_located((By.ID, 'loginName')))\ntime.sleep(1)\n\nname_field = driver.find_element_by_id('loginName')\nname_field.clear()\nname_field.send_keys('你的用户名')\npassword_field = driver.find_element_by_id('loginPassword')\npassword_field.clear()\npassword_field.send_keys('你的密码')\nsubmit_button = driver.find_element_by_id('loginAction')\nsubmit_button.click()\n\nprint(driver.get_cookies())\n```\n\n","slug":"猴子都能学会的用20行代码登录微博","published":1,"updated":"2017-07-19T01:54:15.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj5ae0edj00062wzktkuznvc6","content":"<p>如何登录新浪微博是令许多数据新手（包括我）头疼的大问题。由于新浪的反爬虫策略，网上的教程往往撑不过几个月，查阅到的资料在半年前或是一年前——而它们早就无法使用了，在你想开始爬虫的时候被活生生卡在了第一步。</p>\n<p>简单而言，我使用的方法是通过 Selenium 模拟浏览器的行为，直接在浏览器中输入用户名和密码并登录，然后直接从浏览器中获取 Cookies。虽然听起来十分简单（实际上也十分简单），但是确实是十分有效的方式。只要一个网站能通过浏览器登陆，我们就可以简单改造这个程序来登录并获得想要的资料。</p>\n<h1 id=\"什么是Selenium？如何使用？\"><a href=\"#什么是Selenium？如何使用？\" class=\"headerlink\" title=\"什么是Selenium？如何使用？\"></a>什么是Selenium？如何使用？</h1><p>Selenium 是一个项目的名称，都与浏览器和网页测试相关。主要的工具也就是今天我们所要使用的，是WebDriver，是一个浏览器自动化工具。它为很多不同的语言提供了库，包括 Python、Java、Ruby 等。本文中我选择使用 Python 来进行操作，当然你也可以使用你熟悉的语言来进行操作。</p>\n<p>在 Python中使用 Selenium 只需要通过<code>pip</code>安装 Selenium 提供的 Python 库。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">pip3 install selenium  # 如果你使用 Python 2 ，请使用 pip install selenium</div></pre></td></tr></table></figure>\n<p>仅仅安装 Selenium 本身是不够的，你同时还需要安装 Driver 。你可以将 Driver 理解为浏览器本身的『驱动』，在程序中使用 Driver 就相当于你打开了一个浏览器做了些什么事情。</p>\n<p>在这里我们推荐几个 Driver ：</p>\n<ol>\n<li>Firefox: <a href=\"https://github.com/mozilla/geckodriver/releases\" target=\"_blank\" rel=\"external\">https://github.com/mozilla/geckodriver/releases</a></li>\n<li>Chrome: <a href=\"https://sites.google.com/a/chromium.org/chromedriver/downloads\" target=\"_blank\" rel=\"external\">https://sites.google.com/a/chromium.org/chromedriver/downloads</a></li>\n<li>PhantomJS: <a href=\"http://phantomjs.org/download.html\" target=\"_blank\" rel=\"external\">http://phantomjs.org/download.html</a></li>\n</ol>\n<p>（如果你是Windows用户，这部分内容也需要参考：<a href=\"http://selenium-python.readthedocs.io/installation.html#detailed-instructions-for-windows-users）\" target=\"_blank\" rel=\"external\">http://selenium-python.readthedocs.io/installation.html#detailed-instructions-for-windows-users）</a></p>\n<p>下载后，我建议将可执行文件加入环境中，以备使用。</p>\n<p>Firefox 和 Chrome 相信大家都比较熟悉。PhantomJS 是一个可以让你无需浏览器就进行网页相关操作的<a href=\"https://zh.wikipedia.org/wiki/WebKit\" target=\"_blank\" rel=\"external\">WebKit</a>，它也没有图形界面。个人比较推荐在调试程序期间使用 Firefox 或是 Chrome ，这样你可以通过观察发现自己哪里出了错。在调试完成后使用 PhantomJS ，来避免多余的可视化渲染。</p>\n<h1 id=\"创建一个-WebDriver\"><a href=\"#创建一个-WebDriver\" class=\"headerlink\" title=\"创建一个 WebDriver\"></a>创建一个 WebDriver</h1><p>利用 Selenium 创建 WebDriver 十分简单粗暴：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> selenium <span class=\"keyword\">import</span> webdriver</div><div class=\"line\">driver = webdriver.Firefox()  <span class=\"comment\"># 如果 Firefox 所时使用的 geckodriver 在环境中</span></div><div class=\"line\"><span class=\"comment\"># driver = webdriver.PhantomJS()  # 如果你想使用 PhantomJS</span></div></pre></td></tr></table></figure>\n<p>如果你需要自定义路径，你可以通过传入参数 <code>executable_path</code>：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">driver = webdriver.Firefox(executable_path=<span class=\"string\">\"/path/to/geckodriver\"</span>)</div></pre></td></tr></table></figure>\n<p>如果你使用 Firefox 或 Chrome，你会看到这个操作打开一个浏览器。</p>\n<h1 id=\"观察网页本身\"><a href=\"#观察网页本身\" class=\"headerlink\" title=\"观察网页本身\"></a>观察网页本身</h1><p>为了方便演示，我们使用新浪的移动版进行登录。如果想决定如何操作一个网页，首先我们要观察网页本身。</p>\n<p>右键登录的地方并审查元素，你会发现用户名和密码其实是简单的输入框，而登录按钮是一个链接而已。</p>\n<p><img src=\"http://osvlzj5nm.bkt.clouddn.com/17-7-14/91396431.jpg\" alt=\"\"></p>\n<p>因此我们简单规划之后要做的事情：</p>\n<ol>\n<li>输入用户名和密码</li>\n<li>点击登录按钮（或摁回车）</li>\n</ol>\n<h1 id=\"利用-Selenium-进行登录操作\"><a href=\"#利用-Selenium-进行登录操作\" class=\"headerlink\" title=\"利用 Selenium 进行登录操作\"></a>利用 Selenium 进行登录操作</h1><h2 id=\"打开网页\"><a href=\"#打开网页\" class=\"headerlink\" title=\"打开网页\"></a>打开网页</h2><p>Selenium 提供了方法的<code>get</code>方法用以获取网页：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">driver.get(<span class=\"string\">'https://passport.weibo.cn/signin/login'</span>)</div></pre></td></tr></table></figure>\n<p>如果你使用 Firefox 或 Chrome，你会看到这个操作打开微博手机版的登录页面。</p>\n<h2 id=\"定位元素\"><a href=\"#定位元素\" class=\"headerlink\" title=\"定位元素\"></a>定位元素</h2><p>由网页本身的结构我们发现，这两个输入框和登录链接元素的<code>id</code>属性都是页面中独一无二的，我们便可以利用这一特点寻找到元素本身。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">name_field = driver.find_element_by_id(<span class=\"string\">'loginName'</span>)  <span class=\"comment\"># 用户名输入框</span></div><div class=\"line\">password_field = driver.find_element_by_id(<span class=\"string\">'loginPassword'</span>)  <span class=\"comment\"># 密码输入框</span></div><div class=\"line\">submit_button = driver.find_element_by_id(<span class=\"string\">'loginAction'</span>)  <span class=\"comment\"># 登录键</span></div></pre></td></tr></table></figure>\n<h2 id=\"输入内容\"><a href=\"#输入内容\" class=\"headerlink\" title=\"输入内容\"></a>输入内容</h2><p>Selenium 提供了为元素输入的方法 <code>send_keys()</code>，直接调用这一方法就可以把内容输入到网页中的输入框内：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">name_field.send_keys(<span class=\"string\">'你的用户名'</span>)</div><div class=\"line\">password_field.send_keys(<span class=\"string\">'你的密码'</span>)</div></pre></td></tr></table></figure>\n<p>如果你使用 Firefox 或 Chrome ，你会看到页面中的两个输入框被填入你在程序中输入的文字。</p>\n<p>点击按钮的方法也很简单，如果你已经获取了元素，只要使用<code>click()</code>方法：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">submit_button.click()  <span class=\"comment\"># 单击元素</span></div></pre></td></tr></table></figure>\n<p>如果你需要使用回车键，可以使用<code>send_keys()</code>来发送回车（<code>Keys.RETURN</code>），我在这里不展开描述。</p>\n<p>如果你担心两个输入框在你输入前就已经有了其他内容而影响操作，你可以使用<code>clear()</code>方法，并且我在这里也更加推荐这样的做法：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">name_field.clear()  <span class=\"comment\"># 清除用户名区域</span></div><div class=\"line\">name_field.send_keys(<span class=\"string\">'你的用户名'</span>)</div><div class=\"line\"></div><div class=\"line\">password_field.clear()  <span class=\"comment\"># 清除密码区域</span></div><div class=\"line\">password_field.send_keys(<span class=\"string\">'你的密码'</span>)</div></pre></td></tr></table></figure>\n<h2 id=\"获取-Cookies\"><a href=\"#获取-Cookies\" class=\"headerlink\" title=\"获取 Cookies\"></a>获取 Cookies</h2><p>从 WebDriver 获取 Cookies 只需要一个操作 <code>get_cookies()</code>：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">driver.get_cookies()</div></pre></td></tr></table></figure>\n<p>它是一个字典文件的列表，每一个字典文件是一个 Cookie。如果你们要在其他 WebDriver 或浏览器中使用这组 Cookies ，使用一个循环来给 WebDriver 利用<code>add_cookie</code>方法添加是比较标准的方法：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">for</span> cookie <span class=\"keyword\">in</span> driver.get_cookies():</div><div class=\"line\">    another_driver.add_cookie(cookie)</div></pre></td></tr></table></figure>\n<h2 id=\"等待网页载入\"><a href=\"#等待网页载入\" class=\"headerlink\" title=\"等待网页载入\"></a>等待网页载入</h2><p>如果你仅仅执行上述代码，你会发现如果你的网速不够快，或是电脑不够好，就非常容易在元素出现前就进行操作，然后出现无法找到元素或是元素不可见等错误，我们可以通过等待一段时间来解决这个问题：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> time</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 在获取网页后</span></div><div class=\"line\">time.sleep(<span class=\"number\">2</span>) <span class=\"comment\"># 等待2秒</span></div></pre></td></tr></table></figure>\n<p>这种做法比较简单，但也十分粗暴：因为你无法确定2秒时间足够让网页加载完成。每次打开网页的时间受限于许多因素，你可能很难用一个固定的时间来决定。而 Selenium 本身也提供了一些好用的方法：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> selenium.webdriver.common.by <span class=\"keyword\">import</span> By</div><div class=\"line\"><span class=\"keyword\">from</span> selenium.webdriver.support.ui <span class=\"keyword\">import</span> WebDriverWait</div><div class=\"line\"><span class=\"keyword\">from</span> selenium.webdriver.support <span class=\"keyword\">import</span> expected_conditions <span class=\"keyword\">as</span> EC</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 在获取网页后</span></div><div class=\"line\">WebDriverWait(driver, <span class=\"number\">20</span>).until(</div><div class=\"line\">    EC.presence_of_element_located((By.ID, <span class=\"string\">'loginName'</span>))) </div><div class=\"line\"><span class=\"comment\"># 等待 id 为 loginName的元素出现，最多20秒</span></div></pre></td></tr></table></figure>\n<h1 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h1><p>如何登录网站对于收集数据的人而言是个不大不小的问题。通过使用 Selenium，我们几乎可以通过各种方法模拟浏览器的操作，而且这种方法是只要浏览器存在就可以使用的。我相信如何观察网页的结构以及利用是非常有用的技能。</p>\n<h2 id=\"完整代码\"><a href=\"#完整代码\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> time</div><div class=\"line\"><span class=\"keyword\">from</span> selenium <span class=\"keyword\">import</span> webdriver</div><div class=\"line\"><span class=\"keyword\">from</span> selenium.webdriver.common.by <span class=\"keyword\">import</span> By</div><div class=\"line\"><span class=\"keyword\">from</span> selenium.webdriver.support.ui <span class=\"keyword\">import</span> WebDriverWait</div><div class=\"line\"><span class=\"keyword\">from</span> selenium.webdriver.support <span class=\"keyword\">import</span> expected_conditions <span class=\"keyword\">as</span> EC</div><div class=\"line\"></div><div class=\"line\">driver = webdriver.PhantomJS()</div><div class=\"line\">driver.get(<span class=\"string\">'https://passport.weibo.cn/signin/login'</span>)</div><div class=\"line\">WebDriverWait(driver, <span class=\"number\">20</span>).until(</div><div class=\"line\">    EC.presence_of_element_located((By.ID, <span class=\"string\">'loginName'</span>)))</div><div class=\"line\">time.sleep(<span class=\"number\">1</span>)</div><div class=\"line\"></div><div class=\"line\">name_field = driver.find_element_by_id(<span class=\"string\">'loginName'</span>)</div><div class=\"line\">name_field.clear()</div><div class=\"line\">name_field.send_keys(<span class=\"string\">'你的用户名'</span>)</div><div class=\"line\">password_field = driver.find_element_by_id(<span class=\"string\">'loginPassword'</span>)</div><div class=\"line\">password_field.clear()</div><div class=\"line\">password_field.send_keys(<span class=\"string\">'你的密码'</span>)</div><div class=\"line\">submit_button = driver.find_element_by_id(<span class=\"string\">'loginAction'</span>)</div><div class=\"line\">submit_button.click()</div><div class=\"line\"></div><div class=\"line\">print(driver.get_cookies())</div></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>如何登录新浪微博是令许多数据新手（包括我）头疼的大问题。由于新浪的反爬虫策略，网上的教程往往撑不过几个月，查阅到的资料在半年前或是一年前——而它们早就无法使用了，在你想开始爬虫的时候被活生生卡在了第一步。</p>\n<p>简单而言，我使用的方法是通过 Selenium 模拟浏览器的行为，直接在浏览器中输入用户名和密码并登录，然后直接从浏览器中获取 Cookies。虽然听起来十分简单（实际上也十分简单），但是确实是十分有效的方式。只要一个网站能通过浏览器登陆，我们就可以简单改造这个程序来登录并获得想要的资料。</p>\n<h1 id=\"什么是Selenium？如何使用？\"><a href=\"#什么是Selenium？如何使用？\" class=\"headerlink\" title=\"什么是Selenium？如何使用？\"></a>什么是Selenium？如何使用？</h1><p>Selenium 是一个项目的名称，都与浏览器和网页测试相关。主要的工具也就是今天我们所要使用的，是WebDriver，是一个浏览器自动化工具。它为很多不同的语言提供了库，包括 Python、Java、Ruby 等。本文中我选择使用 Python 来进行操作，当然你也可以使用你熟悉的语言来进行操作。</p>\n<p>在 Python中使用 Selenium 只需要通过<code>pip</code>安装 Selenium 提供的 Python 库。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">pip3 install selenium  # 如果你使用 Python 2 ，请使用 pip install selenium</div></pre></td></tr></table></figure>\n<p>仅仅安装 Selenium 本身是不够的，你同时还需要安装 Driver 。你可以将 Driver 理解为浏览器本身的『驱动』，在程序中使用 Driver 就相当于你打开了一个浏览器做了些什么事情。</p>\n<p>在这里我们推荐几个 Driver ：</p>\n<ol>\n<li>Firefox: <a href=\"https://github.com/mozilla/geckodriver/releases\" target=\"_blank\" rel=\"external\">https://github.com/mozilla/geckodriver/releases</a></li>\n<li>Chrome: <a href=\"https://sites.google.com/a/chromium.org/chromedriver/downloads\" target=\"_blank\" rel=\"external\">https://sites.google.com/a/chromium.org/chromedriver/downloads</a></li>\n<li>PhantomJS: <a href=\"http://phantomjs.org/download.html\" target=\"_blank\" rel=\"external\">http://phantomjs.org/download.html</a></li>\n</ol>\n<p>（如果你是Windows用户，这部分内容也需要参考：<a href=\"http://selenium-python.readthedocs.io/installation.html#detailed-instructions-for-windows-users）\" target=\"_blank\" rel=\"external\">http://selenium-python.readthedocs.io/installation.html#detailed-instructions-for-windows-users）</a></p>\n<p>下载后，我建议将可执行文件加入环境中，以备使用。</p>\n<p>Firefox 和 Chrome 相信大家都比较熟悉。PhantomJS 是一个可以让你无需浏览器就进行网页相关操作的<a href=\"https://zh.wikipedia.org/wiki/WebKit\" target=\"_blank\" rel=\"external\">WebKit</a>，它也没有图形界面。个人比较推荐在调试程序期间使用 Firefox 或是 Chrome ，这样你可以通过观察发现自己哪里出了错。在调试完成后使用 PhantomJS ，来避免多余的可视化渲染。</p>\n<h1 id=\"创建一个-WebDriver\"><a href=\"#创建一个-WebDriver\" class=\"headerlink\" title=\"创建一个 WebDriver\"></a>创建一个 WebDriver</h1><p>利用 Selenium 创建 WebDriver 十分简单粗暴：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> selenium <span class=\"keyword\">import</span> webdriver</div><div class=\"line\">driver = webdriver.Firefox()  <span class=\"comment\"># 如果 Firefox 所时使用的 geckodriver 在环境中</span></div><div class=\"line\"><span class=\"comment\"># driver = webdriver.PhantomJS()  # 如果你想使用 PhantomJS</span></div></pre></td></tr></table></figure>\n<p>如果你需要自定义路径，你可以通过传入参数 <code>executable_path</code>：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">driver = webdriver.Firefox(executable_path=<span class=\"string\">\"/path/to/geckodriver\"</span>)</div></pre></td></tr></table></figure>\n<p>如果你使用 Firefox 或 Chrome，你会看到这个操作打开一个浏览器。</p>\n<h1 id=\"观察网页本身\"><a href=\"#观察网页本身\" class=\"headerlink\" title=\"观察网页本身\"></a>观察网页本身</h1><p>为了方便演示，我们使用新浪的移动版进行登录。如果想决定如何操作一个网页，首先我们要观察网页本身。</p>\n<p>右键登录的地方并审查元素，你会发现用户名和密码其实是简单的输入框，而登录按钮是一个链接而已。</p>\n<p><img src=\"http://osvlzj5nm.bkt.clouddn.com/17-7-14/91396431.jpg\" alt=\"\"></p>\n<p>因此我们简单规划之后要做的事情：</p>\n<ol>\n<li>输入用户名和密码</li>\n<li>点击登录按钮（或摁回车）</li>\n</ol>\n<h1 id=\"利用-Selenium-进行登录操作\"><a href=\"#利用-Selenium-进行登录操作\" class=\"headerlink\" title=\"利用 Selenium 进行登录操作\"></a>利用 Selenium 进行登录操作</h1><h2 id=\"打开网页\"><a href=\"#打开网页\" class=\"headerlink\" title=\"打开网页\"></a>打开网页</h2><p>Selenium 提供了方法的<code>get</code>方法用以获取网页：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">driver.get(<span class=\"string\">'https://passport.weibo.cn/signin/login'</span>)</div></pre></td></tr></table></figure>\n<p>如果你使用 Firefox 或 Chrome，你会看到这个操作打开微博手机版的登录页面。</p>\n<h2 id=\"定位元素\"><a href=\"#定位元素\" class=\"headerlink\" title=\"定位元素\"></a>定位元素</h2><p>由网页本身的结构我们发现，这两个输入框和登录链接元素的<code>id</code>属性都是页面中独一无二的，我们便可以利用这一特点寻找到元素本身。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">name_field = driver.find_element_by_id(<span class=\"string\">'loginName'</span>)  <span class=\"comment\"># 用户名输入框</span></div><div class=\"line\">password_field = driver.find_element_by_id(<span class=\"string\">'loginPassword'</span>)  <span class=\"comment\"># 密码输入框</span></div><div class=\"line\">submit_button = driver.find_element_by_id(<span class=\"string\">'loginAction'</span>)  <span class=\"comment\"># 登录键</span></div></pre></td></tr></table></figure>\n<h2 id=\"输入内容\"><a href=\"#输入内容\" class=\"headerlink\" title=\"输入内容\"></a>输入内容</h2><p>Selenium 提供了为元素输入的方法 <code>send_keys()</code>，直接调用这一方法就可以把内容输入到网页中的输入框内：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">name_field.send_keys(<span class=\"string\">'你的用户名'</span>)</div><div class=\"line\">password_field.send_keys(<span class=\"string\">'你的密码'</span>)</div></pre></td></tr></table></figure>\n<p>如果你使用 Firefox 或 Chrome ，你会看到页面中的两个输入框被填入你在程序中输入的文字。</p>\n<p>点击按钮的方法也很简单，如果你已经获取了元素，只要使用<code>click()</code>方法：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">submit_button.click()  <span class=\"comment\"># 单击元素</span></div></pre></td></tr></table></figure>\n<p>如果你需要使用回车键，可以使用<code>send_keys()</code>来发送回车（<code>Keys.RETURN</code>），我在这里不展开描述。</p>\n<p>如果你担心两个输入框在你输入前就已经有了其他内容而影响操作，你可以使用<code>clear()</code>方法，并且我在这里也更加推荐这样的做法：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">name_field.clear()  <span class=\"comment\"># 清除用户名区域</span></div><div class=\"line\">name_field.send_keys(<span class=\"string\">'你的用户名'</span>)</div><div class=\"line\"></div><div class=\"line\">password_field.clear()  <span class=\"comment\"># 清除密码区域</span></div><div class=\"line\">password_field.send_keys(<span class=\"string\">'你的密码'</span>)</div></pre></td></tr></table></figure>\n<h2 id=\"获取-Cookies\"><a href=\"#获取-Cookies\" class=\"headerlink\" title=\"获取 Cookies\"></a>获取 Cookies</h2><p>从 WebDriver 获取 Cookies 只需要一个操作 <code>get_cookies()</code>：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">driver.get_cookies()</div></pre></td></tr></table></figure>\n<p>它是一个字典文件的列表，每一个字典文件是一个 Cookie。如果你们要在其他 WebDriver 或浏览器中使用这组 Cookies ，使用一个循环来给 WebDriver 利用<code>add_cookie</code>方法添加是比较标准的方法：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">for</span> cookie <span class=\"keyword\">in</span> driver.get_cookies():</div><div class=\"line\">    another_driver.add_cookie(cookie)</div></pre></td></tr></table></figure>\n<h2 id=\"等待网页载入\"><a href=\"#等待网页载入\" class=\"headerlink\" title=\"等待网页载入\"></a>等待网页载入</h2><p>如果你仅仅执行上述代码，你会发现如果你的网速不够快，或是电脑不够好，就非常容易在元素出现前就进行操作，然后出现无法找到元素或是元素不可见等错误，我们可以通过等待一段时间来解决这个问题：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> time</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 在获取网页后</span></div><div class=\"line\">time.sleep(<span class=\"number\">2</span>) <span class=\"comment\"># 等待2秒</span></div></pre></td></tr></table></figure>\n<p>这种做法比较简单，但也十分粗暴：因为你无法确定2秒时间足够让网页加载完成。每次打开网页的时间受限于许多因素，你可能很难用一个固定的时间来决定。而 Selenium 本身也提供了一些好用的方法：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> selenium.webdriver.common.by <span class=\"keyword\">import</span> By</div><div class=\"line\"><span class=\"keyword\">from</span> selenium.webdriver.support.ui <span class=\"keyword\">import</span> WebDriverWait</div><div class=\"line\"><span class=\"keyword\">from</span> selenium.webdriver.support <span class=\"keyword\">import</span> expected_conditions <span class=\"keyword\">as</span> EC</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 在获取网页后</span></div><div class=\"line\">WebDriverWait(driver, <span class=\"number\">20</span>).until(</div><div class=\"line\">    EC.presence_of_element_located((By.ID, <span class=\"string\">'loginName'</span>))) </div><div class=\"line\"><span class=\"comment\"># 等待 id 为 loginName的元素出现，最多20秒</span></div></pre></td></tr></table></figure>\n<h1 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h1><p>如何登录网站对于收集数据的人而言是个不大不小的问题。通过使用 Selenium，我们几乎可以通过各种方法模拟浏览器的操作，而且这种方法是只要浏览器存在就可以使用的。我相信如何观察网页的结构以及利用是非常有用的技能。</p>\n<h2 id=\"完整代码\"><a href=\"#完整代码\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> time</div><div class=\"line\"><span class=\"keyword\">from</span> selenium <span class=\"keyword\">import</span> webdriver</div><div class=\"line\"><span class=\"keyword\">from</span> selenium.webdriver.common.by <span class=\"keyword\">import</span> By</div><div class=\"line\"><span class=\"keyword\">from</span> selenium.webdriver.support.ui <span class=\"keyword\">import</span> WebDriverWait</div><div class=\"line\"><span class=\"keyword\">from</span> selenium.webdriver.support <span class=\"keyword\">import</span> expected_conditions <span class=\"keyword\">as</span> EC</div><div class=\"line\"></div><div class=\"line\">driver = webdriver.PhantomJS()</div><div class=\"line\">driver.get(<span class=\"string\">'https://passport.weibo.cn/signin/login'</span>)</div><div class=\"line\">WebDriverWait(driver, <span class=\"number\">20</span>).until(</div><div class=\"line\">    EC.presence_of_element_located((By.ID, <span class=\"string\">'loginName'</span>)))</div><div class=\"line\">time.sleep(<span class=\"number\">1</span>)</div><div class=\"line\"></div><div class=\"line\">name_field = driver.find_element_by_id(<span class=\"string\">'loginName'</span>)</div><div class=\"line\">name_field.clear()</div><div class=\"line\">name_field.send_keys(<span class=\"string\">'你的用户名'</span>)</div><div class=\"line\">password_field = driver.find_element_by_id(<span class=\"string\">'loginPassword'</span>)</div><div class=\"line\">password_field.clear()</div><div class=\"line\">password_field.send_keys(<span class=\"string\">'你的密码'</span>)</div><div class=\"line\">submit_button = driver.find_element_by_id(<span class=\"string\">'loginAction'</span>)</div><div class=\"line\">submit_button.click()</div><div class=\"line\"></div><div class=\"line\">print(driver.get_cookies())</div></pre></td></tr></table></figure>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cj5ae0edi00052wzkn8iene48","category_id":"cj5ae0edc00022wzkh10bik1e","_id":"cj5ae0edr00092wzkluzqilgg"},{"post_id":"cj5ae0ed300002wzkjyqvvp3u","category_id":"cj5ae0edc00022wzkh10bik1e","_id":"cj5ae0eds000c2wzklo51ou1m"},{"post_id":"cj5ae0edj00062wzktkuznvc6","category_id":"cj5ae0edc00022wzkh10bik1e","_id":"cj5ae0edt000e2wzkp7frbthh"},{"post_id":"cj5ae0ed900012wzkv24nfnzt","category_id":"cj5ae0edc00022wzkh10bik1e","_id":"cj5ae0edu000h2wzkk2bye05v"},{"post_id":"cj5ae0edf00042wzk7ytapitm","category_id":"cj5ae0edc00022wzkh10bik1e","_id":"cj5ae0edu000i2wzk1kbuhylf"}],"PostTag":[{"post_id":"cj5ae0ed300002wzkjyqvvp3u","tag_id":"cj5ae0edf00032wzkisga8mn0","_id":"cj5ae0edt000d2wzkrj1jba3b"},{"post_id":"cj5ae0ed300002wzkjyqvvp3u","tag_id":"cj5ae0edm00082wzk3a1qeb3y","_id":"cj5ae0edt000f2wzkjebcqzz8"},{"post_id":"cj5ae0ed900012wzkv24nfnzt","tag_id":"cj5ae0edf00032wzkisga8mn0","_id":"cj5ae0edv000k2wzk1mkeabn3"},{"post_id":"cj5ae0ed900012wzkv24nfnzt","tag_id":"cj5ae0edm00082wzk3a1qeb3y","_id":"cj5ae0edv000l2wzkedvhz47f"},{"post_id":"cj5ae0edf00042wzk7ytapitm","tag_id":"cj5ae0edf00032wzkisga8mn0","_id":"cj5ae0edz000o2wzkqv1ds1vm"},{"post_id":"cj5ae0edf00042wzk7ytapitm","tag_id":"cj5ae0edm00082wzk3a1qeb3y","_id":"cj5ae0edz000p2wzk17digaf8"},{"post_id":"cj5ae0edi00052wzkn8iene48","tag_id":"cj5ae0edf00032wzkisga8mn0","_id":"cj5ae0ee1000r2wzkwhyder4e"},{"post_id":"cj5ae0edi00052wzkn8iene48","tag_id":"cj5ae0edm00082wzk3a1qeb3y","_id":"cj5ae0ee1000s2wzk34ehcdg8"},{"post_id":"cj5ae0edj00062wzktkuznvc6","tag_id":"cj5ae0edf00032wzkisga8mn0","_id":"cj5ae0ee2000t2wzkwdizjods"},{"post_id":"cj5ae0edj00062wzktkuznvc6","tag_id":"cj5ae0edz000q2wzkshf445f1","_id":"cj5ae0ee2000u2wzkrnadyutm"}],"Tag":[{"name":"Python","_id":"cj5ae0edf00032wzkisga8mn0"},{"name":"聊天机器人","_id":"cj5ae0edm00082wzk3a1qeb3y"},{"name":"爬虫","_id":"cj5ae0edz000q2wzkshf445f1"}]}}